{"version":3,"sources":["../../../../node_modules/tslib/tslib.es6.js","../../../../projects/ajsf-core/src/lib/shared/utility.functions.ts","../../../../projects/ajsf-core/src/lib/shared/convert-schema-to-draft6.function.ts","../../../../projects/ajsf-core/src/lib/shared/validator.functions.ts","../../../../projects/ajsf-core/src/lib/framework-library/framework.ts","../../../../projects/ajsf-core/src/lib/shared/jsonpointer.functions.ts","../../../../projects/ajsf-core/src/lib/shared/format-regex.constants.ts","../../../../projects/ajsf-core/src/lib/shared/json.validators.ts","../../../../projects/ajsf-core/src/lib/shared/merge-schemas.function.ts","../../../../projects/ajsf-core/src/lib/shared/json-schema.functions.ts","../../../../projects/ajsf-core/src/lib/shared/form-group.functions.ts","../../../../projects/ajsf-core/src/lib/shared/layout.functions.ts","../../../../projects/ajsf-core/src/lib/locale-dates/en-US.ts","../../../../projects/ajsf-core/src/lib/locale/de-validation-messages.ts","../../../../projects/ajsf-core/src/lib/locale/en-validation-messages.ts","../../../../projects/ajsf-core/src/lib/locale/es-validation-messages.ts","../../../../projects/ajsf-core/src/lib/locale/fr-validation-messages.ts","../../../../projects/ajsf-core/src/lib/locale/it-validation-messages.ts","../../../../projects/ajsf-core/src/lib/locale/pt-validation-messages.ts","../../../../projects/ajsf-core/src/lib/locale/zh-validation-messages.ts","../../../../projects/ajsf-core/src/lib/json-schema-form.service.ts","../../../../projects/ajsf-core/src/lib/widget-library/add-reference.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/button.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/checkbox.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/checkboxes.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/file.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/input.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/message.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/none.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/number.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/one-of.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/radios.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/root.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/section.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/select.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/select-framework.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/select-widget.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/submit.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/tabs.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/template.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/textarea.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/widget-library.service.ts","../../../../projects/ajsf-core/src/lib/framework-library/framework-library.service.ts","../../../../projects/ajsf-core/src/lib/json-schema-form.component.ts","../../../../projects/ajsf-core/src/lib/framework-library/no-framework.component.ts","../../../../projects/ajsf-core/src/lib/framework-library/no.framework.ts","../../../../projects/ajsf-core/src/lib/widget-library/hidden.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/tab.component.ts","../../../../projects/ajsf-core/src/lib/widget-library/orderable.directive.ts","../../../../projects/ajsf-core/src/lib/widget-library/index.ts","../../../../projects/ajsf-core/src/lib/widget-library/widget-library.module.ts","../../../../projects/ajsf-core/src/lib/framework-library/no-framework.module.ts","../../../../projects/ajsf-core/src/lib/json-schema-form.module.ts","../../../../projects/ajsf-core/src/lib/shared/date.functions.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","create","__values","o","s","Symbol","iterator","m","i","length","next","value","done","TypeError","__read","n","r","e","ar","push","error","__spread","arguments","concat","ExpressionType","convertSchemaToDraft6","schema","options","draft","changed","map","subSchema","newSchema","assign","simpleTypes","$schema","test","contentEncoding","media","binaryEncoding","extends","allOf","disallow","not","type","anyOf","dependencies","keys","some","key","filter","forEach","maxDecimal","multipleOf","Math","pow","divisibleBy","minimum","minimumCanEqual","exclusiveMinimum","maximum","maximumCanEqual","exclusiveMaximum","properties","properties_1","requiredKeys_1","isArray","required","Set","optional","add","size","from","requires","dependencies_1","id","$id","slice","every","includes","addToDescription","description","arrayKeys","numberKeys","objectKeys","stringKeys","filterKeys_1","array","integer","number","object","string","all","newType","_b","_c","default","typeSchema","newKey_1","subKey","cloneDeep","_executeValidators","control","validators","invert","validator","_executeAsyncValidators","_mergeObjects","objects","_i","mergedObject","objects_1","objects_1_1","currentObject","isObject","e_2","_d","currentValue","mergedValue","isDefined","isBoolean","xor","getType","_mergeErrors","arrayOfErrors","mergedErrors","apply","isEmpty","hasValue","isString","isNumber","strict","isNaN","isInteger","option","item","isDate","toString","isMap","isSet","isType","console","isPrimitive","toJavaScriptType","types","strictIntegers","inArray","parseInt","parseFloat","toISOString","getTime","toSchemaType","testValue","isPromise","then","isObservable","subscribe","toObservable","observable","Observable","allIn","subItem","value1","value2","copy","errors","Map","fn","recurse","rootObject","forEachCopy","newObject","hasOwn","property","has","isEqual","expressionType","EQUALS","isNotEqual","NOT_EQUALS","mergeFilteredObject","targetObject","sourceObject","excludeKeys","keyFn","valFn","val","uniqueItems","items","returnItems","items_1","items_1_1","commonItems","arrays","arrays_1","arrays_1_1","fixTitle","name","toTitleCase","replace","input","forceWords","forceArray","split","forceArrayLower","w","toLowerCase","noInitialCase","toUpperCase","prevLastChar","trim","word","idx","search","newWord","forceWord","indexOf","this","widgets","stylesheets","scripts","Injectable","JsonPointer","get","pointer","startSlice","endSlice","getBoolean","undefined","keyArray","parse","subObject","keyArray_1","keyArray_1_1","evaluatedExpression","evaluateExpression","passed","logErrors","defaultResult","keysAndExpression","parseKeysAndExpression","ownCheckResult","doOwnCheckResult","keyAndValue","cleanedValue","charAt","evaluatedResult","performExpressionOnValue","propertyByKey","doComparisonByExpressionType","keyOrSubObjEmpty","expressionCandidate","NOT_AN_EXPRESSION","isNotExpression","getKeyAndValueByExpressionType","getCopy","objectToCopy","forEachDeepCopy","getFirst","defaultValue","items_2","items_2_1","isJsonPointer","getFirstCopy","set","insert","match","lastKey","splice","setCopy","insertCopy","remove","pop","parentObject","dict","results","forEachDeep","bottomUp","v","newPointer","escape","unescape","compile","_this","join","toKey","isSubPointer","shortPointer","longPointer","trueIfMatching","invalid","toIndexedPointer","genericPointer","indexArray","arrayMap","indexedPointer_1","arrayIndex_1","stringIndex","indexArray_1","indexArray_1_1","pointerIndex","toGenericPointer","indexedPointer","pointerArray","subPointer","toControlPointer","dataPointer","formGroup","controlMustExist","dataPointerArray","controlPointerArray","subGroup","dataPointerArray_1","dataPointerArray_1_1","controls","toSchemaPointer","firstKey","shift","additionalProperties","arrayItem","additionalItems","toDataPointer","schemaPointer","pointerSuffix","secondKey","parseObjectPath","path","index","parts","nextDot","nextOB","quote","nextCB","RegExp","jsonSchemaFormatTests","date","time","date-time","email","hostname","ipv4","ipv6","uri","uri-reference","uri-template","url","uuid","color","json-pointer","relative-json-pointer","regex","str","JsonValidators","nullValidator","requiredType","enum","allowedValues","isEqualVal","enumValue","inputValue","const","requiredValue","constValue","minLength","minimumLength","currentLength","maxLength","maximumLength","pattern","wholeString","requiredPattern","format","requiredFormat","isValid","formatTest","minimumValue","exclusiveMinimumValue","maximumValue","exclusiveMaximumValue","multipleOfValue","minProperties","minimumProperties","currentProperties","maxProperties","maximumProperties","allErrors","requiringField","requiredFields","requiringFieldErrors","requiredFields_1","requiredFields_1_1","requiredField","requirements","requiredFieldErrors","requirement","parameter","exclusive","_a","minItems","minimumItems","currentItems","maxItems","maximumItems","unique","sorted","sort","duplicateItems","contains","requiredItem","composeAnyOf","presentValidators","composeOneOf","arrayOfValids","oneOf","composeAllOf","combinedErrors","composeNot","compose","composeAsync","observables","forkJoin","min","actual","max","requiredTrue","mergeSchemas","schemas","combinedSchema","schemas_1","schemas_1_1","x","y","combinedValue","schemaValue","item1","findIndex","item2","combinedObject","_e","e_3","_f","definitions","_g","e_4","_h","combinedDependency","schemaDependency","gcd_1","notAnyOf","reduce","notAnyOfArray","notSchema","_j","e_5","_k","patternProperties","combinedObject_1","combinedKey","nonMatchingKey","_l","e_6","_m","combinedTypes","buildSchemaFromLayout","layout","buildSchemaFromData","data","requireAllFields","isRoot","getFieldType","fieldType","null","buildSubSchema","a","getFromSchema","returnType","subSchemaFound","removeRecursiveReferences","recursiveRefMap","possibleReferences","toPointer","fromPointer","getInputType","layoutNode","controlType","checkInlineType","schemaType","getTitleMapFromOneOf","isInputRequired","listPointerArray","keyName","nextToLastKey","parentSchema","updateInputOptions","jsf","newOptions","fixUiKeys","formOptions","defautWidgetOptions","newTitleMap","flatList","titleMap","enumNames","typeahead","autocomplete","tagsinput","validateOnly","title","newTitleMap_1","group","getControlValidators","prop","ucLimit","eLimit","limit","resolveSchemaReferences","schemaRefLibrary","schemaRecursiveRefMap","dataRecursiveRefMap","refLinks","refMapSet","refMap","refLibrary","subSchemaPointer","refPointer","ref","getSubSchema","checkRefLinks","fromRef1","toRef1","fromRef2","toRef2","refLink","fromRef","toRef","compiledSchema","$ref","fromDataRef","toDataRef","tupleItems","usedPointers","refPointer_1","ptr","refSchema","extraKeys","combineAllOf","fixRequiredArrayProperties","mergedSchema","itemsObject_1","buildFormGroupTemplate","nodeValue","setValues","templatePointer","setSchemaDefaults","formValues","shortDataPointer","dataMap","nodeOptions","propertyKeys_1","unnamedKeys","fieldsRequired","setRequiredFields","additionalItemsPointer","schemaRefPointer","itemRecursive","itemRefPointer","templateRefLibrary","itemOptions","arrayLength","schemaRef","newTemplate","disabled","buildFormGroup","template","validatorFns","validatorFn","parameters","groupControls_1","newControl","FormGroup","FormArray","FormControl","formControlTemplate","requiredArray","formatFormData","formData","returnEmptyFields","fixErrors","formattedData","newValue","getControl","returnGroup","formControl","buildLayout","widgetLibrary","hasSubmitButton","formLayout","mapLayout","layoutItem","layoutPointer","newNode","_id","uniqueId","widget","legend","validationMessages","errorMessages","validationMessage","code","newKey","nodeSchema","findDataPointer_1","searchItem","childDataPointer","lastIndexOf","buildLayoutFromSchema","LastKey","recursive_1","nodeDataMap","hasWidget","oldWidgetType","dataType","listItems","copyValueTo","getWidget","itemRefPointer_1","arrayItemGroup","unshift","arrayItemType","removable","orderable","arrayListItems","layoutRefLibrary","recursiveReference","getLayoutNode","addable","buttonText","fieldStyle","style","parentType","hasRootReference","fullLayout","forRefLibrary","dataPointerPrefix","newNodeType","lastDataKey","newSection_1","keySchemaPointer","innerItem","additionalItemsSchemaPointer","newItem","itemSchemaPointer","prefix","dataRef","newLayout","rootLayout","indexPad","realIndex","newLayoutPointer","itemsArray","tabs","refNode","newLayoutNode","subNode","buildTitleMap","enumList","fieldRequired","hasEmptyValue","groupTitleMap","longMonths","longDays","shortMonths","shortDays","deValidationMessages","log10","enValidationMessages","esValidationMessages","frValidationMessages","itValidationMessages","ptValidationMessages","zhValidationMessages","JsonSchemaFormService","JsonFormCompatibility","ReactJsonSchemaFormCompatibility","AngularSchemaFormCompatibility","tpldata","ajvOptions","jsonPointers","unknownFormats","ajv","Ajv","validateFormData","formGroupTemplate","framework","validData","ajvErrors","validationErrors","dataErrors","formValueSubscription","dataChanges","Subject","isValidChanges","validationErrorChanges","","language","defaultFormOptions","addSubmit","debug","disableInvalidSubmit","formDisabled","formReadonly","loadExternalAssets","pristine","success","supressPropertyTitles","setLayoutDefaults","validateOnRender","enableErrorState","enableSuccessState","feedback","feedbackOnRender","notitle","readonly","setLanguage","addMetaSchema","jsonDraft6","de","en","es","fr","it","pt","zh","getData","getSchema","getLayout","resetAllValues","buildRemoteError","value_1","value_1_1","err","setErrors","emitEvent","validateData","updateSubscriptions","compiledErrors","dataPath","message","compileAjvSchema","unsubscribe","valueChanges","formValue","setOptions","addOptions","defaultOptions","globalDefaults_1","suffix","removeSchema","setTpldata","newTpldata","parseText","text","values","parseExpression","expression","delim","term","setArrayItemTitle","parentCtx","childNode","parentNode","parentValues","getFormControlValue","isArrayItem","childValue","setItemTitle","ctx","getFormControlGroup","dataIndex","evaluateCondition","arrayIndex","result","condition","model","functionBody","Function","dynFn","initializeControl","bind","getFormControl","boundControl","controlName","getFormControlName","controlValue","controlDisabled","errorMessage","status","formatErrors","showErrors","statusChanges","getDataPointer","addSpaces","formatError","errorKey","errorProperty","updateValue","setValue","markAsDirty","targetControl","updateArrayCheckboxList","checkboxList","formArray","removeAt","checkboxList_1","checkboxList_1_1","checkboxItem","checked","newFormControl","getLayoutArray","getLayoutPointer","getParentNode","layoutIndex","isControlBound","controlGroup","addItem","newFormGroup","addControl","moveArrayItem","oldIndex","newIndex","at","updateValueAndValidity","layoutArray","removeItem","removeControl","args","providedIn","AddReferenceComponent","ngOnInit","defineProperty","event","preventDefault","parent","itemCount","Component","selector","changeDetection","ChangeDetectionStrategy","Default","Input","ButtonComponent","onClick","target","CheckboxComponent","trueValue","falseValue","CheckboxesComponent","layoutOrientation","formArray_1","FileComponent","InputComponent","autoCompleteList","MessageComponent","help","helpvalue","msg","NumberComponent","allowNegative","allowDecimal","allowExponents","lastValidNumber","OneOfComponent","RadiosComponent","radiosList","RootComponent","isFlexItem","isDraggable","node","isOrderable","getFlexAttribute","attribute","flex","showWidget","SectionComponent","expanded","expandable","containerType","toggleExpanded","flexActive","displayFlex","display","SelectComponent","selectList","SelectFrameworkComponent","componentFactory","newComponent","updateComponent","ngOnChanges","widgetContainer","createComponent","resolveComponentFactory","instance","ComponentFactoryResolver","ViewChild","read","ViewContainerRef","static","SelectWidgetComponent","SubmitComponent","TabsComponent","selectedItem","showAddTab","updateControl","select","lastItem","setTabTitle","TemplateComponent","TextareaComponent","WidgetLibraryService","defaultWidget","none","NoneComponent","root","select-framework","select-widget","password","tel","datetime","datetime-local","month","range","week","checkbox","file","hidden","image","radio","reset","submit","button","textarea","checkboxes","checkboxes-inline","checkboxbuttons","radios","radios-inline","radiobuttons","section","div","fieldset","one-of","tabarray","tab","html","advancedfieldset","authfieldset","optionfieldset","selectfieldset","conditional","actions","updown","alt-datetime","alt-date","wizard","textline","registeredWidgets","frameworkWidgets","activeWidgets","setActiveWidgets","widgetName","usedAliases","setDefaultWidget","widgetSet","hasDefaultWidget","registerWidget","unRegisterWidget","unRegisterAllWidgets","unRegisterFrameworkWidgets","registerFrameworkWidgets","getAllWidgets","FrameworkLibraryService","frameworks","activeFramework","frameworkLibrary","defaultFramework","setFramework","setLoadExternalAssets","hasFramework","getFramework","getFrameworkWidgets","getFrameworkStylesheets","load","getFrameworkScripts","Inject","Framework","decorators","JsonSchemaFormComponent","changeDetector","formInitialized","objectWrap","previousInputs","form","JSONSchema","UISchema","onChanges","EventEmitter","onSubmit","formSchema","dataChange","modelChange","formDataChange","ngModelChange","setFormValues","resetScriptsAndStyleSheets","document","querySelectorAll","element","loadScripts","script","scriptTag","createElement","src","async","setAttribute","getElementsByTagName","appendChild","loadStyleSheets","stylesheet","linkTag","rel","href","loadAssets","updateForm","changes","isFirstChange","previousValue","writeValue","formValuesInput","registerOnChange","onChange","registerOnTouched","onTouched","setDisabledState","isDisabled","initializeForm","changedInput","resetFirst","startsWith","newFormValues","activateForm","patchValue","submitForm","emit","ngModel","initializeOptions","initializeSchema","initializeLayout","initializeData","debugOutput","JSON","stringify","1","fixJsonFormOptions","alternateLayout","uiSchema","customFormItems","groupPointer","itemPointer","markForCheck","validateOnRender_1","touchAll_1","markAsTouched","OnPush","ChangeDetectorRef","Output","NoFramework","_super","NoFrameworkComponent","String","__","constructor","__extends","HiddenComponent","TabComponent","OrderableDirective","elementRef","ngZone","overParentElement","overChildElement","nativeElement","draggable","arrayLayoutIndex","runOutsideAngular","addEventListener","dataTransfer","effectAllowed","setData","sourceArrayIndex","sessionStorage","setItem","dropEffect","getItem","classList","destArrayIndex","Directive","ElementRef","NgZone","BASIC_WIDGETS","NgModule","imports","CommonModule","FormsModule","ReactiveFormsModule","declarations","exports","entryComponents","WidgetLibraryModule","providers","provide","useClass","multi","NoFrameworkModule","toPromise","oldClasses","newClasses","badType","toSet","combinedSet","c","dateFormat","Date","getDate","year","getFullYear","getMonth","day","dayOfWeek","getDay","getOrdinal"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from) {\r\n    for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\r\n        to[j] = from[i];\r\n    return to;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import {hasValue, inArray, isArray, isDefined, isEmpty, isMap, isObject, isSet, isString, PlainObject} from './validator.functions';\n\n/**\n * Utility function library:\n *\n * addClasses, copy, forEach, forEachCopy, hasOwn, mergeFilteredObject,\n * uniqueItems, commonItems, fixTitle, toTitleCase\n*/\n\n/**\n * 'addClasses' function\n *\n * Merges two space-delimited lists of CSS classes and removes duplicates.\n *\n * // {string | string[] | Set<string>} oldClasses\n * // {string | string[] | Set<string>} newClasses\n * // {string | string[] | Set<string>} - Combined classes\n */\nexport function addClasses(\n  oldClasses: string | string[] | Set<string>,\n  newClasses: string | string[] | Set<string>\n): string | string[] | Set<string> {\n  const badType = i => !isSet(i) && !isArray(i) && !isString(i);\n  if (badType(newClasses)) { return oldClasses; }\n  if (badType(oldClasses)) { oldClasses = ''; }\n  const toSet = i => isSet(i) ? i : isArray(i) ? new Set(i) : new Set(i.split(' '));\n  const combinedSet: Set<any> = toSet(oldClasses);\n  const newSet: Set<any> = toSet(newClasses);\n  newSet.forEach(c => combinedSet.add(c));\n  if (isSet(oldClasses)) { return combinedSet; }\n  if (isArray(oldClasses)) { return Array.from(combinedSet); }\n  return Array.from(combinedSet).join(' ');\n}\n\n/**\n * 'copy' function\n *\n * Makes a shallow copy of a JavaScript object, array, Map, or Set.\n * If passed a JavaScript primitive value (string, number, boolean, or null),\n * it returns the value.\n *\n * // {Object|Array|string|number|boolean|null} object - The object to copy\n * // {boolean = false} errors - Show errors?\n * // {Object|Array|string|number|boolean|null} - The copied object\n */\nexport function copy(object: any, errors = false): any {\n  if (typeof object !== 'object' || object === null) { return object; }\n  if (isMap(object))    { return new Map(object); }\n  if (isSet(object))    { return new Set(object); }\n  if (isArray(object))  { return [ ...object ];   }\n  if (isObject(object)) { return { ...object };   }\n  if (errors) {\n    console.error('copy error: Object to copy must be a JavaScript object or value.');\n  }\n  return object;\n}\n\n/**\n * 'forEach' function\n *\n * Iterates over all items in the first level of an object or array\n * and calls an iterator funciton on each item.\n *\n * The iterator function is called with four values:\n * 1. The current item's value\n * 2. The current item's key\n * 3. The parent object, which contains the current item\n * 4. The root object\n *\n * Setting the optional third parameter to 'top-down' or 'bottom-up' will cause\n * it to also recursively iterate over items in sub-objects or sub-arrays in the\n * specified direction.\n *\n * // {Object|Array} object - The object or array to iterate over\n * // {function} fn - the iterator funciton to call on each item\n * // {boolean = false} errors - Show errors?\n * // {void}\n */\nexport function forEach(\n  object: any, fn: (v: any, k?: string | number, c?: any, rc?: any) => any,\n  recurse: boolean | string = false, rootObject: any = object, errors = false\n): void {\n  if (isEmpty(object)) { return; }\n  if ((isObject(object) || isArray(object)) && typeof fn === 'function') {\n    for (const key of Object.keys(object)) {\n      const value = object[key];\n      if (recurse === 'bottom-up' && (isObject(value) || isArray(value))) {\n        forEach(value, fn, recurse, rootObject);\n      }\n      fn(value, key, object, rootObject);\n      if (recurse === 'top-down' && (isObject(value) || isArray(value))) {\n        forEach(value, fn, recurse, rootObject);\n      }\n    }\n  }\n  if (errors) {\n    if (typeof fn !== 'function') {\n      console.error('forEach error: Iterator must be a function.');\n      console.error('function', fn);\n    }\n    if (!isObject(object) && !isArray(object)) {\n      console.error('forEach error: Input object must be an object or array.');\n      console.error('object', object);\n    }\n  }\n}\n\n/**\n * 'forEachCopy' function\n *\n * Iterates over all items in the first level of an object or array\n * and calls an iterator function on each item. Returns a new object or array\n * with the same keys or indexes as the original, and values set to the results\n * of the iterator function.\n *\n * Does NOT recursively iterate over items in sub-objects or sub-arrays.\n *\n * // {Object | Array} object - The object or array to iterate over\n * // {function} fn - The iterator funciton to call on each item\n * // {boolean = false} errors - Show errors?\n * // {Object | Array} - The resulting object or array\n */\nexport function forEachCopy(\n  object: any, fn: (v: any, k?: string | number, o?: any, p?: string) => any,\n  errors = false\n): any {\n  if (!hasValue(object)) { return; }\n  if ((isObject(object) || isArray(object)) && typeof object !== 'function') {\n    const newObject: any = isArray(object) ? [] : {};\n    for (const key of Object.keys(object)) {\n      newObject[key] = fn(object[key], key, object);\n    }\n    return newObject;\n  }\n  if (errors) {\n    if (typeof fn !== 'function') {\n      console.error('forEachCopy error: Iterator must be a function.');\n      console.error('function', fn);\n    }\n    if (!isObject(object) && !isArray(object)) {\n      console.error('forEachCopy error: Input object must be an object or array.');\n      console.error('object', object);\n    }\n  }\n}\n\n/**\n * 'hasOwn' utility function\n *\n * Checks whether an object or array has a particular property.\n *\n * // {any} object - the object to check\n * // {string} property - the property to look for\n * // {boolean} - true if object has property, false if not\n */\nexport function hasOwn(object: any, property: string): boolean {\n  if (!object || !['number', 'string', 'symbol'].includes(typeof property) ||\n    (!isObject(object) && !isArray(object) && !isMap(object) && !isSet(object))\n  ) { return false; }\n  if (isMap(object) || isSet(object)) { return object.has(property); }\n  if (typeof property === 'number') {\n    if (isArray(object)) { return object[<number>property]; }\n    property = property + '';\n  }\n  return object.hasOwnProperty(property);\n}\n\n/**\n * Types of possible expressions which the app is able to evaluate.\n */\nexport enum ExpressionType {\n  EQUALS,\n  NOT_EQUALS,\n  NOT_AN_EXPRESSION\n}\n\n/**\n * Detects the type of expression from the given candidate. `==` for equals,\n * `!=` for not equals. If none of these are contained in the candidate, the candidate\n * is not considered to be an expression at all and thus `NOT_AN_EXPRESSION` is returned.\n * // {expressionCandidate} expressionCandidate - potential expression\n */\nexport function getExpressionType(expressionCandidate: string): ExpressionType {\n  if (expressionCandidate.indexOf('==') !== -1) {\n    return ExpressionType.EQUALS;\n  }\n\n  if (expressionCandidate.toString().indexOf('!=') !== -1) {\n    return ExpressionType.NOT_EQUALS;\n  }\n\n  return ExpressionType.NOT_AN_EXPRESSION;\n}\n\nexport function isEqual(expressionType) {\n  return expressionType as ExpressionType === ExpressionType.EQUALS;\n}\n\nexport function isNotEqual(expressionType) {\n  return expressionType as ExpressionType === ExpressionType.NOT_EQUALS;\n}\n\nexport function isNotExpression(expressionType) {\n  return expressionType as ExpressionType === ExpressionType.NOT_AN_EXPRESSION;\n}\n\n/**\n * Splits the expression key by the expressionType on a pair of values\n * before and after the equals or nor equals sign.\n * // {expressionType} enum of an expression type\n * // {key} the given key from a for loop iver all conditions\n */\nexport function getKeyAndValueByExpressionType(expressionType: ExpressionType, key: string) {\n  if (isEqual(expressionType)) {\n    return key.split('==', 2);\n  }\n\n  if (isNotEqual(expressionType)) {\n    return key.split('!=', 2);\n  }\n\n  return null;\n}\n\nexport function cleanValueOfQuotes(keyAndValue): String {\n  if (keyAndValue.charAt(0) === '\\'' && keyAndValue.charAt(keyAndValue.length - 1) === '\\'') {\n    return keyAndValue.replace('\\'', '').replace('\\'', '');\n  }\n  return keyAndValue;\n}\n\n/**\n * 'mergeFilteredObject' utility function\n *\n * Shallowly merges two objects, setting key and values from source object\n * in target object, excluding specified keys.\n *\n * Optionally, it can also use functions to transform the key names and/or\n * the values of the merging object.\n *\n * // {PlainObject} targetObject - Target object to add keys and values to\n * // {PlainObject} sourceObject - Source object to copy keys and values from\n * // {string[]} excludeKeys - Array of keys to exclude\n * // {(string: string) => string = (k) => k} keyFn - Function to apply to keys\n * // {(any: any) => any = (v) => v} valueFn - Function to apply to values\n * // {PlainObject} - Returns targetObject\n */\nexport function mergeFilteredObject(\n  targetObject: PlainObject,\n  sourceObject: PlainObject,\n  excludeKeys = <string[]>[],\n  keyFn = (key: string): string => key,\n  valFn = (val: any): any => val\n): PlainObject {\n  if (!isObject(sourceObject)) { return targetObject; }\n  if (!isObject(targetObject)) { targetObject = {}; }\n  for (const key of Object.keys(sourceObject)) {\n    if (!inArray(key, excludeKeys) && isDefined(sourceObject[key])) {\n      targetObject[keyFn(key)] = valFn(sourceObject[key]);\n    }\n  }\n  return targetObject;\n}\n\n/**\n * 'uniqueItems' function\n *\n * Accepts any number of string value inputs,\n * and returns an array of all input vaues, excluding duplicates.\n *\n * // {...string} ...items -\n * // {string[]} -\n */\nexport function uniqueItems(...items): string[] {\n  const returnItems = [];\n  for (const item of items) {\n    if (!returnItems.includes(item)) { returnItems.push(item); }\n  }\n  return returnItems;\n}\n\n/**\n * 'commonItems' function\n *\n * Accepts any number of strings or arrays of string values,\n * and returns a single array containing only values present in all inputs.\n *\n * // {...string|string[]} ...arrays -\n * // {string[]} -\n */\nexport function commonItems(...arrays): string[] {\n  let returnItems = null;\n  for (let array of arrays) {\n    if (isString(array)) { array = [array]; }\n    returnItems = returnItems === null ? [ ...array ] :\n      returnItems.filter(item => array.includes(item));\n    if (!returnItems.length) { return []; }\n  }\n  return returnItems;\n}\n\n/**\n * 'fixTitle' function\n *\n *\n * // {string} input -\n * // {string} -\n */\nexport function fixTitle(name: string): string {\n  return name && toTitleCase(name.replace(/([a-z])([A-Z])/g, '$1 $2').replace(/_/g, ' '));\n}\n\n/**\n * 'toTitleCase' function\n *\n * Intelligently converts an input string to Title Case.\n *\n * Accepts an optional second parameter with a list of additional\n * words and abbreviations to force into a particular case.\n *\n * This function is built on prior work by John Gruber and David Gouch:\n * http://daringfireball.net/2008/08/title_case_update\n * https://github.com/gouch/to-title-case\n *\n * // {string} input -\n * // {string|string[]} forceWords? -\n * // {string} -\n */\nexport function toTitleCase(input: string, forceWords?: string|string[]): string {\n  if (!isString(input)) { return input; }\n  let forceArray: string[] = ['a', 'an', 'and', 'as', 'at', 'but', 'by', 'en',\n   'for', 'if', 'in', 'nor', 'of', 'on', 'or', 'per', 'the', 'to', 'v', 'v.',\n   'vs', 'vs.', 'via'];\n  if (isString(forceWords)) { forceWords = (<string>forceWords).split('|'); }\n  if (isArray(forceWords)) { forceArray = forceArray.concat(forceWords); }\n  const forceArrayLower: string[] = forceArray.map(w => w.toLowerCase());\n  const noInitialCase: boolean =\n    input === input.toUpperCase() || input === input.toLowerCase();\n  let prevLastChar = '';\n  input = input.trim();\n  return input.replace(/[A-Za-z0-9\\u00C0-\\u00FF]+[^\\s-]*/g, (word, idx) => {\n    if (!noInitialCase && word.slice(1).search(/[A-Z]|\\../) !== -1) {\n      return word;\n    } else {\n      let newWord: string;\n      const forceWord: string =\n        forceArray[forceArrayLower.indexOf(word.toLowerCase())];\n      if (!forceWord) {\n        if (noInitialCase) {\n          if (word.slice(1).search(/\\../) !== -1) {\n            newWord = word.toLowerCase();\n          } else {\n            newWord = word[0].toUpperCase() + word.slice(1).toLowerCase();\n          }\n        } else {\n          newWord = word[0].toUpperCase() + word.slice(1);\n        }\n      } else if (\n        forceWord === forceWord.toLowerCase() && (\n          idx === 0 || idx + word.length === input.length ||\n          prevLastChar === ':' || input[idx - 1].search(/[^\\s-]/) !== -1 ||\n          (input[idx - 1] !== '-' && input[idx + word.length] === '-')\n        )\n      ) {\n        newWord = forceWord[0].toUpperCase() + forceWord.slice(1);\n      } else {\n        newWord = forceWord;\n      }\n      prevLastChar = word.slice(-1);\n      return newWord;\n    }\n  });\n}\n","import cloneDeep from 'lodash/cloneDeep';\n\n/**\n * 'convertSchemaToDraft6' function\n *\n * Converts a JSON Schema from draft 1 through 4 format to draft 6 format\n *\n * Inspired by on geraintluff's JSON Schema 3 to 4 compatibility function:\n *   https://github.com/geraintluff/json-schema-compatibility\n * Also uses suggestions from AJV's JSON Schema 4 to 6 migration guide:\n *   https://github.com/epoberezkin/ajv/releases/tag/5.0.0\n * And additional details from the official JSON Schema documentation:\n *   http://json-schema.org\n *\n * //  { object } originalSchema - JSON schema (draft 1, 2, 3, 4, or 6)\n * //  { OptionObject = {} } options - options: parent schema changed?, schema draft number?\n * // { object } - JSON schema (draft 6)\n */\nexport interface OptionObject { changed?: boolean; draft?: number; }\nexport function convertSchemaToDraft6(schema, options: OptionObject = {}) {\n  let draft: number = options.draft || null;\n  let changed: boolean = options.changed || false;\n\n  if (typeof schema !== 'object') { return schema; }\n  if (typeof schema.map === 'function') {\n    return [...schema.map(subSchema => convertSchemaToDraft6(subSchema, { changed, draft }))];\n  }\n  let newSchema = { ...schema };\n  const simpleTypes = ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string'];\n\n  if (typeof newSchema.$schema === 'string' &&\n    /http\\:\\/\\/json\\-schema\\.org\\/draft\\-0\\d\\/schema\\#/.test(newSchema.$schema)\n  ) {\n    draft = newSchema.$schema[30];\n  }\n\n  // Convert v1-v2 'contentEncoding' to 'media.binaryEncoding'\n  // Note: This is only used in JSON hyper-schema (not regular JSON schema)\n  if (newSchema.contentEncoding) {\n    newSchema.media = { binaryEncoding: newSchema.contentEncoding };\n    delete newSchema.contentEncoding;\n    changed = true;\n  }\n\n  // Convert v1-v3 'extends' to 'allOf'\n  if (typeof newSchema.extends === 'object') {\n    newSchema.allOf = typeof newSchema.extends.map === 'function' ?\n      newSchema.extends.map(subSchema => convertSchemaToDraft6(subSchema, { changed, draft })) :\n      [convertSchemaToDraft6(newSchema.extends, { changed, draft })];\n    delete newSchema.extends;\n    changed = true;\n  }\n\n  // Convert v1-v3 'disallow' to 'not'\n  if (newSchema.disallow) {\n    if (typeof newSchema.disallow === 'string') {\n      newSchema.not = { type: newSchema.disallow };\n    } else if (typeof newSchema.disallow.map === 'function') {\n      newSchema.not = {\n        anyOf: newSchema.disallow\n          .map(type => typeof type === 'object' ? type : { type })\n      };\n    }\n    delete newSchema.disallow;\n    changed = true;\n  }\n\n  // Convert v3 string 'dependencies' properties to arrays\n  if (typeof newSchema.dependencies === 'object' &&\n    Object.keys(newSchema.dependencies)\n      .some(key => typeof newSchema.dependencies[key] === 'string')\n  ) {\n    newSchema.dependencies = { ...newSchema.dependencies };\n    Object.keys(newSchema.dependencies)\n      .filter(key => typeof newSchema.dependencies[key] === 'string')\n      .forEach(key => newSchema.dependencies[key] = [newSchema.dependencies[key]]);\n    changed = true;\n  }\n\n  // Convert v1 'maxDecimal' to 'multipleOf'\n  if (typeof newSchema.maxDecimal === 'number') {\n    newSchema.multipleOf = 1 / Math.pow(10, newSchema.maxDecimal);\n    delete newSchema.divisibleBy;\n    changed = true;\n    if (!draft || draft === 2) { draft = 1; }\n  }\n\n  // Convert v2-v3 'divisibleBy' to 'multipleOf'\n  if (typeof newSchema.divisibleBy === 'number') {\n    newSchema.multipleOf = newSchema.divisibleBy;\n    delete newSchema.divisibleBy;\n    changed = true;\n  }\n\n  // Convert v1-v2 boolean 'minimumCanEqual' to 'exclusiveMinimum'\n  if (typeof newSchema.minimum === 'number' && newSchema.minimumCanEqual === false) {\n    newSchema.exclusiveMinimum = newSchema.minimum;\n    delete newSchema.minimum;\n    changed = true;\n    if (!draft) { draft = 2; }\n  } else if (typeof newSchema.minimumCanEqual === 'boolean') {\n    delete newSchema.minimumCanEqual;\n    changed = true;\n    if (!draft) { draft = 2; }\n  }\n\n  // Convert v3-v4 boolean 'exclusiveMinimum' to numeric\n  if (typeof newSchema.minimum === 'number' && newSchema.exclusiveMinimum === true) {\n    newSchema.exclusiveMinimum = newSchema.minimum;\n    delete newSchema.minimum;\n    changed = true;\n  } else if (typeof newSchema.exclusiveMinimum === 'boolean') {\n    delete newSchema.exclusiveMinimum;\n    changed = true;\n  }\n\n  // Convert v1-v2 boolean 'maximumCanEqual' to 'exclusiveMaximum'\n  if (typeof newSchema.maximum === 'number' && newSchema.maximumCanEqual === false) {\n    newSchema.exclusiveMaximum = newSchema.maximum;\n    delete newSchema.maximum;\n    changed = true;\n    if (!draft) { draft = 2; }\n  } else if (typeof newSchema.maximumCanEqual === 'boolean') {\n    delete newSchema.maximumCanEqual;\n    changed = true;\n    if (!draft) { draft = 2; }\n  }\n\n  // Convert v3-v4 boolean 'exclusiveMaximum' to numeric\n  if (typeof newSchema.maximum === 'number' && newSchema.exclusiveMaximum === true) {\n    newSchema.exclusiveMaximum = newSchema.maximum;\n    delete newSchema.maximum;\n    changed = true;\n  } else if (typeof newSchema.exclusiveMaximum === 'boolean') {\n    delete newSchema.exclusiveMaximum;\n    changed = true;\n  }\n\n  // Search object 'properties' for 'optional', 'required', and 'requires' items,\n  // and convert them into object 'required' arrays and 'dependencies' objects\n  if (typeof newSchema.properties === 'object') {\n    const properties = { ...newSchema.properties };\n    const requiredKeys = Array.isArray(newSchema.required) ?\n      new Set(newSchema.required) : new Set();\n\n    // Convert v1-v2 boolean 'optional' properties to 'required' array\n    if (draft === 1 || draft === 2 ||\n      Object.keys(properties).some(key => properties[key].optional === true)\n    ) {\n      Object.keys(properties)\n        .filter(key => properties[key].optional !== true)\n        .forEach(key => requiredKeys.add(key));\n      changed = true;\n      if (!draft) { draft = 2; }\n    }\n\n    // Convert v3 boolean 'required' properties to 'required' array\n    if (Object.keys(properties).some(key => properties[key].required === true)) {\n      Object.keys(properties)\n        .filter(key => properties[key].required === true)\n        .forEach(key => requiredKeys.add(key));\n      changed = true;\n    }\n\n    if (requiredKeys.size) { newSchema.required = Array.from(requiredKeys); }\n\n    // Convert v1-v2 array or string 'requires' properties to 'dependencies' object\n    if (Object.keys(properties).some(key => properties[key].requires)) {\n      const dependencies = typeof newSchema.dependencies === 'object' ?\n        { ...newSchema.dependencies } : {};\n      Object.keys(properties)\n        .filter(key => properties[key].requires)\n        .forEach(key => dependencies[key] =\n          typeof properties[key].requires === 'string' ?\n            [properties[key].requires] : properties[key].requires\n        );\n      newSchema.dependencies = dependencies;\n      changed = true;\n      if (!draft) { draft = 2; }\n    }\n\n    newSchema.properties = properties;\n  }\n\n  // Revove v1-v2 boolean 'optional' key\n  if (typeof newSchema.optional === 'boolean') {\n    delete newSchema.optional;\n    changed = true;\n    if (!draft) { draft = 2; }\n  }\n\n  // Revove v1-v2 'requires' key\n  if (newSchema.requires) {\n    delete newSchema.requires;\n  }\n\n  // Revove v3 boolean 'required' key\n  if (typeof newSchema.required === 'boolean') {\n    delete newSchema.required;\n  }\n\n  // Convert id to $id\n  if (typeof newSchema.id === 'string' && !newSchema.$id) {\n    if (newSchema.id.slice(-1) === '#') {\n      newSchema.id = newSchema.id.slice(0, -1);\n    }\n    newSchema.$id = newSchema.id + '-CONVERTED-TO-DRAFT-06#';\n    delete newSchema.id;\n    changed = true;\n  }\n\n  // Check if v1-v3 'any' or object types will be converted\n  if (newSchema.type && (typeof newSchema.type.every === 'function' ?\n    !newSchema.type.every(type => simpleTypes.includes(type)) :\n    !simpleTypes.includes(newSchema.type)\n  )) {\n    changed = true;\n  }\n\n  // If schema changed, update or remove $schema identifier\n  if (typeof newSchema.$schema === 'string' &&\n    /http\\:\\/\\/json\\-schema\\.org\\/draft\\-0[1-4]\\/schema\\#/.test(newSchema.$schema)\n  ) {\n    newSchema.$schema = 'http://json-schema.org/draft-06/schema#';\n    changed = true;\n  } else if (changed && typeof newSchema.$schema === 'string') {\n    const addToDescription = 'Converted to draft 6 from ' + newSchema.$schema;\n    if (typeof newSchema.description === 'string' && newSchema.description.length) {\n      newSchema.description += '\\n' + addToDescription;\n    } else {\n      newSchema.description = addToDescription;\n    }\n    delete newSchema.$schema;\n  }\n\n  // Convert v1-v3 'any' and object types\n  if (newSchema.type && (typeof newSchema.type.every === 'function' ?\n    !newSchema.type.every(type => simpleTypes.includes(type)) :\n    !simpleTypes.includes(newSchema.type)\n  )) {\n    if (newSchema.type.length === 1) { newSchema.type = newSchema.type[0]; }\n    if (typeof newSchema.type === 'string') {\n      // Convert string 'any' type to array of all standard types\n      if (newSchema.type === 'any') {\n        newSchema.type = simpleTypes;\n        // Delete non-standard string type\n      } else {\n        delete newSchema.type;\n      }\n    } else if (typeof newSchema.type === 'object') {\n      if (typeof newSchema.type.every === 'function') {\n        // If array of strings, only allow standard types\n        if (newSchema.type.every(type => typeof type === 'string')) {\n          newSchema.type = newSchema.type.some(type => type === 'any') ?\n            newSchema.type = simpleTypes :\n            newSchema.type.filter(type => simpleTypes.includes(type));\n          // If type is an array with objects, convert the current schema to an 'anyOf' array\n        } else if (newSchema.type.length > 1) {\n          const arrayKeys = ['additionalItems', 'items', 'maxItems', 'minItems', 'uniqueItems', 'contains'];\n          const numberKeys = ['multipleOf', 'maximum', 'exclusiveMaximum', 'minimum', 'exclusiveMinimum'];\n          const objectKeys = ['maxProperties', 'minProperties', 'required', 'additionalProperties',\n            'properties', 'patternProperties', 'dependencies', 'propertyNames'];\n          const stringKeys = ['maxLength', 'minLength', 'pattern', 'format'];\n          const filterKeys = {\n            'array': [...numberKeys, ...objectKeys, ...stringKeys],\n            'integer': [...arrayKeys, ...objectKeys, ...stringKeys],\n            'number': [...arrayKeys, ...objectKeys, ...stringKeys],\n            'object': [...arrayKeys, ...numberKeys, ...stringKeys],\n            'string': [...arrayKeys, ...numberKeys, ...objectKeys],\n            'all': [...arrayKeys, ...numberKeys, ...objectKeys, ...stringKeys],\n          };\n          const anyOf = [];\n          for (const type of newSchema.type) {\n            const newType = typeof type === 'string' ? { type } : { ...type };\n            Object.keys(newSchema)\n              .filter(key => !newType.hasOwnProperty(key) &&\n                ![...(filterKeys[newType.type] || filterKeys.all), 'type', 'default']\n                  .includes(key)\n              )\n              .forEach(key => newType[key] = newSchema[key]);\n            anyOf.push(newType);\n          }\n          newSchema = newSchema.hasOwnProperty('default') ?\n            { anyOf, default: newSchema.default } : { anyOf };\n          // If type is an object, merge it with the current schema\n        } else {\n          const typeSchema = newSchema.type;\n          delete newSchema.type;\n          Object.assign(newSchema, typeSchema);\n        }\n      }\n    } else {\n      delete newSchema.type;\n    }\n  }\n\n  // Convert sub schemas\n  Object.keys(newSchema)\n    .filter(key => typeof newSchema[key] === 'object')\n    .forEach(key => {\n      if (\n        ['definitions', 'dependencies', 'properties', 'patternProperties']\n          .includes(key) && typeof newSchema[key].map !== 'function'\n      ) {\n        const newKey = {};\n        Object.keys(newSchema[key]).forEach(subKey => newKey[subKey] =\n          convertSchemaToDraft6(newSchema[key][subKey], { changed, draft })\n        );\n        newSchema[key] = newKey;\n      } else if (\n        ['items', 'additionalItems', 'additionalProperties',\n          'allOf', 'anyOf', 'oneOf', 'not'].includes(key)\n      ) {\n        newSchema[key] = convertSchemaToDraft6(newSchema[key], { changed, draft });\n      } else {\n        newSchema[key] = cloneDeep(newSchema[key]);\n      }\n    });\n\n  return newSchema;\n}\n","import { AbstractControl } from '@angular/forms';\nimport { from, Observable } from 'rxjs';\n\n/**\n * Validator utility function library:\n *\n * Validator and error utilities:\n *   _executeValidators, _executeAsyncValidators, _mergeObjects, _mergeErrors\n *\n * Individual value checking:\n *   isDefined, hasValue, isEmpty\n *\n * Individual type checking:\n *   isString, isNumber, isInteger, isBoolean, isFunction, isObject, isArray,\n *   isMap, isSet, isPromise, isObservable\n *\n * Multiple type checking and fixing:\n *   getType, isType, isPrimitive, toJavaScriptType, toSchemaType,\n *   _toPromise, toObservable\n *\n * Utility functions:\n *   inArray, xor\n *\n * Typescript types and interfaces:\n *   SchemaPrimitiveType, SchemaType, JavaScriptPrimitiveType, JavaScriptType,\n *   PrimitiveValue, PlainObject, IValidatorFn, AsyncIValidatorFn\n *\n * Note: 'IValidatorFn' is short for 'invertable validator function',\n *   which is a validator functions that accepts an optional second\n *   argument which, if set to TRUE, causes the validator to perform\n *   the opposite of its original function.\n */\n\nexport type SchemaPrimitiveType =\n  'string' | 'number' | 'integer' | 'boolean' | 'null';\nexport type SchemaType =\n  'string' | 'number' | 'integer' | 'boolean' | 'null' | 'object' | 'array';\nexport type JavaScriptPrimitiveType =\n  'string' | 'number' | 'boolean' | 'null' | 'undefined';\nexport type JavaScriptType =\n  'string' | 'number' | 'boolean' | 'null' | 'undefined' | 'object' | 'array' |\n  'map' | 'set' | 'arguments' | 'date' | 'error' | 'function' | 'json' |\n  'math' | 'regexp'; // Note: this list is incomplete\nexport type PrimitiveValue = string | number | boolean | null | undefined;\nexport interface PlainObject { [k: string]: any; }\n\nexport type IValidatorFn = (c: AbstractControl, i?: boolean) => PlainObject;\nexport type AsyncIValidatorFn = (c: AbstractControl, i?: boolean) => any;\n\n/**\n * '_executeValidators' utility function\n *\n * Validates a control against an array of validators, and returns\n * an array of the same length containing a combination of error messages\n * (from invalid validators) and null values (from valid validators)\n *\n * //  { AbstractControl } control - control to validate\n * //  { IValidatorFn[] } validators - array of validators\n * //  { boolean } invert - invert?\n * // { PlainObject[] } - array of nulls and error message\n */\nexport function _executeValidators(control, validators, invert = false) {\n  return validators.map(validator => validator(control, invert));\n}\n\n/**\n * '_executeAsyncValidators' utility function\n *\n * Validates a control against an array of async validators, and returns\n * an array of observabe results of the same length containing a combination of\n * error messages (from invalid validators) and null values (from valid ones)\n *\n * //  { AbstractControl } control - control to validate\n * //  { AsyncIValidatorFn[] } validators - array of async validators\n * //  { boolean } invert - invert?\n * //  - array of observable nulls and error message\n */\nexport function _executeAsyncValidators(control, validators, invert = false) {\n  return validators.map(validator => validator(control, invert));\n}\n\n/**\n * '_mergeObjects' utility function\n *\n * Recursively Merges one or more objects into a single object with combined keys.\n * Automatically detects and ignores null and undefined inputs.\n * Also detects duplicated boolean 'not' keys and XORs their values.\n *\n * //  { PlainObject[] } objects - one or more objects to merge\n * // { PlainObject } - merged object\n */\nexport function _mergeObjects(...objects) {\n  const mergedObject: PlainObject = { };\n  for (const currentObject of objects) {\n    if (isObject(currentObject)) {\n      for (const key of Object.keys(currentObject)) {\n        const currentValue = currentObject[key];\n        const mergedValue = mergedObject[key];\n        mergedObject[key] = !isDefined(mergedValue) ? currentValue :\n          key === 'not' && isBoolean(mergedValue, 'strict') &&\n            isBoolean(currentValue, 'strict') ? xor(mergedValue, currentValue) :\n          getType(mergedValue) === 'object' && getType(currentValue) === 'object' ?\n            _mergeObjects(mergedValue, currentValue) :\n            currentValue;\n      }\n    }\n  }\n  return mergedObject;\n}\n\n/**\n * '_mergeErrors' utility function\n *\n * Merges an array of objects.\n * Used for combining the validator errors returned from 'executeValidators'\n *\n * //  { PlainObject[] } arrayOfErrors - array of objects\n * // { PlainObject } - merged object, or null if no usable input objectcs\n */\nexport function _mergeErrors(arrayOfErrors) {\n  const mergedErrors = _mergeObjects(...arrayOfErrors);\n  return isEmpty(mergedErrors) ? null : mergedErrors;\n}\n\n/**\n * 'isDefined' utility function\n *\n * Checks if a variable contains a value of any type.\n * Returns true even for otherwise 'falsey' values of 0, '', and false.\n *\n * //   value - the value to check\n * // { boolean } - false if undefined or null, otherwise true\n */\nexport function isDefined(value) {\n  return value !== undefined && value !== null;\n}\n\n/**\n * 'hasValue' utility function\n *\n * Checks if a variable contains a value.\n * Returs false for null, undefined, or a zero-length strng, '',\n * otherwise returns true.\n * (Stricter than 'isDefined' because it also returns false for '',\n * though it stil returns true for otherwise 'falsey' values 0 and false.)\n *\n * //   value - the value to check\n * // { boolean } - false if undefined, null, or '', otherwise true\n */\nexport function hasValue(value) {\n  return value !== undefined && value !== null && value !== '';\n}\n\n/**\n * 'isEmpty' utility function\n *\n * Similar to !hasValue, but also returns true for empty arrays and objects.\n *\n * //   value - the value to check\n * // { boolean } - false if undefined, null, or '', otherwise true\n */\nexport function isEmpty(value) {\n  if (isArray(value)) { return !value.length; }\n  if (isObject(value)) { return !Object.keys(value).length; }\n  return value === undefined || value === null || value === '';\n}\n\n/**\n * 'isString' utility function\n *\n * Checks if a value is a string.\n *\n * //   value - the value to check\n * // { boolean } - true if string, false if not\n */\nexport function isString(value) {\n  return typeof value === 'string';\n}\n\n/**\n * 'isNumber' utility function\n *\n * Checks if a value is a regular number, numeric string, or JavaScript Date.\n *\n * //   value - the value to check\n * //  { any = false } strict - if truthy, also checks JavaScript tyoe\n * // { boolean } - true if number, false if not\n */\nexport function isNumber(value, strict: any = false) {\n  if (strict && typeof value !== 'number') { return false; }\n  return !isNaN(value) && value !== value / 0;\n}\n\n/**\n * 'isInteger' utility function\n *\n * Checks if a value is an integer.\n *\n * //   value - the value to check\n * //  { any = false } strict - if truthy, also checks JavaScript tyoe\n * // {boolean } - true if number, false if not\n */\nexport function isInteger(value, strict: any = false) {\n  if (strict && typeof value !== 'number') { return false; }\n  return !isNaN(value) &&  value !== value / 0 && value % 1 === 0;\n}\n\n/**\n * 'isBoolean' utility function\n *\n * Checks if a value is a boolean.\n *\n * //   value - the value to check\n * //  { any = null } option - if 'strict', also checks JavaScript type\n *                              if TRUE or FALSE, checks only for that value\n * // { boolean } - true if boolean, false if not\n */\nexport function isBoolean(value, option: any = null) {\n  if (option === 'strict') { return value === true || value === false; }\n  if (option === true) {\n    return value === true || value === 1 || value === 'true' || value === '1';\n  }\n  if (option === false) {\n    return value === false || value === 0 || value === 'false' || value === '0';\n  }\n  return value === true || value === 1 || value === 'true' || value === '1' ||\n    value === false || value === 0 || value === 'false' || value === '0';\n}\n\nexport function isFunction(item: any): boolean {\n  return typeof item === 'function';\n}\n\nexport function isObject(item: any): boolean {\n  return item !== null && typeof item === 'object';\n}\n\nexport function isArray(item: any): boolean {\n  return Array.isArray(item);\n}\n\nexport function isDate(item: any): boolean {\n  return !!item && Object.prototype.toString.call(item) === '[object Date]';\n}\n\nexport function isMap(item: any): boolean {\n  return !!item && Object.prototype.toString.call(item) === '[object Map]';\n}\n\nexport function isSet(item: any): boolean {\n  return !!item && Object.prototype.toString.call(item) === '[object Set]';\n}\n\nexport function isSymbol(item: any): boolean {\n  return typeof item === 'symbol';\n}\n\n/**\n * 'getType' function\n *\n * Detects the JSON Schema Type of a value.\n * By default, detects numbers and integers even if formatted as strings.\n * (So all integers are also numbers, and any number may also be a string.)\n * However, it only detects true boolean values (to detect boolean values\n * in non-boolean formats, use isBoolean() instead).\n *\n * If passed a second optional parameter of 'strict', it will only detect\n * numbers and integers if they are formatted as JavaScript numbers.\n *\n * Examples:\n * getType('10.5') = 'number'\n * getType(10.5) = 'number'\n * getType('10') = 'integer'\n * getType(10) = 'integer'\n * getType('true') = 'string'\n * getType(true) = 'boolean'\n * getType(null) = 'null'\n * getType({ }) = 'object'\n * getType([]) = 'array'\n *\n * getType('10.5', 'strict') = 'string'\n * getType(10.5, 'strict') = 'number'\n * getType('10', 'strict') = 'string'\n * getType(10, 'strict') = 'integer'\n * getType('true', 'strict') = 'string'\n * getType(true, 'strict') = 'boolean'\n *\n * //   value - value to check\n * //  { any = false } strict - if truthy, also checks JavaScript tyoe\n * // { SchemaType }\n */\nexport function getType(value, strict: any = false) {\n  if (!isDefined(value)) { return 'null'; }\n  if (isArray(value)) { return 'array'; }\n  if (isObject(value)) { return 'object'; }\n  if (isBoolean(value, 'strict')) { return 'boolean'; }\n  if (isInteger(value, strict)) { return 'integer'; }\n  if (isNumber(value, strict)) { return 'number'; }\n  if (isString(value) || (!strict && isDate(value))) { return 'string'; }\n  return null;\n}\n\n/**\n * 'isType' function\n *\n * Checks wether an input (probably string) value contains data of\n * a specified JSON Schema type\n *\n * //  { PrimitiveValue } value - value to check\n * //  { SchemaPrimitiveType } type - type to check\n * // { boolean }\n */\nexport function isType(value, type) {\n  switch (type) {\n    case 'string':\n      return isString(value) || isDate(value);\n    case 'number':\n      return isNumber(value);\n    case 'integer':\n      return isInteger(value);\n    case 'boolean':\n      return isBoolean(value);\n    case 'null':\n      return !hasValue(value);\n    default:\n      console.error(`isType error: \"${type}\" is not a recognized type.`);\n      return null;\n  }\n}\n\n/**\n * 'isPrimitive' function\n *\n * Checks wether an input value is a JavaScript primitive type:\n * string, number, boolean, or null.\n *\n * //   value - value to check\n * // { boolean }\n */\nexport function isPrimitive(value) {\n  return (isString(value) || isNumber(value) ||\n    isBoolean(value, 'strict') || value === null);\n}\n\n/**\n * 'toJavaScriptType' function\n *\n * Converts an input (probably string) value to a JavaScript primitive type -\n * 'string', 'number', 'boolean', or 'null' - before storing in a JSON object.\n *\n * Does not coerce values (other than null), and only converts the types\n * of values that would otherwise be valid.\n *\n * If the optional third parameter 'strictIntegers' is TRUE, and the\n * JSON Schema type 'integer' is specified, it also verifies the input value\n * is an integer and, if it is, returns it as a JaveScript number.\n * If 'strictIntegers' is FALSE (or not set) the type 'integer' is treated\n * exactly the same as 'number', and allows decimals.\n *\n * Valid Examples:\n * toJavaScriptType('10',   'number' ) = 10   // '10'   is a number\n * toJavaScriptType('10',   'integer') = 10   // '10'   is also an integer\n * toJavaScriptType( 10,    'integer') = 10   //  10    is still an integer\n * toJavaScriptType( 10,    'string' ) = '10' //  10    can be made into a string\n * toJavaScriptType('10.5', 'number' ) = 10.5 // '10.5' is a number\n *\n * Invalid Examples:\n * toJavaScriptType('10.5', 'integer') = null // '10.5' is not an integer\n * toJavaScriptType( 10.5,  'integer') = null //  10.5  is still not an integer\n *\n * //  { PrimitiveValue } value - value to convert\n * //  { SchemaPrimitiveType | SchemaPrimitiveType[] } types - types to convert to\n * //  { boolean = false } strictIntegers - if FALSE, treat integers as numbers\n * // { PrimitiveValue }\n */\nexport function toJavaScriptType(value, types, strictIntegers = true)  {\n  if (!isDefined(value)) { return null; }\n  if (isString(types)) { types = [types]; }\n  if (strictIntegers && inArray('integer', types)) {\n    if (isInteger(value, 'strict')) { return value; }\n    if (isInteger(value)) { return parseInt(value, 10); }\n  }\n  if (inArray('number', types) || (!strictIntegers && inArray('integer', types))) {\n    if (isNumber(value, 'strict')) { return value; }\n    if (isNumber(value)) { return parseFloat(value); }\n  }\n  if (inArray('string', types)) {\n    if (isString(value)) { return value; }\n    // If value is a date, and types includes 'string',\n    // convert the date to a string\n    if (isDate(value)) { return value.toISOString().slice(0, 10); }\n    if (isNumber(value)) { return value.toString(); }\n  }\n  // If value is a date, and types includes 'integer' or 'number',\n  // but not 'string', convert the date to a number\n  if (isDate(value) && (inArray('integer', types) || inArray('number', types))) {\n    return value.getTime();\n  }\n  if (inArray('boolean', types)) {\n    if (isBoolean(value, true)) { return true; }\n    if (isBoolean(value, false)) { return false; }\n  }\n  return null;\n}\n\n/**\n * 'toSchemaType' function\n *\n * Converts an input (probably string) value to the \"best\" JavaScript\n * equivalent available from an allowed list of JSON Schema types, which may\n * contain 'string', 'number', 'integer', 'boolean', and/or 'null'.\n * If necssary, it does progressively agressive type coersion.\n * It will not return null unless null is in the list of allowed types.\n *\n * Number conversion examples:\n * toSchemaType('10', ['number','integer','string']) = 10 // integer\n * toSchemaType('10', ['number','string']) = 10 // number\n * toSchemaType('10', ['string']) = '10' // string\n * toSchemaType('10.5', ['number','integer','string']) = 10.5 // number\n * toSchemaType('10.5', ['integer','string']) = '10.5' // string\n * toSchemaType('10.5', ['integer']) = 10 // integer\n * toSchemaType(10.5, ['null','boolean','string']) = '10.5' // string\n * toSchemaType(10.5, ['null','boolean']) = true // boolean\n *\n * String conversion examples:\n * toSchemaType('1.5x', ['boolean','number','integer','string']) = '1.5x' // string\n * toSchemaType('1.5x', ['boolean','number','integer']) = '1.5' // number\n * toSchemaType('1.5x', ['boolean','integer']) = '1' // integer\n * toSchemaType('1.5x', ['boolean']) = true // boolean\n * toSchemaType('xyz', ['number','integer','boolean','null']) = true // boolean\n * toSchemaType('xyz', ['number','integer','null']) = null // null\n * toSchemaType('xyz', ['number','integer']) = 0 // number\n *\n * Boolean conversion examples:\n * toSchemaType('1', ['integer','number','string','boolean']) = 1 // integer\n * toSchemaType('1', ['number','string','boolean']) = 1 // number\n * toSchemaType('1', ['string','boolean']) = '1' // string\n * toSchemaType('1', ['boolean']) = true // boolean\n * toSchemaType('true', ['number','string','boolean']) = 'true' // string\n * toSchemaType('true', ['boolean']) = true // boolean\n * toSchemaType('true', ['number']) = 0 // number\n * toSchemaType(true, ['number','string','boolean']) = true // boolean\n * toSchemaType(true, ['number','string']) = 'true' // string\n * toSchemaType(true, ['number']) = 1 // number\n *\n * //  { PrimitiveValue } value - value to convert\n * //  { SchemaPrimitiveType | SchemaPrimitiveType[] } types - allowed types to convert to\n * // { PrimitiveValue }\n */\nexport function toSchemaType(value, types) {\n  if (!isArray(<SchemaPrimitiveType>types)) {\n    types = <SchemaPrimitiveType[]>[types];\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('null') && !hasValue(value)) {\n    return null;\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('boolean') && !isBoolean(value, 'strict')) {\n    return value;\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('integer')) {\n    const testValue = toJavaScriptType(value, 'integer');\n    if (testValue !== null) { return +testValue; }\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('number')) {\n    const testValue = toJavaScriptType(value, 'number');\n    if (testValue !== null) { return +testValue; }\n  }\n  if (\n    (isString(value) || isNumber(value, 'strict')) &&\n    (<SchemaPrimitiveType[]>types).includes('string')\n  ) { // Convert number to string\n    return toJavaScriptType(value, 'string');\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('boolean') && isBoolean(value)) {\n    return toJavaScriptType(value, 'boolean');\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('string')) { // Convert null & boolean to string\n    if (value === null) { return ''; }\n    const testValue = toJavaScriptType(value, 'string');\n    if (testValue !== null) { return testValue; }\n  }\n  if ((\n    (<SchemaPrimitiveType[]>types).includes('number') ||\n    (<SchemaPrimitiveType[]>types).includes('integer'))\n  ) {\n    if (value === true) { return 1; } // Convert boolean & null to number\n    if (value === false || value === null || value === '') { return 0; }\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('number')) { // Convert mixed string to number\n    const testValue = parseFloat(<string>value);\n    if (!!testValue) { return testValue; }\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('integer')) { // Convert string or number to integer\n    const testValue = parseInt(<string>value, 10);\n    if (!!testValue) { return testValue; }\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('boolean')) { // Convert anything to boolean\n    return !!value;\n  }\n  if ((\n      (<SchemaPrimitiveType[]>types).includes('number') ||\n      (<SchemaPrimitiveType[]>types).includes('integer')\n    ) && !(<SchemaPrimitiveType[]>types).includes('null')\n  ) {\n    return 0; // If null not allowed, return 0 for non-convertable values\n  }\n}\n\n/**\n * 'isPromise' function\n *\n * //   object\n * // { boolean }\n */\nexport function isPromise(object): object is Promise<any> {\n  return !!object && typeof object.then === 'function';\n}\n\n/**\n * 'isObservable' function\n *\n * //   object\n * // { boolean }\n */\nexport function isObservable(object): object is Observable<any> {\n  return !!object && typeof object.subscribe === 'function';\n}\n\n/**\n * '_toPromise' function\n *\n * //  { object } object\n * // { Promise<any> }\n */\nexport function _toPromise(object): Promise<any> {\n  return isPromise(object) ? object : object.toPromise();\n}\n\n/**\n * 'toObservable' function\n *\n * //  { object } object\n * // { Observable<any> }\n */\nexport function toObservable(object): Observable<any> {\n  const observable = isPromise(object) ? from(object) : object;\n  if (isObservable(observable)) { return observable; }\n  console.error('toObservable error: Expected validator to return Promise or Observable.');\n  return new Observable();\n}\n\n/**\n * 'inArray' function\n *\n * Searches an array for an item, or one of a list of items, and returns true\n * as soon as a match is found, or false if no match.\n *\n * If the optional third parameter allIn is set to TRUE, and the item to find\n * is an array, then the function returns true only if all elements from item\n * are found in the array list, and false if any element is not found. If the\n * item to find is not an array, setting allIn to TRUE has no effect.\n *\n * //  { any|any[] } item - the item to search for\n * //   array - the array to search\n * //  { boolean = false } allIn - if TRUE, all items must be in array\n * // { boolean } - true if item(s) in array, false otherwise\n */\nexport function inArray(item, array, allIn = false) {\n  if (!isDefined(item) || !isArray(array)) { return false; }\n  return isArray(item) ?\n    item[allIn ? 'every' : 'some'](subItem => array.includes(subItem)) :\n    array.includes(item);\n}\n\n/**\n * 'xor' utility function - exclusive or\n *\n * Returns true if exactly one of two values is truthy.\n *\n * //   value1 - first value to check\n * //   value2 - second value to check\n * // { boolean } - true if exactly one input value is truthy, false if not\n */\nexport function xor(value1, value2) {\n  return (!!value1 && !value2) || (!value1 && !!value2);\n}\n","import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class Framework {\n  name: string;\n  framework: any;\n  widgets?: { [key: string]: any } = {};\n  stylesheets?: string[] = [];\n  scripts?: string[] = [];\n}\n","import {\n  cleanValueOfQuotes,\n  copy,\n  ExpressionType,\n  getExpressionType,\n  getKeyAndValueByExpressionType,\n  hasOwn,\n  isEqual,\n  isNotEqual,\n  isNotExpression\n} from './utility.functions';\nimport {Injectable} from '@angular/core';\nimport {isArray, isDefined, isEmpty, isMap, isNumber, isObject, isString} from './validator.functions';\n\n/**\n * 'JsonPointer' class\n *\n * Some utilities for using JSON Pointers with JSON objects\n * https://tools.ietf.org/html/rfc6901\n *\n * get, getCopy, getFirst, set, setCopy, insert, insertCopy, remove, has, dict,\n * forEachDeep, forEachDeepCopy, escape, unescape, parse, compile, toKey,\n * isJsonPointer, isSubPointer, toIndexedPointer, toGenericPointer,\n * toControlPointer, toSchemaPointer, toDataPointer, parseObjectPath\n *\n * Some functions based on manuelstofer's json-pointer utilities\n * https://github.com/manuelstofer/json-pointer\n */\nexport type Pointer = string | string[];\n\n@Injectable()\nexport class JsonPointer {\n\n  /**\n   * 'get' function\n   *\n   * Uses a JSON Pointer to retrieve a value from an object.\n   *\n   * //  { object } object - Object to get value from\n   * //  { Pointer } pointer - JSON Pointer (string or array)\n   * //  { number = 0 } startSlice - Zero-based index of first Pointer key to use\n   * //  { number } endSlice - Zero-based index of last Pointer key to use\n   * //  { boolean = false } getBoolean - Return only true or false?\n   * //  { boolean = false } errors - Show error if not found?\n   * // { object } - Located value (or true or false if getBoolean = true)\n   */\n  static get(\n    object, pointer, startSlice = 0, endSlice: number = null,\n    getBoolean = false, errors = false\n  ) {\n    if (object === null) { return getBoolean ? false : undefined; }\n    let keyArray: any[] = this.parse(pointer, errors);\n    if (typeof object === 'object' && keyArray !== null) {\n      let subObject = object;\n      if (startSlice >= keyArray.length || endSlice <= -keyArray.length) { return object; }\n      if (startSlice <= -keyArray.length) { startSlice = 0; }\n      if (!isDefined(endSlice) || endSlice >= keyArray.length) { endSlice = keyArray.length; }\n      keyArray = keyArray.slice(startSlice, endSlice);\n      for (let key of keyArray) {\n        if (key === '-' && isArray(subObject) && subObject.length) {\n          key = subObject.length - 1;\n        }\n        if (isMap(subObject) && subObject.has(key)) {\n          subObject = subObject.get(key);\n        } else if (typeof subObject === 'object' && subObject !== null &&\n          hasOwn(subObject, key)\n        ) {\n          subObject = subObject[key];\n        } else {\n          const evaluatedExpression = JsonPointer.evaluateExpression(subObject, key);\n          if (evaluatedExpression.passed) {\n            subObject = evaluatedExpression.key ? subObject[evaluatedExpression.key] : subObject;\n          } else {\n            this.logErrors(errors, key, pointer, object);\n            return getBoolean ? false : undefined;\n          }\n        }\n      }\n      return getBoolean ? true : subObject;\n    }\n    if (errors && keyArray === null) {\n      console.error(`get error: Invalid JSON Pointer: ${pointer}`);\n    }\n    if (errors && typeof object !== 'object') {\n      console.error('get error: Invalid object:');\n      console.error(object);\n    }\n    return getBoolean ? false : undefined;\n  }\n\n  private static logErrors(errors, key, pointer, object) {\n    if (errors) {\n      console.error(`get error: \"${key}\" key not found in object.`);\n      console.error(pointer);\n      console.error(object);\n    }\n  }\n\n  /**\n   * Evaluates conditional expression in form of `model.<property>==<value>` or\n   * `model.<property>!=<value>` where the first one means that the value must match to be\n   * shown in a form, while the former shows the property only when the property value is not\n   * set, or does not equal the given value.\n   *\n   * // { subObject } subObject -  an object containing the data values of properties\n   * // { key } key - the key from the for loop in a form of `<property>==<value>`\n   *\n   * Returns the object with two properties. The property passed informs whether\n   * the expression evaluated successfully and the property key returns either the same\n   * key if it is not contained inside the subObject or the key of the property if it is contained.\n   */\n  static evaluateExpression(subObject: Object, key: any) {\n    const defaultResult = {passed: false, key: key};\n    const keysAndExpression = this.parseKeysAndExpression(key, subObject);\n    if (!keysAndExpression) {\n      return defaultResult;\n    }\n\n    const ownCheckResult = this.doOwnCheckResult(subObject, keysAndExpression);\n    if (ownCheckResult) {\n      return ownCheckResult;\n    }\n\n    const cleanedValue = cleanValueOfQuotes(keysAndExpression.keyAndValue[1]);\n\n    const evaluatedResult = this.performExpressionOnValue(keysAndExpression, cleanedValue, subObject);\n    if (evaluatedResult) {\n      return evaluatedResult;\n    }\n\n    return defaultResult;\n  }\n\n  /**\n   * Performs the actual evaluation on the given expression with given values and keys.\n   * // { cleanedValue } cleanedValue - the given valued cleaned of quotes if it had any\n   * // { subObject } subObject - the object with properties values\n   * // { keysAndExpression } keysAndExpression - an object holding the expressions with\n   */\n  private static performExpressionOnValue(keysAndExpression: any, cleanedValue: String, subObject: Object) {\n    const propertyByKey = subObject[keysAndExpression.keyAndValue[0]];\n    if (this.doComparisonByExpressionType(keysAndExpression.expressionType, propertyByKey, cleanedValue)) {\n      return {passed: true, key: keysAndExpression.keyAndValue[0]};\n    }\n\n    return null;\n  }\n\n  private static doComparisonByExpressionType(expressionType: ExpressionType, propertyByKey, cleanedValue: String): Boolean {\n    if (isEqual(expressionType)) {\n      return propertyByKey === cleanedValue;\n    }\n    if (isNotEqual(expressionType)) {\n      return propertyByKey !== cleanedValue;\n    }\n    return false;\n  }\n\n  /**\n   * Does the checks when the parsed key is actually no a property inside subObject.\n   * That would mean that the equal comparison makes no sense and thus the negative result\n   * is returned, and the not equal comparison is not necessary because it doesn't equal\n   * obviously. Returns null when the given key is a real property inside the subObject.\n   * // { subObject } subObject - the object with properties values\n   * // { keysAndExpression } keysAndExpression - an object holding the expressions with\n   * the associated keys.\n   */\n  private static doOwnCheckResult(subObject: Object, keysAndExpression) {\n    let ownCheckResult = null;\n    if (!hasOwn(subObject, keysAndExpression.keyAndValue[0])) {\n      if (isEqual(keysAndExpression.expressionType)) {\n        ownCheckResult = {passed: false, key: null};\n      }\n      if (isNotEqual(keysAndExpression.expressionType)) {\n        ownCheckResult = {passed: true, key: null};\n      }\n    }\n    return ownCheckResult;\n  }\n\n  /**\n   * Does the basic checks and tries to parse an expression and a pair\n   * of key and value.\n   * // { key } key - the original for loop created value containing key and value in one string\n   * // { subObject } subObject - the object with properties values\n   */\n  private static parseKeysAndExpression(key: string, subObject) {\n    if (this.keyOrSubObjEmpty(key, subObject)) {\n      return null;\n    }\n    const expressionType = getExpressionType(key.toString());\n    if (isNotExpression(expressionType)) {\n      return null;\n    }\n    const keyAndValue = getKeyAndValueByExpressionType(expressionType, key);\n    if (!keyAndValue || !keyAndValue[0] || !keyAndValue[1]) {\n      return null;\n    }\n    return {expressionType: expressionType, keyAndValue: keyAndValue};\n  }\n\n  private static keyOrSubObjEmpty(key: any, subObject: Object) {\n    return !key || !subObject;\n  }\n\n  /**\n   * 'getCopy' function\n   *\n   * Uses a JSON Pointer to deeply clone a value from an object.\n   *\n   * //  { object } object - Object to get value from\n   * //  { Pointer } pointer - JSON Pointer (string or array)\n   * //  { number = 0 } startSlice - Zero-based index of first Pointer key to use\n   * //  { number } endSlice - Zero-based index of last Pointer key to use\n   * //  { boolean = false } getBoolean - Return only true or false?\n   * //  { boolean = false } errors - Show error if not found?\n   * // { object } - Located value (or true or false if getBoolean = true)\n   */\n  static getCopy(\n    object, pointer, startSlice = 0, endSlice: number = null,\n    getBoolean = false, errors = false\n  ) {\n    const objectToCopy =\n      this.get(object, pointer, startSlice, endSlice, getBoolean, errors);\n    return this.forEachDeepCopy(objectToCopy);\n  }\n\n  /**\n   * 'getFirst' function\n   *\n   * Takes an array of JSON Pointers and objects,\n   * checks each object for a value specified by the pointer,\n   * and returns the first value found.\n   *\n   * //  { [object, pointer][] } items - Array of objects and pointers to check\n   * //  { any = null } defaultValue - Value to return if nothing found\n   * //  { boolean = false } getCopy - Return a copy instead?\n   * //  - First value found\n   */\n  static getFirst(items, defaultValue: any = null, getCopy = false) {\n    if (isEmpty(items)) { return; }\n    if (isArray(items)) {\n      for (const item of items) {\n        if (isEmpty(item)) { continue; }\n        if (isArray(item) && item.length >= 2) {\n          if (isEmpty(item[0]) || isEmpty(item[1])) { continue; }\n          const value = getCopy ?\n            this.getCopy(item[0], item[1]) :\n            this.get(item[0], item[1]);\n          if (value) { return value; }\n          continue;\n        }\n        console.error('getFirst error: Input not in correct format.\\n' +\n          'Should be: [ [ object1, pointer1 ], [ object 2, pointer2 ], etc... ]');\n        return;\n      }\n      return defaultValue;\n    }\n    if (isMap(items)) {\n      for (const [object, pointer] of items) {\n        if (object === null || !this.isJsonPointer(pointer)) { continue; }\n        const value = getCopy ?\n          this.getCopy(object, pointer) :\n          this.get(object, pointer);\n        if (value) { return value; }\n      }\n      return defaultValue;\n    }\n    console.error('getFirst error: Input not in correct format.\\n' +\n      'Should be: [ [ object1, pointer1 ], [ object 2, pointer2 ], etc... ]');\n    return defaultValue;\n  }\n\n  /**\n   * 'getFirstCopy' function\n   *\n   * Similar to getFirst, but always returns a copy.\n   *\n   * //  { [object, pointer][] } items - Array of objects and pointers to check\n   * //  { any = null } defaultValue - Value to return if nothing found\n   * //  - Copy of first value found\n   */\n  static getFirstCopy(items, defaultValue: any = null) {\n    const firstCopy = this.getFirst(items, defaultValue, true);\n    return firstCopy;\n  }\n\n  /**\n   * 'set' function\n   *\n   * Uses a JSON Pointer to set a value on an object.\n   * Also creates any missing sub objects or arrays to contain that value.\n   *\n   * If the optional fourth parameter is TRUE and the inner-most container\n   * is an array, the function will insert the value as a new item at the\n   * specified location in the array, rather than overwriting the existing\n   * value (if any) at that location.\n   *\n   * So set([1, 2, 3], '/1', 4) => [1, 4, 3]\n   * and\n   * So set([1, 2, 3], '/1', 4, true) => [1, 4, 2, 3]\n   *\n   * //  { object } object - The object to set value in\n   * //  { Pointer } pointer - The JSON Pointer (string or array)\n   * //   value - The new value to set\n   * //  { boolean } insert - insert value?\n   * // { object } - The original object, modified with the set value\n   */\n  static set(object, pointer, value, insert = false) {\n    const keyArray = this.parse(pointer);\n    if (keyArray !== null && keyArray.length) {\n      let subObject = object;\n      for (let i = 0; i < keyArray.length - 1; ++i) {\n        let key = keyArray[i];\n        if (key === '-' && isArray(subObject)) {\n          key = subObject.length;\n        }\n        if (isMap(subObject) && subObject.has(key)) {\n          subObject = subObject.get(key);\n        } else {\n          if (!hasOwn(subObject, key)) {\n            subObject[key] = (keyArray[i + 1].match(/^(\\d+|-)$/)) ? [] : {};\n          }\n          subObject = subObject[key];\n        }\n      }\n      const lastKey = keyArray[keyArray.length - 1];\n      if (isArray(subObject) && lastKey === '-') {\n        subObject.push(value);\n      } else if (insert && isArray(subObject) && !isNaN(+lastKey)) {\n        subObject.splice(lastKey, 0, value);\n      } else if (isMap(subObject)) {\n        subObject.set(lastKey, value);\n      } else {\n        subObject[lastKey] = value;\n      }\n      return object;\n    }\n    console.error(`set error: Invalid JSON Pointer: ${pointer}`);\n    return object;\n  }\n\n  /**\n   * 'setCopy' function\n   *\n   * Copies an object and uses a JSON Pointer to set a value on the copy.\n   * Also creates any missing sub objects or arrays to contain that value.\n   *\n   * If the optional fourth parameter is TRUE and the inner-most container\n   * is an array, the function will insert the value as a new item at the\n   * specified location in the array, rather than overwriting the existing value.\n   *\n   * //  { object } object - The object to copy and set value in\n   * //  { Pointer } pointer - The JSON Pointer (string or array)\n   * //   value - The value to set\n   * //  { boolean } insert - insert value?\n   * // { object } - The new object with the set value\n   */\n  static setCopy(object, pointer, value, insert = false) {\n    const keyArray = this.parse(pointer);\n    if (keyArray !== null) {\n      const newObject = copy(object);\n      let subObject = newObject;\n      for (let i = 0; i < keyArray.length - 1; ++i) {\n        let key = keyArray[i];\n        if (key === '-' && isArray(subObject)) {\n          key = subObject.length;\n        }\n        if (isMap(subObject) && subObject.has(key)) {\n          subObject.set(key, copy(subObject.get(key)));\n          subObject = subObject.get(key);\n        } else {\n          if (!hasOwn(subObject, key)) {\n            subObject[key] = (keyArray[i + 1].match(/^(\\d+|-)$/)) ? [] : {};\n          }\n          subObject[key] = copy(subObject[key]);\n          subObject = subObject[key];\n        }\n      }\n      const lastKey = keyArray[keyArray.length - 1];\n      if (isArray(subObject) && lastKey === '-') {\n        subObject.push(value);\n      } else if (insert && isArray(subObject) && !isNaN(+lastKey)) {\n        subObject.splice(lastKey, 0, value);\n      } else if (isMap(subObject)) {\n        subObject.set(lastKey, value);\n      } else {\n        subObject[lastKey] = value;\n      }\n      return newObject;\n    }\n    console.error(`setCopy error: Invalid JSON Pointer: ${pointer}`);\n    return object;\n  }\n\n  /**\n   * 'insert' function\n   *\n   * Calls 'set' with insert = TRUE\n   *\n   * //  { object } object - object to insert value in\n   * //  { Pointer } pointer - JSON Pointer (string or array)\n   * //   value - value to insert\n   * // { object }\n   */\n  static insert(object, pointer, value) {\n    const updatedObject = this.set(object, pointer, value, true);\n    return updatedObject;\n  }\n\n  /**\n   * 'insertCopy' function\n   *\n   * Calls 'setCopy' with insert = TRUE\n   *\n   * //  { object } object - object to insert value in\n   * //  { Pointer } pointer - JSON Pointer (string or array)\n   * //   value - value to insert\n   * // { object }\n   */\n  static insertCopy(object, pointer, value) {\n    const updatedObject = this.setCopy(object, pointer, value, true);\n    return updatedObject;\n  }\n\n  /**\n   * 'remove' function\n   *\n   * Uses a JSON Pointer to remove a key and its attribute from an object\n   *\n   * //  { object } object - object to delete attribute from\n   * //  { Pointer } pointer - JSON Pointer (string or array)\n   * // { object }\n   */\n  static remove(object, pointer) {\n    const keyArray = this.parse(pointer);\n    if (keyArray !== null && keyArray.length) {\n      let lastKey = keyArray.pop();\n      const parentObject = this.get(object, keyArray);\n      if (isArray(parentObject)) {\n        if (lastKey === '-') { lastKey = parentObject.length - 1; }\n        parentObject.splice(lastKey, 1);\n      } else if (isObject(parentObject)) {\n        delete parentObject[lastKey];\n      }\n      return object;\n    }\n    console.error(`remove error: Invalid JSON Pointer: ${pointer}`);\n    return object;\n  }\n\n  /**\n   * 'has' function\n   *\n   * Tests if an object has a value at the location specified by a JSON Pointer\n   *\n   * //  { object } object - object to chek for value\n   * //  { Pointer } pointer - JSON Pointer (string or array)\n   * // { boolean }\n   */\n  static has(object, pointer) {\n    const hasValue = this.get(object, pointer, 0, null, true);\n    return hasValue;\n  }\n\n  /**\n   * 'dict' function\n   *\n   * Returns a (pointer -> value) dictionary for an object\n   *\n   * //  { object } object - The object to create a dictionary from\n   * // { object } - The resulting dictionary object\n   */\n  static dict(object) {\n    const results: any = {};\n    this.forEachDeep(object, (value, pointer) => {\n      if (typeof value !== 'object') { results[pointer] = value; }\n    });\n    return results;\n  }\n\n  /**\n   * 'forEachDeep' function\n   *\n   * Iterates over own enumerable properties of an object or items in an array\n   * and invokes an iteratee function for each key/value or index/value pair.\n   * By default, iterates over items within objects and arrays after calling\n   * the iteratee function on the containing object or array itself.\n   *\n   * The iteratee is invoked with three arguments: (value, pointer, rootObject),\n   * where pointer is a JSON pointer indicating the location of the current\n   * value within the root object, and rootObject is the root object initially\n   * submitted to th function.\n   *\n   * If a third optional parameter 'bottomUp' is set to TRUE, the iterator\n   * function will be called on sub-objects and arrays after being\n   * called on their contents, rather than before, which is the default.\n   *\n   * This function can also optionally be called directly on a sub-object by\n   * including optional 4th and 5th parameterss to specify the initial\n   * root object and pointer.\n   *\n   * //  { object } object - the initial object or array\n   * //  { (v: any, p?: string, o?: any) => any } function - iteratee function\n   * //  { boolean = false } bottomUp - optional, set to TRUE to reverse direction\n   * //  { object = object } rootObject - optional, root object or array\n   * //  { string = '' } pointer - optional, JSON Pointer to object within rootObject\n   * // { object } - The modified object\n   */\n  static forEachDeep(\n    object, fn: (v: any, p?: string, o?: any) => any = (v) => v,\n    bottomUp = false, pointer = '', rootObject = object\n  ) {\n    if (typeof fn !== 'function') {\n      console.error(`forEachDeep error: Iterator is not a function:`, fn);\n      return;\n    }\n    if (!bottomUp) { fn(object, pointer, rootObject); }\n    if (isObject(object) || isArray(object)) {\n      for (const key of Object.keys(object)) {\n        const newPointer = pointer + '/' + this.escape(key);\n        this.forEachDeep(object[key], fn, bottomUp, newPointer, rootObject);\n      }\n    }\n    if (bottomUp) { fn(object, pointer, rootObject); }\n  }\n\n  /**\n   * 'forEachDeepCopy' function\n   *\n   * Similar to forEachDeep, but returns a copy of the original object, with\n   * the same keys and indexes, but with values replaced with the result of\n   * the iteratee function.\n   *\n   * //  { object } object - the initial object or array\n   * //  { (v: any, k?: string, o?: any, p?: any) => any } function - iteratee function\n   * //  { boolean = false } bottomUp - optional, set to TRUE to reverse direction\n   * //  { object = object } rootObject - optional, root object or array\n   * //  { string = '' } pointer - optional, JSON Pointer to object within rootObject\n   * // { object } - The copied object\n   */\n  static forEachDeepCopy(\n    object, fn: (v: any, p?: string, o?: any) => any = (v) => v,\n    bottomUp = false, pointer = '', rootObject = object\n  ) {\n    if (typeof fn !== 'function') {\n      console.error(`forEachDeepCopy error: Iterator is not a function:`, fn);\n      return null;\n    }\n    if (isObject(object) || isArray(object)) {\n      let newObject = isArray(object) ? [ ...object ] : { ...object };\n      if (!bottomUp) { newObject = fn(newObject, pointer, rootObject); }\n      for (const key of Object.keys(newObject)) {\n        const newPointer = pointer + '/' + this.escape(key);\n        newObject[key] = this.forEachDeepCopy(\n          newObject[key], fn, bottomUp, newPointer, rootObject\n        );\n      }\n      if (bottomUp) { newObject = fn(newObject, pointer, rootObject); }\n      return newObject;\n    } else {\n      return fn(object, pointer, rootObject);\n    }\n  }\n\n  /**\n   * 'escape' function\n   *\n   * Escapes a string reference key\n   *\n   * //  { string } key - string key to escape\n   * // { string } - escaped key\n   */\n  static escape(key) {\n    const escaped = key.toString().replace(/~/g, '~0').replace(/\\//g, '~1');\n    return escaped;\n  }\n\n  /**\n   * 'unescape' function\n   *\n   * Unescapes a string reference key\n   *\n   * //  { string } key - string key to unescape\n   * // { string } - unescaped key\n   */\n  static unescape(key) {\n    const unescaped = key.toString().replace(/~1/g, '/').replace(/~0/g, '~');\n    return unescaped;\n  }\n\n  /**\n   * 'parse' function\n   *\n   * Converts a string JSON Pointer into a array of keys\n   * (if input is already an an array of keys, it is returned unchanged)\n   *\n   * //  { Pointer } pointer - JSON Pointer (string or array)\n   * //  { boolean = false } errors - Show error if invalid pointer?\n   * // { string[] } - JSON Pointer array of keys\n   */\n  static parse(pointer, errors = false) {\n    if (!this.isJsonPointer(pointer)) {\n      if (errors) { console.error(`parse error: Invalid JSON Pointer: ${pointer}`); }\n      return null;\n    }\n    if (isArray(pointer)) { return <string[]>pointer; }\n    if (typeof pointer === 'string') {\n      if ((<string>pointer)[0] === '#') { pointer = pointer.slice(1); }\n      if (<string>pointer === '' || <string>pointer === '/') { return []; }\n      return (<string>pointer).slice(1).split('/').map(this.unescape);\n    }\n  }\n\n  /**\n   * 'compile' function\n   *\n   * Converts an array of keys into a JSON Pointer string\n   * (if input is already a string, it is normalized and returned)\n   *\n   * The optional second parameter is a default which will replace any empty keys.\n   *\n   * //  { Pointer } pointer - JSON Pointer (string or array)\n   * //  { string | number = '' } defaultValue - Default value\n   * //  { boolean = false } errors - Show error if invalid pointer?\n   * // { string } - JSON Pointer string\n   */\n  static compile(pointer, defaultValue = '', errors = false) {\n    if (pointer === '#') { return ''; }\n    if (!this.isJsonPointer(pointer)) {\n      if (errors) { console.error(`compile error: Invalid JSON Pointer: ${pointer}`); }\n      return null;\n    }\n    if (isArray(pointer)) {\n      if ((<string[]>pointer).length === 0) { return ''; }\n      return '/' + (<string[]>pointer).map(\n        key => key === '' ? defaultValue : this.escape(key)\n      ).join('/');\n    }\n    if (typeof pointer === 'string') {\n      if (pointer[0] === '#') { pointer = pointer.slice(1); }\n      return pointer;\n    }\n  }\n\n  /**\n   * 'toKey' function\n   *\n   * Extracts name of the final key from a JSON Pointer.\n   *\n   * //  { Pointer } pointer - JSON Pointer (string or array)\n   * //  { boolean = false } errors - Show error if invalid pointer?\n   * // { string } - the extracted key\n   */\n  static toKey(pointer, errors = false) {\n    const keyArray = this.parse(pointer, errors);\n    if (keyArray === null) { return null; }\n    if (!keyArray.length) { return ''; }\n    return keyArray[keyArray.length - 1];\n  }\n\n  /**\n   * 'isJsonPointer' function\n   *\n   * Checks a string or array value to determine if it is a valid JSON Pointer.\n   * Returns true if a string is empty, or starts with '/' or '#/'.\n   * Returns true if an array contains only string values.\n   *\n   * //   value - value to check\n   * // { boolean } - true if value is a valid JSON Pointer, otherwise false\n   */\n  static isJsonPointer(value) {\n    if (isArray(value)) {\n      return value.every(key => typeof key === 'string');\n    } else if (isString(value)) {\n      if (value === '' || value === '#') { return true; }\n      if (value[0] === '/' || value.slice(0, 2) === '#/') {\n        return !/(~[^01]|~$)/g.test(value);\n      }\n    }\n    return false;\n  }\n\n  /**\n   * 'isSubPointer' function\n   *\n   * Checks whether one JSON Pointer is a subset of another.\n   *\n   * //  { Pointer } shortPointer - potential subset JSON Pointer\n   * //  { Pointer } longPointer - potential superset JSON Pointer\n   * //  { boolean = false } trueIfMatching - return true if pointers match?\n   * //  { boolean = false } errors - Show error if invalid pointer?\n   * // { boolean } - true if shortPointer is a subset of longPointer, false if not\n   */\n  static isSubPointer(\n    shortPointer, longPointer, trueIfMatching = false, errors = false\n  ) {\n    if (!this.isJsonPointer(shortPointer) || !this.isJsonPointer(longPointer)) {\n      if (errors) {\n        let invalid = '';\n        if (!this.isJsonPointer(shortPointer)) { invalid += ` 1: ${shortPointer}`; }\n        if (!this.isJsonPointer(longPointer)) { invalid += ` 2: ${longPointer}`; }\n        console.error(`isSubPointer error: Invalid JSON Pointer ${invalid}`);\n      }\n      return;\n    }\n    shortPointer = this.compile(shortPointer, '', errors);\n    longPointer = this.compile(longPointer, '', errors);\n    return shortPointer === longPointer ? trueIfMatching :\n      `${shortPointer}/` === longPointer.slice(0, shortPointer.length + 1);\n  }\n\n  /**\n   * 'toIndexedPointer' function\n   *\n   * Merges an array of numeric indexes and a generic pointer to create an\n   * indexed pointer for a specific item.\n   *\n   * For example, merging the generic pointer '/foo/-/bar/-/baz' and\n   * the array [4, 2] would result in the indexed pointer '/foo/4/bar/2/baz'\n   *\n   *\n   * //  { Pointer } genericPointer - The generic pointer\n   * //  { number[] } indexArray - The array of numeric indexes\n   * //  { Map<string, number> } arrayMap - An optional array map\n   * // { string } - The merged pointer with indexes\n   */\n  static toIndexedPointer(\n    genericPointer, indexArray, arrayMap: Map<string, number> = null\n  ) {\n    if (this.isJsonPointer(genericPointer) && isArray(indexArray)) {\n      let indexedPointer = this.compile(genericPointer);\n      if (isMap(arrayMap)) {\n        let arrayIndex = 0;\n        return indexedPointer.replace(/\\/\\-(?=\\/|$)/g, (key, stringIndex) =>\n          arrayMap.has((<string>indexedPointer).slice(0, stringIndex)) ?\n            '/' + indexArray[arrayIndex++] : key\n        );\n      } else {\n        for (const pointerIndex of indexArray) {\n          indexedPointer = indexedPointer.replace('/-', '/' + pointerIndex);\n        }\n        return indexedPointer;\n      }\n    }\n    if (!this.isJsonPointer(genericPointer)) {\n      console.error(`toIndexedPointer error: Invalid JSON Pointer: ${genericPointer}`);\n    }\n    if (!isArray(indexArray)) {\n      console.error(`toIndexedPointer error: Invalid indexArray: ${indexArray}`);\n    }\n  }\n\n  /**\n   * 'toGenericPointer' function\n   *\n   * Compares an indexed pointer to an array map and removes list array\n   * indexes (but leaves tuple arrray indexes and all object keys, including\n   * numeric keys) to create a generic pointer.\n   *\n   * For example, using the indexed pointer '/foo/1/bar/2/baz/3' and\n   * the arrayMap [['/foo', 0], ['/foo/-/bar', 3], ['/foo/-/bar/-/baz', 0]]\n   * would result in the generic pointer '/foo/-/bar/2/baz/-'\n   * Using the indexed pointer '/foo/1/bar/4/baz/3' and the same arrayMap\n   * would result in the generic pointer '/foo/-/bar/-/baz/-'\n   * (the bar array has 3 tuple items, so index 2 is retained, but 4 is removed)\n   *\n   * The structure of the arrayMap is: [['path to array', number of tuple items]...]\n   *\n   *\n   * //  { Pointer } indexedPointer - The indexed pointer (array or string)\n   * //  { Map<string, number> } arrayMap - The optional array map (for preserving tuple indexes)\n   * // { string } - The generic pointer with indexes removed\n   */\n  static toGenericPointer(indexedPointer, arrayMap = new Map<string, number>()) {\n    if (this.isJsonPointer(indexedPointer) && isMap(arrayMap)) {\n      const pointerArray = this.parse(indexedPointer);\n      for (let i = 1; i < pointerArray.length; i++) {\n        const subPointer = this.compile(pointerArray.slice(0, i));\n        if (arrayMap.has(subPointer) &&\n          arrayMap.get(subPointer) <= +pointerArray[i]\n        ) {\n          pointerArray[i] = '-';\n        }\n      }\n      return this.compile(pointerArray);\n    }\n    if (!this.isJsonPointer(indexedPointer)) {\n      console.error(`toGenericPointer error: invalid JSON Pointer: ${indexedPointer}`);\n    }\n    if (!isMap(arrayMap)) {\n      console.error(`toGenericPointer error: invalid arrayMap: ${arrayMap}`);\n    }\n  }\n\n  /**\n   * 'toControlPointer' function\n   *\n   * Accepts a JSON Pointer for a data object and returns a JSON Pointer for the\n   * matching control in an Angular FormGroup.\n   *\n   * //  { Pointer } dataPointer - JSON Pointer (string or array) to a data object\n   * //  { FormGroup } formGroup - Angular FormGroup to get value from\n   * //  { boolean = false } controlMustExist - Only return if control exists?\n   * // { Pointer } - JSON Pointer (string) to the formGroup object\n   */\n  static toControlPointer(dataPointer, formGroup, controlMustExist = false) {\n    const dataPointerArray = this.parse(dataPointer);\n    const controlPointerArray: string[] = [];\n    let subGroup = formGroup;\n    if (dataPointerArray !== null) {\n      for (const key of dataPointerArray) {\n        if (hasOwn(subGroup, 'controls')) {\n          controlPointerArray.push('controls');\n          subGroup = subGroup.controls;\n        }\n        if (isArray(subGroup) && (key === '-')) {\n          controlPointerArray.push((subGroup.length - 1).toString());\n          subGroup = subGroup[subGroup.length - 1];\n        } else if (hasOwn(subGroup, key)) {\n          controlPointerArray.push(key);\n          subGroup = subGroup[key];\n        } else if (controlMustExist) {\n          console.error(`toControlPointer error: Unable to find \"${key}\" item in FormGroup.`);\n          console.error(dataPointer);\n          console.error(formGroup);\n          return;\n        } else {\n          controlPointerArray.push(key);\n          subGroup = { controls: {} };\n        }\n      }\n      return this.compile(controlPointerArray);\n    }\n    console.error(`toControlPointer error: Invalid JSON Pointer: ${dataPointer}`);\n  }\n\n  /**\n   * 'toSchemaPointer' function\n   *\n   * Accepts a JSON Pointer to a value inside a data object and a JSON schema\n   * for that object.\n   *\n   * Returns a Pointer to the sub-schema for the value inside the object's schema.\n   *\n   * //  { Pointer } dataPointer - JSON Pointer (string or array) to an object\n   * //   schema - JSON schema for the object\n   * // { Pointer } - JSON Pointer (string) to the object's schema\n   */\n  static toSchemaPointer(dataPointer, schema) {\n    if (this.isJsonPointer(dataPointer) && typeof schema === 'object') {\n      const pointerArray = this.parse(dataPointer);\n      if (!pointerArray.length) { return ''; }\n      const firstKey = pointerArray.shift();\n      if (schema.type === 'object' || schema.properties || schema.additionalProperties) {\n        if ((schema.properties || {})[firstKey]) {\n          return `/properties/${this.escape(firstKey)}` +\n            this.toSchemaPointer(pointerArray, schema.properties[firstKey]);\n        } else  if (schema.additionalProperties) {\n          return '/additionalProperties' +\n            this.toSchemaPointer(pointerArray, schema.additionalProperties);\n        }\n      }\n      if ((schema.type === 'array' || schema.items) &&\n        (isNumber(firstKey) || firstKey === '-' || firstKey === '')\n      ) {\n        const arrayItem = firstKey === '-' || firstKey === '' ? 0 : +firstKey;\n        if (isArray(schema.items)) {\n          if (arrayItem < schema.items.length) {\n            return '/items/' + arrayItem +\n              this.toSchemaPointer(pointerArray, schema.items[arrayItem]);\n          } else if (schema.additionalItems) {\n            return '/additionalItems' +\n              this.toSchemaPointer(pointerArray, schema.additionalItems);\n          }\n        } else if (isObject(schema.items)) {\n          return '/items' + this.toSchemaPointer(pointerArray, schema.items);\n        } else if (isObject(schema.additionalItems)) {\n          return '/additionalItems' +\n            this.toSchemaPointer(pointerArray, schema.additionalItems);\n        }\n      }\n      console.error(`toSchemaPointer error: Data pointer ${dataPointer} ` +\n        `not compatible with schema ${schema}`);\n      return null;\n    }\n    if (!this.isJsonPointer(dataPointer)) {\n      console.error(`toSchemaPointer error: Invalid JSON Pointer: ${dataPointer}`);\n    }\n    if (typeof schema !== 'object') {\n      console.error(`toSchemaPointer error: Invalid JSON Schema: ${schema}`);\n    }\n    return null;\n  }\n\n  /**\n   * 'toDataPointer' function\n   *\n   * Accepts a JSON Pointer to a sub-schema inside a JSON schema and the schema.\n   *\n   * If possible, returns a generic Pointer to the corresponding value inside\n   * the data object described by the JSON schema.\n   *\n   * Returns null if the sub-schema is in an ambiguous location (such as\n   * definitions or additionalProperties) where the corresponding value\n   * location cannot be determined.\n   *\n   * //  { Pointer } schemaPointer - JSON Pointer (string or array) to a JSON schema\n   * //   schema - the JSON schema\n   * //  { boolean = false } errors - Show errors?\n   * // { Pointer } - JSON Pointer (string) to the value in the data object\n   */\n  static toDataPointer(schemaPointer, schema, errors = false) {\n    if (this.isJsonPointer(schemaPointer) && typeof schema === 'object' &&\n      this.has(schema, schemaPointer)\n    ) {\n      const pointerArray = this.parse(schemaPointer);\n      if (!pointerArray.length) { return ''; }\n      const firstKey = pointerArray.shift();\n      if (firstKey === 'properties' ||\n        (firstKey === 'items' && isArray(schema.items))\n      ) {\n        const secondKey = pointerArray.shift();\n        const pointerSuffix = this.toDataPointer(pointerArray, schema[firstKey][secondKey]);\n        return pointerSuffix === null ? null : '/' + secondKey + pointerSuffix;\n      } else if (firstKey === 'additionalItems' ||\n        (firstKey === 'items' && isObject(schema.items))\n      ) {\n        const pointerSuffix = this.toDataPointer(pointerArray, schema[firstKey]);\n        return pointerSuffix === null ? null : '/-' + pointerSuffix;\n      } else if (['allOf', 'anyOf', 'oneOf'].includes(firstKey)) {\n        const secondKey = pointerArray.shift();\n        return this.toDataPointer(pointerArray, schema[firstKey][secondKey]);\n      } else if (firstKey === 'not') {\n        return this.toDataPointer(pointerArray, schema[firstKey]);\n      } else if (['contains', 'definitions', 'dependencies', 'additionalItems',\n        'additionalProperties', 'patternProperties', 'propertyNames'].includes(firstKey)\n      ) {\n        if (errors) { console.error(`toDataPointer error: Ambiguous location`); }\n      }\n      return '';\n    }\n    if (errors) {\n      if (!this.isJsonPointer(schemaPointer)) {\n        console.error(`toDataPointer error: Invalid JSON Pointer: ${schemaPointer}`);\n      }\n      if (typeof schema !== 'object') {\n        console.error(`toDataPointer error: Invalid JSON Schema: ${schema}`);\n      }\n      if (typeof schema !== 'object') {\n        console.error(`toDataPointer error: Pointer ${schemaPointer} invalid for Schema: ${schema}`);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * 'parseObjectPath' function\n   *\n   * Parses a JavaScript object path into an array of keys, which\n   * can then be passed to compile() to convert into a string JSON Pointer.\n   *\n   * Based on mike-marcacci's excellent objectpath parse function:\n   * https://github.com/mike-marcacci/objectpath\n   *\n   * //  { Pointer } path - The object path to parse\n   * // { string[] } - The resulting array of keys\n   */\n  static parseObjectPath(path) {\n    if (isArray(path)) { return <string[]>path; }\n    if (this.isJsonPointer(path)) { return this.parse(path); }\n    if (typeof path === 'string') {\n      let index = 0;\n      const parts: string[] = [];\n      while (index < path.length) {\n        const nextDot = path.indexOf('.', index);\n        const nextOB = path.indexOf('[', index); // next open bracket\n        if (nextDot === -1 && nextOB === -1) { // last item\n          parts.push(path.slice(index));\n          index = path.length;\n        } else if (nextDot !== -1 && (nextDot < nextOB || nextOB === -1)) { // dot notation\n          parts.push(path.slice(index, nextDot));\n          index = nextDot + 1;\n        } else { // bracket notation\n          if (nextOB > index) {\n            parts.push(path.slice(index, nextOB));\n            index = nextOB;\n          }\n          const quote = path.charAt(nextOB + 1);\n          if (quote === '\"' || quote === '\\'') { // enclosing quotes\n            let nextCB = path.indexOf(quote + ']', nextOB); // next close bracket\n            while (nextCB !== -1 && path.charAt(nextCB - 1) === '\\\\') {\n              nextCB = path.indexOf(quote + ']', nextCB + 2);\n            }\n            if (nextCB === -1) { nextCB = path.length; }\n            parts.push(path.slice(index + 2, nextCB)\n              .replace(new RegExp('\\\\' + quote, 'g'), quote));\n            index = nextCB + 2;\n          } else { // no enclosing quotes\n            let nextCB = path.indexOf(']', nextOB); // next close bracket\n            if (nextCB === -1) { nextCB = path.length; }\n            parts.push(path.slice(index + 1, nextCB));\n            index = nextCB + 1;\n          }\n          if (path.charAt(index) === '.') { index++; }\n        }\n      }\n      return parts;\n    }\n    console.error('parseObjectPath error: Input object path must be a string.');\n  }\n}\n","// updated from AJV fast format regular expressions:\n// https://github.com/epoberezkin/ajv/blob/master/lib/compile/formats.js\n\nexport const jsonSchemaFormatTests = {\n\n  'date': /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/,\n\n  'time': /^[0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)?$/i,\n\n  // Modified to allow incomplete entries, such as\n  // \"2000-03-14T01:59:26.535\" (needs \"Z\") or \"2000-03-14T01:59\" (needs \":00Z\")\n  'date-time': /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d(?::[0-5]\\d)?(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)?$/i,\n\n  // email (sources from jsen validator):\n  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363\n  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')\n  'email': /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n\n  'hostname': /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i,\n\n  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n  'ipv4': /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n\n  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses\n  // tslint:disable-next-line:max-line-length\n  'ipv6': /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,\n\n  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n  'uri': /^(?:[a-z][a-z0-9+-.]*)(?::|\\/)\\/?[^\\s]*$/i,\n\n  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n  'uri-reference': /^(?:(?:[a-z][a-z0-9+-.]*:)?\\/\\/)?[^\\s]*$/i,\n\n  // uri-template: https://tools.ietf.org/html/rfc6570\n  // tslint:disable-next-line:max-line-length\n  'uri-template': /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i,\n\n  // For the source: https://gist.github.com/dperini/729294\n  // For test cases: https://mathiasbynens.be/demo/url-regex\n  // tslint:disable-next-line:max-line-length\n  // @todo Delete current URL in favour of the commented out URL rule when this ajv issue is fixed https://github.com/eslint/eslint/issues/7983.\n  // tslint:disable-next-line:max-line-length\n  // URL: /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu,\n  // tslint:disable-next-line:max-line-length\n  'url': /^(?:(?:http[s\\u017F]?|ftp):\\/\\/)(?:(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+(?::(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?@)?(?:(?!10(?:\\.[0-9]{1,3}){3})(?!127(?:\\.[0-9]{1,3}){3})(?!169\\.254(?:\\.[0-9]{1,3}){2})(?!192\\.168(?:\\.[0-9]{1,3}){2})(?!172\\.(?:1[6-9]|2[0-9]|3[01])(?:\\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-?)*(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)(?:\\.(?:(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-?)*(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)*(?:\\.(?:(?:[KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\\/(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?$/i,\n\n  // uuid: http://tools.ietf.org/html/rfc4122\n  'uuid': /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,\n\n  // optimized https://gist.github.com/olmokramer/82ccce673f86db7cda5e\n  // tslint:disable-next-line:max-line-length\n  'color': /^\\s*(#(?:[\\da-f]{3}){1,2}|rgb\\((?:\\d{1,3},\\s*){2}\\d{1,3}\\)|rgba\\((?:\\d{1,3},\\s*){3}\\d*\\.?\\d+\\)|hsl\\(\\d{1,3}(?:,\\s*\\d{1,3}%){2}\\)|hsla\\(\\d{1,3}(?:,\\s*\\d{1,3}%){2},\\s*\\d*\\.?\\d+\\))\\s*$/gi,\n\n  // JSON-pointer: https://tools.ietf.org/html/rfc6901\n  'json-pointer': /^(?:\\/(?:[^~/]|~0|~1)*)*$|^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,\n\n  'relative-json-pointer': /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/,\n\n  'regex': function (str) {\n    if (/[^\\\\]\\\\Z/.test(str)) { return false; }\n    try {\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n};\n\nexport type JsonSchemaFormatNames =\n  'date' | 'time' | 'date-time' | 'email' | 'hostname' | 'ipv4' | 'ipv6' |\n  'uri' | 'uri-reference' | 'uri-template' | 'url' | 'uuid' | 'color' |\n  'json-pointer' | 'relative-json-pointer' | 'regex';\n","import isEqual from 'lodash/isEqual';\nimport {\n  _executeAsyncValidators,\n  _executeValidators,\n  _mergeErrors,\n  _mergeObjects,\n  AsyncIValidatorFn,\n  getType,\n  hasValue,\n  isArray,\n  isBoolean,\n  isDefined,\n  isEmpty,\n  isNumber,\n  isString,\n  isType,\n  IValidatorFn,\n  SchemaPrimitiveType,\n  toJavaScriptType,\n  toObservable,\n  xor\n  } from './validator.functions';\nimport { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';\nimport { forEachCopy } from './utility.functions';\nimport { forkJoin } from 'rxjs';\nimport { JsonSchemaFormatNames, jsonSchemaFormatTests } from './format-regex.constants';\nimport { map } from 'rxjs/operators';\n\n\n\n/**\n * 'JsonValidators' class\n *\n * Provides an extended set of validators to be used by form controls,\n * compatible with standard JSON Schema validation options.\n * http://json-schema.org/latest/json-schema-validation.html\n *\n * Note: This library is designed as a drop-in replacement for the Angular\n * Validators library, and except for one small breaking change to the 'pattern'\n * validator (described below) it can even be imported as a substitute, like so:\n *\n *   import { JsonValidators as Validators } from 'json-validators';\n *\n * and it should work with existing code as a complete replacement.\n *\n * The one exception is the 'pattern' validator, which has been changed to\n * matche partial values by default (the standard 'pattern' validator wrapped\n * all patterns in '^' and '$', forcing them to always match an entire value).\n * However, the old behavior can be restored by simply adding '^' and '$'\n * around your patterns, or by passing an optional second parameter of TRUE.\n * This change is to make the 'pattern' validator match the behavior of a\n * JSON Schema pattern, which allows partial matches, rather than the behavior\n * of an HTML input control pattern, which does not.\n *\n * This library replaces Angular's validators and combination functions\n * with the following validators and transformation functions:\n *\n * Validators:\n *   For all formControls:     required (*), type, enum, const\n *   For text formControls:    minLength (*), maxLength (*), pattern (*), format\n *   For numeric formControls: maximum, exclusiveMaximum,\n *                             minimum, exclusiveMinimum, multipleOf\n *   For formGroup objects:    minProperties, maxProperties, dependencies\n *   For formArray arrays:     minItems, maxItems, uniqueItems, contains\n *   Not used by JSON Schema:  min (*), max (*), requiredTrue (*), email (*)\n * (Validators originally included with Angular are maked with (*).)\n *\n * NOTE / TODO: The dependencies validator is not complete.\n * NOTE / TODO: The contains validator is not complete.\n *\n * Validators not used by JSON Schema (but included for compatibility)\n * and their JSON Schema equivalents:\n *\n *   Angular validator | JSON Schema equivalent\n *   ------------------|-----------------------\n *     min(number)     |   minimum(number)\n *     max(number)     |   maximum(number)\n *     requiredTrue()  |   const(true)\n *     email()         |   format('email')\n *\n * Validator transformation functions:\n *   composeAnyOf, composeOneOf, composeAllOf, composeNot\n * (Angular's original combination funciton, 'compose', is also included for\n * backward compatibility, though it is functionally equivalent to composeAllOf,\n * asside from its more generic error message.)\n *\n * All validators have also been extended to accept an optional second argument\n * which, if passed a TRUE value, causes the validator to perform the opposite\n * of its original finction. (This is used internally to enable 'not' and\n * 'composeOneOf' to function and return useful error messages.)\n *\n * The 'required' validator has also been overloaded so that if called with\n * a boolean parameter (or no parameters) it returns the original validator\n * function (rather than executing it). However, if it is called with an\n * AbstractControl parameter (as was previously required), it behaves\n * exactly as before.\n *\n * This enables all validators (including 'required') to be constructed in\n * exactly the same way, so they can be automatically applied using the\n * equivalent key names and values taken directly from a JSON Schema.\n *\n * This source code is partially derived from Angular,\n * which is Copyright (c) 2014-2017 Google, Inc.\n * Use of this source code is therefore governed by the same MIT-style license\n * that can be found in the LICENSE file at https://angular.io/license\n *\n * Original Angular Validators:\n * https://github.com/angular/angular/blob/master/packages/forms/src/validators.ts\n */\nexport class JsonValidators {\n\n  /**\n   * Validator functions:\n   *\n   * For all formControls:     required, type, enum, const\n   * For text formControls:    minLength, maxLength, pattern, format\n   * For numeric formControls: maximum, exclusiveMaximum,\n   *                           minimum, exclusiveMinimum, multipleOf\n   * For formGroup objects:    minProperties, maxProperties, dependencies\n   * For formArray arrays:     minItems, maxItems, uniqueItems, contains\n   *\n   * TODO: finish dependencies validator\n   */\n\n  /**\n   * 'required' validator\n   *\n   * This validator is overloaded, compared to the default required validator.\n   * If called with no parameters, or TRUE, this validator returns the\n   * 'required' validator function (rather than executing it). This matches\n   * the behavior of all other validators in this library.\n   *\n   * If this validator is called with an AbstractControl parameter\n   * (as was previously required) it behaves the same as Angular's default\n   * required validator, and returns an error if the control is empty.\n   *\n   * Old behavior: (if input type = AbstractControl)\n   * // {AbstractControl} control - required control\n   * // {{[key: string]: boolean}} - returns error message if no input\n   *\n   * New behavior: (if no input, or input type = boolean)\n   * // {boolean = true} required? - true to validate, false to disable\n   * // {IValidatorFn} - returns the 'required' validator function itself\n   */\n  static required(input: AbstractControl): ValidationErrors|null;\n  static required(input?: boolean): IValidatorFn;\n\n  static required(input?: AbstractControl|boolean): ValidationErrors|null|IValidatorFn {\n    if (input === undefined) { input = true; }\n    switch (input) {\n      case true: // Return required function (do not execute it yet)\n        return (control: AbstractControl, invert = false): ValidationErrors|null => {\n          if (invert) { return null; } // if not required, always return valid\n          return hasValue(control.value) ? null : { 'required': true };\n        };\n      case false: // Do nothing (if field is not required, it is always valid)\n        return JsonValidators.nullValidator;\n      default: // Execute required function\n        return hasValue((<AbstractControl>input).value) ? null : { 'required': true };\n    }\n  }\n\n  /**\n   * 'type' validator\n   *\n   * Requires a control to only accept values of a specified type,\n   * or one of an array of types.\n   *\n   * Note: SchemaPrimitiveType = 'string'|'number'|'integer'|'boolean'|'null'\n   *\n   * // {SchemaPrimitiveType|SchemaPrimitiveType[]} type - type(s) to accept\n   * // {IValidatorFn}\n   */\n  static type(requiredType: SchemaPrimitiveType|SchemaPrimitiveType[]): IValidatorFn {\n    if (!hasValue(requiredType)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue: any = control.value;\n      const isValid = isArray(requiredType) ?\n        (<SchemaPrimitiveType[]>requiredType).some(type => isType(currentValue, type)) :\n        isType(currentValue, <SchemaPrimitiveType>requiredType);\n      return xor(isValid, invert) ?\n        null : { 'type': { requiredType, currentValue } };\n    };\n  }\n\n  /**\n   * 'enum' validator\n   *\n   * Requires a control to have a value from an enumerated list of values.\n   *\n   * Converts types as needed to allow string inputs to still correctly\n   * match number, boolean, and null enum values.\n   *\n   * // {any[]} allowedValues - array of acceptable values\n   * // {IValidatorFn}\n   */\n  static enum(allowedValues: any[]): IValidatorFn {\n    if (!isArray(allowedValues)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue: any = control.value;\n      const isEqualVal = (enumValue, inputValue) =>\n        enumValue === inputValue ||\n        (isNumber(enumValue) && +inputValue === +enumValue) ||\n        (isBoolean(enumValue, 'strict') &&\n          toJavaScriptType(inputValue, 'boolean') === enumValue) ||\n        (enumValue === null && !hasValue(inputValue)) ||\n        isEqual(enumValue, inputValue);\n      const isValid = isArray(currentValue) ?\n        currentValue.every(inputValue => allowedValues.some(enumValue =>\n          isEqualVal(enumValue, inputValue)\n        )) :\n        allowedValues.some(enumValue => isEqualVal(enumValue, currentValue));\n      return xor(isValid, invert) ?\n        null : { 'enum': { allowedValues, currentValue } };\n    };\n  }\n\n  /**\n   * 'const' validator\n   *\n   * Requires a control to have a specific value.\n   *\n   * Converts types as needed to allow string inputs to still correctly\n   * match number, boolean, and null values.\n   *\n   * TODO: modify to work with objects\n   *\n   * // {any[]} requiredValue - required value\n   * // {IValidatorFn}\n   */\n  static const(requiredValue: any): IValidatorFn {\n    if (!hasValue(requiredValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue: any = control.value;\n      const isEqualVal = (constValue, inputValue) =>\n        constValue === inputValue ||\n        isNumber(constValue) && +inputValue === +constValue ||\n        isBoolean(constValue, 'strict') &&\n          toJavaScriptType(inputValue, 'boolean') === constValue ||\n        constValue === null && !hasValue(inputValue);\n      const isValid = isEqualVal(requiredValue, currentValue);\n      return xor(isValid, invert) ?\n        null : { 'const': { requiredValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'minLength' validator\n   *\n   * Requires a control's text value to be greater than a specified length.\n   *\n   * // {number} minimumLength - minimum allowed string length\n   * // {boolean = false} invert - instead return error object only if valid\n   * // {IValidatorFn}\n   */\n  static minLength(minimumLength: number): IValidatorFn {\n    if (!hasValue(minimumLength)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentLength = isString(control.value) ? control.value.length : 0;\n      const isValid = currentLength >= minimumLength;\n      return xor(isValid, invert) ?\n        null : { 'minLength': { minimumLength, currentLength } };\n    };\n  }\n\n  /**\n   * 'maxLength' validator\n   *\n   * Requires a control's text value to be less than a specified length.\n   *\n   * // {number} maximumLength - maximum allowed string length\n   * // {boolean = false} invert - instead return error object only if valid\n   * // {IValidatorFn}\n   */\n  static maxLength(maximumLength: number): IValidatorFn {\n    if (!hasValue(maximumLength)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const currentLength = isString(control.value) ? control.value.length : 0;\n      const isValid = currentLength <= maximumLength;\n      return xor(isValid, invert) ?\n        null : { 'maxLength': { maximumLength, currentLength } };\n    };\n  }\n\n  /**\n   * 'pattern' validator\n   *\n   * Note: NOT the same as Angular's default pattern validator.\n   *\n   * Requires a control's value to match a specified regular expression pattern.\n   *\n   * This validator changes the behavior of default pattern validator\n   * by replacing RegExp(`^${pattern}$`) with RegExp(`${pattern}`),\n   * which allows for partial matches.\n   *\n   * To return to the default funcitonality, and match the entire string,\n   * pass TRUE as the optional second parameter.\n   *\n   * // {string} pattern - regular expression pattern\n   * // {boolean = false} wholeString - match whole value string?\n   * // {IValidatorFn}\n   */\n  static pattern(pattern: string|RegExp, wholeString = false): IValidatorFn {\n    if (!hasValue(pattern)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      let regex: RegExp;\n      let requiredPattern: string;\n      if (typeof pattern === 'string') {\n        requiredPattern = (wholeString) ? `^${pattern}$` : pattern;\n        regex = new RegExp(requiredPattern);\n      } else {\n        requiredPattern = pattern.toString();\n        regex = pattern;\n      }\n      const currentValue: string = control.value;\n      const isValid = isString(currentValue) ? regex.test(currentValue) : false;\n      return xor(isValid, invert) ?\n        null : { 'pattern': { requiredPattern, currentValue } };\n    };\n  }\n\n  /**\n   * 'format' validator\n   *\n   * Requires a control to have a value of a certain format.\n   *\n   * This validator currently checks the following formsts:\n   *   date, time, date-time, email, hostname, ipv4, ipv6,\n   *   uri, uri-reference, uri-template, url, uuid, color,\n   *   json-pointer, relative-json-pointer, regex\n   *\n   * Fast format regular expressions copied from AJV:\n   * https://github.com/epoberezkin/ajv/blob/master/lib/compile/formats.js\n   *\n   * // {JsonSchemaFormatNames} requiredFormat - format to check\n   * // {IValidatorFn}\n   */\n  static format(requiredFormat: JsonSchemaFormatNames): IValidatorFn {\n    if (!hasValue(requiredFormat)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      let isValid: boolean;\n      const currentValue: string|Date = control.value;\n      if (isString(currentValue)) {\n        const formatTest: Function|RegExp = jsonSchemaFormatTests[requiredFormat];\n        if (typeof formatTest === 'object') {\n          isValid = (<RegExp>formatTest).test(<string>currentValue);\n        } else if (typeof formatTest === 'function') {\n          isValid = (<Function>formatTest)(<string>currentValue);\n        } else {\n          console.error(`format validator error: \"${requiredFormat}\" is not a recognized format.`);\n          isValid = true;\n        }\n      } else {\n        // Allow JavaScript Date objects\n        isValid = ['date', 'time', 'date-time'].includes(requiredFormat) &&\n          Object.prototype.toString.call(currentValue) === '[object Date]';\n      }\n      return xor(isValid, invert) ?\n        null : { 'format': { requiredFormat, currentValue } };\n    };\n  }\n\n  /**\n   * 'minimum' validator\n   *\n   * Requires a control's numeric value to be greater than or equal to\n   * a minimum amount.\n   *\n   * Any non-numeric value is also valid (according to the HTML forms spec,\n   * a non-numeric value doesn't have a minimum).\n   * https://www.w3.org/TR/html5/forms.html#attr-input-max\n   *\n   * // {number} minimum - minimum allowed value\n   * // {IValidatorFn}\n   */\n  static minimum(minimumValue: number): IValidatorFn {\n    if (!hasValue(minimumValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue = control.value;\n      const isValid = !isNumber(currentValue) || currentValue >= minimumValue;\n      return xor(isValid, invert) ?\n        null : { 'minimum': { minimumValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'exclusiveMinimum' validator\n   *\n   * Requires a control's numeric value to be less than a maximum amount.\n   *\n   * Any non-numeric value is also valid (according to the HTML forms spec,\n   * a non-numeric value doesn't have a maximum).\n   * https://www.w3.org/TR/html5/forms.html#attr-input-max\n   *\n   * // {number} exclusiveMinimumValue - maximum allowed value\n   * // {IValidatorFn}\n   */\n  static exclusiveMinimum(exclusiveMinimumValue: number): IValidatorFn {\n    if (!hasValue(exclusiveMinimumValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue = control.value;\n      const isValid = !isNumber(currentValue) || +currentValue < exclusiveMinimumValue;\n      return xor(isValid, invert) ?\n        null : { 'exclusiveMinimum': { exclusiveMinimumValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'maximum' validator\n   *\n   * Requires a control's numeric value to be less than or equal to\n   * a maximum amount.\n   *\n   * Any non-numeric value is also valid (according to the HTML forms spec,\n   * a non-numeric value doesn't have a maximum).\n   * https://www.w3.org/TR/html5/forms.html#attr-input-max\n   *\n   * // {number} maximumValue - maximum allowed value\n   * // {IValidatorFn}\n   */\n  static maximum(maximumValue: number): IValidatorFn {\n    if (!hasValue(maximumValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue = control.value;\n      const isValid = !isNumber(currentValue) || +currentValue <= maximumValue;\n      return xor(isValid, invert) ?\n        null : { 'maximum': { maximumValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'exclusiveMaximum' validator\n   *\n   * Requires a control's numeric value to be less than a maximum amount.\n   *\n   * Any non-numeric value is also valid (according to the HTML forms spec,\n   * a non-numeric value doesn't have a maximum).\n   * https://www.w3.org/TR/html5/forms.html#attr-input-max\n   *\n   * // {number} exclusiveMaximumValue - maximum allowed value\n   * // {IValidatorFn}\n   */\n  static exclusiveMaximum(exclusiveMaximumValue: number): IValidatorFn {\n    if (!hasValue(exclusiveMaximumValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue = control.value;\n      const isValid = !isNumber(currentValue) || +currentValue < exclusiveMaximumValue;\n      return xor(isValid, invert) ?\n        null : { 'exclusiveMaximum': { exclusiveMaximumValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'multipleOf' validator\n   *\n   * Requires a control to have a numeric value that is a multiple\n   * of a specified number.\n   *\n   * // {number} multipleOfValue - number value must be a multiple of\n   * // {IValidatorFn}\n   */\n  static multipleOf(multipleOfValue: number): IValidatorFn {\n    if (!hasValue(multipleOfValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue = control.value;\n      const isValid = isNumber(currentValue) &&\n        currentValue % multipleOfValue === 0;\n      return xor(isValid, invert) ?\n        null : { 'multipleOf': { multipleOfValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'minProperties' validator\n   *\n   * Requires a form group to have a minimum number of properties (i.e. have\n   * values entered in a minimum number of controls within the group).\n   *\n   * // {number} minimumProperties - minimum number of properties allowed\n   * // {IValidatorFn}\n   */\n  static minProperties(minimumProperties: number): IValidatorFn {\n    if (!hasValue(minimumProperties)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentProperties = Object.keys(control.value).length || 0;\n      const isValid = currentProperties >= minimumProperties;\n      return xor(isValid, invert) ?\n        null : { 'minProperties': { minimumProperties, currentProperties } };\n    };\n  }\n\n  /**\n   * 'maxProperties' validator\n   *\n   * Requires a form group to have a maximum number of properties (i.e. have\n   * values entered in a maximum number of controls within the group).\n   *\n   * Note: Has no effect if the form group does not contain more than the\n   * maximum number of controls.\n   *\n   * // {number} maximumProperties - maximum number of properties allowed\n   * // {IValidatorFn}\n   */\n  static maxProperties(maximumProperties: number): IValidatorFn {\n    if (!hasValue(maximumProperties)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const currentProperties = Object.keys(control.value).length || 0;\n      const isValid = currentProperties <= maximumProperties;\n      return xor(isValid, invert) ?\n        null : { 'maxProperties': { maximumProperties, currentProperties } };\n    };\n  }\n\n  /**\n   * 'dependencies' validator\n   *\n   * Requires the controls in a form group to meet additional validation\n   * criteria, depending on the values of other controls in the group.\n   *\n   * Examples:\n   * https://spacetelescope.github.io/understanding-json-schema/reference/object.html#dependencies\n   *\n   * // {any} dependencies - required dependencies\n   * // {IValidatorFn}\n   */\n  static dependencies(dependencies: any): IValidatorFn {\n    if (getType(dependencies) !== 'object' || isEmpty(dependencies)) {\n      return JsonValidators.nullValidator;\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const allErrors = _mergeObjects(\n        forEachCopy(dependencies, (value, requiringField) => {\n          if (!hasValue(control.value[requiringField])) { return null; }\n          let requiringFieldErrors: ValidationErrors = { };\n          let requiredFields: string[];\n          let properties: ValidationErrors = { };\n          if (getType(dependencies[requiringField]) === 'array') {\n            requiredFields = dependencies[requiringField];\n          } else if (getType(dependencies[requiringField]) === 'object') {\n            requiredFields = dependencies[requiringField]['required'] || [];\n            properties = dependencies[requiringField]['properties'] || { };\n          }\n\n          // Validate property dependencies\n          for (const requiredField of requiredFields) {\n            if (xor(!hasValue(control.value[requiredField]), invert)) {\n              requiringFieldErrors[requiredField] = { 'required': true };\n            }\n          }\n\n          // Validate schema dependencies\n          requiringFieldErrors = _mergeObjects(requiringFieldErrors,\n            forEachCopy(properties, (requirements, requiredField) => {\n              const requiredFieldErrors = _mergeObjects(\n                forEachCopy(requirements, (requirement, parameter) => {\n                  let validator: IValidatorFn = null;\n                  if (requirement === 'maximum' || requirement === 'minimum') {\n                    const exclusive = !!requirements['exclusiveM' + requirement.slice(1)];\n                    validator = JsonValidators[requirement](parameter, exclusive);\n                  } else if (typeof JsonValidators[requirement] === 'function') {\n                    validator = JsonValidators[requirement](parameter);\n                  }\n                  return !isDefined(validator) ?\n                    null : validator(control.value[requiredField]);\n                })\n              );\n              return isEmpty(requiredFieldErrors) ?\n                null : { [requiredField]: requiredFieldErrors };\n            })\n          );\n          return isEmpty(requiringFieldErrors) ?\n            null : { [requiringField]: requiringFieldErrors };\n        })\n      );\n      return isEmpty(allErrors) ? null : allErrors;\n    };\n  }\n\n  /**\n   * 'minItems' validator\n   *\n   * Requires a form array to have a minimum number of values.\n   *\n   * // {number} minimumItems - minimum number of items allowed\n   * // {IValidatorFn}\n   */\n  static minItems(minimumItems: number): IValidatorFn {\n    if (!hasValue(minimumItems)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentItems = isArray(control.value) ? control.value.length : 0;\n      const isValid = currentItems >= minimumItems;\n      return xor(isValid, invert) ?\n        null : { 'minItems': { minimumItems, currentItems } };\n    };\n  }\n\n  /**\n   * 'maxItems' validator\n   *\n   * Requires a form array to have a maximum number of values.\n   *\n   * // {number} maximumItems - maximum number of items allowed\n   * // {IValidatorFn}\n   */\n  static maxItems(maximumItems: number): IValidatorFn {\n    if (!hasValue(maximumItems)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const currentItems = isArray(control.value) ? control.value.length : 0;\n      const isValid = currentItems <= maximumItems;\n      return xor(isValid, invert) ?\n        null : { 'maxItems': { maximumItems, currentItems } };\n    };\n  }\n\n  /**\n   * 'uniqueItems' validator\n   *\n   * Requires values in a form array to be unique.\n   *\n   * // {boolean = true} unique? - true to validate, false to disable\n   * // {IValidatorFn}\n   */\n  static uniqueItems(unique = true): IValidatorFn {\n    if (!unique) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const sorted: any[] = control.value.slice().sort();\n      const duplicateItems = [];\n      for (let i = 1; i < sorted.length; i++) {\n        if (sorted[i - 1] === sorted[i] && duplicateItems.includes(sorted[i])) {\n          duplicateItems.push(sorted[i]);\n        }\n      }\n      const isValid = !duplicateItems.length;\n      return xor(isValid, invert) ?\n        null : { 'uniqueItems': { duplicateItems } };\n    };\n  }\n\n  /**\n   * 'contains' validator\n   *\n   * TODO: Complete this validator\n   *\n   * Requires values in a form array to be unique.\n   *\n   * // {boolean = true} unique? - true to validate, false to disable\n   * // {IValidatorFn}\n   */\n  static contains(requiredItem = true): IValidatorFn {\n    if (!requiredItem) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value) || !isArray(control.value)) { return null; }\n      const currentItems = control.value;\n      // const isValid = currentItems.some(item =>\n      //\n      // );\n      const isValid = true;\n      return xor(isValid, invert) ?\n        null : { 'contains': { requiredItem, currentItems } };\n    };\n  }\n\n  /**\n   * No-op validator. Included for backward compatibility.\n   */\n  static nullValidator(control: AbstractControl): ValidationErrors|null {\n    return null;\n  }\n\n  /**\n   * Validator transformation functions:\n   * composeAnyOf, composeOneOf, composeAllOf, composeNot,\n   * compose, composeAsync\n   *\n   * TODO: Add composeAnyOfAsync, composeOneOfAsync,\n   *           composeAllOfAsync, composeNotAsync\n   */\n\n  /**\n   * 'composeAnyOf' validator combination function\n   *\n   * Accepts an array of validators and returns a single validator that\n   * evaluates to valid if any one or more of the submitted validators are\n   * valid. If every validator is invalid, it returns combined errors from\n   * all validators.\n   *\n   * // {IValidatorFn[]} validators - array of validators to combine\n   * // {IValidatorFn} - single combined validator function\n   */\n  static composeAnyOf(validators: IValidatorFn[]): IValidatorFn {\n    if (!validators) { return null; }\n    const presentValidators = validators.filter(isDefined);\n    if (presentValidators.length === 0) { return null; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const arrayOfErrors =\n        _executeValidators(control, presentValidators, invert).filter(isDefined);\n      const isValid = validators.length > arrayOfErrors.length;\n      return xor(isValid, invert) ?\n        null : _mergeObjects(...arrayOfErrors, { 'anyOf': !invert });\n    };\n  }\n\n  /**\n   * 'composeOneOf' validator combination function\n   *\n   * Accepts an array of validators and returns a single validator that\n   * evaluates to valid only if exactly one of the submitted validators\n   * is valid. Otherwise returns combined information from all validators,\n   * both valid and invalid.\n   *\n   * // {IValidatorFn[]} validators - array of validators to combine\n   * // {IValidatorFn} - single combined validator function\n   */\n  static composeOneOf(validators: IValidatorFn[]): IValidatorFn {\n    if (!validators) { return null; }\n    const presentValidators = validators.filter(isDefined);\n    if (presentValidators.length === 0) { return null; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const arrayOfErrors =\n        _executeValidators(control, presentValidators);\n      const validControls =\n        validators.length - arrayOfErrors.filter(isDefined).length;\n      const isValid = validControls === 1;\n      if (xor(isValid, invert)) { return null; }\n      const arrayOfValids =\n        _executeValidators(control, presentValidators, invert);\n      return _mergeObjects(...arrayOfErrors, ...arrayOfValids, { 'oneOf': !invert });\n    };\n  }\n\n  /**\n   * 'composeAllOf' validator combination function\n   *\n   * Accepts an array of validators and returns a single validator that\n   * evaluates to valid only if all the submitted validators are individually\n   * valid. Otherwise it returns combined errors from all invalid validators.\n   *\n   * // {IValidatorFn[]} validators - array of validators to combine\n   * // {IValidatorFn} - single combined validator function\n   */\n  static composeAllOf(validators: IValidatorFn[]): IValidatorFn {\n    if (!validators) { return null; }\n    const presentValidators = validators.filter(isDefined);\n    if (presentValidators.length === 0) { return null; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const combinedErrors = _mergeErrors(\n        _executeValidators(control, presentValidators, invert)\n      );\n      const isValid = combinedErrors === null;\n      return (xor(isValid, invert)) ?\n        null : _mergeObjects(combinedErrors, { 'allOf': !invert });\n    };\n  }\n\n  /**\n   * 'composeNot' validator inversion function\n   *\n   * Accepts a single validator function and inverts its result.\n   * Returns valid if the submitted validator is invalid, and\n   * returns invalid if the submitted validator is valid.\n   * (Note: this function can itself be inverted\n   *   - e.g. composeNot(composeNot(validator)) -\n   *   but this can be confusing and is therefore not recommended.)\n   *\n   * // {IValidatorFn[]} validators - validator(s) to invert\n   * // {IValidatorFn} - new validator function that returns opposite result\n   */\n  static composeNot(validator: IValidatorFn): IValidatorFn {\n    if (!validator) { return null; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const error = validator(control, !invert);\n      const isValid = error === null;\n      return (xor(isValid, invert)) ?\n        null : _mergeObjects(error, { 'not': !invert });\n    };\n  }\n\n  /**\n   * 'compose' validator combination function\n   *\n   * // {IValidatorFn[]} validators - array of validators to combine\n   * // {IValidatorFn} - single combined validator function\n   */\n  static compose(validators: IValidatorFn[]): IValidatorFn {\n    if (!validators) { return null; }\n    const presentValidators = validators.filter(isDefined);\n    if (presentValidators.length === 0) { return null; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null =>\n      _mergeErrors(_executeValidators(control, presentValidators, invert));\n  }\n\n  /**\n   * 'composeAsync' async validator combination function\n   *\n   * // {AsyncIValidatorFn[]} async validators - array of async validators\n   * // {AsyncIValidatorFn} - single combined async validator function\n   */\n  static composeAsync(validators: AsyncIValidatorFn[]): AsyncIValidatorFn {\n    if (!validators) { return null; }\n    const presentValidators = validators.filter(isDefined);\n    if (presentValidators.length === 0) { return null; }\n    return (control: AbstractControl) => {\n      const observables =\n        _executeAsyncValidators(control, presentValidators).map(toObservable);\n      return map.call(forkJoin(observables), _mergeErrors);\n    };\n  }\n\n  // Additional angular validators (not used by Angualr JSON Schema Form)\n  // From https://github.com/angular/angular/blob/master/packages/forms/src/validators.ts\n\n  /**\n   * Validator that requires controls to have a value greater than a number.\n   */\n  static min(min: number): ValidatorFn {\n    if (!hasValue(min)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl): ValidationErrors|null => {\n      // don't validate empty values to allow optional controls\n      if (isEmpty(control.value) || isEmpty(min)) { return null; }\n      const value = parseFloat(control.value);\n      const actual = control.value;\n      // Controls with NaN values after parsing should be treated as not having a\n      // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min\n      return isNaN(value) || value >= min ? null : { 'min': { min, actual } };\n    };\n  }\n\n  /**\n   * Validator that requires controls to have a value less than a number.\n   */\n  static max(max: number): ValidatorFn {\n    if (!hasValue(max)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl): ValidationErrors|null => {\n      // don't validate empty values to allow optional controls\n      if (isEmpty(control.value) || isEmpty(max)) { return null; }\n      const value = parseFloat(control.value);\n      const actual = control.value;\n      // Controls with NaN values after parsing should be treated as not having a\n      // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max\n      return isNaN(value) || value <= max ? null : { 'max': { max, actual } };\n    };\n  }\n\n  /**\n   * Validator that requires control value to be true.\n   */\n  static requiredTrue(control: AbstractControl): ValidationErrors|null {\n    if (!control) { return JsonValidators.nullValidator; }\n    return control.value === true ? null : { 'required': true };\n  }\n\n  /**\n   * Validator that performs email validation.\n   */\n  static email(control: AbstractControl): ValidationErrors|null {\n    if (!control) { return JsonValidators.nullValidator; }\n    const EMAIL_REGEXP =\n      // tslint:disable-next-line:max-line-length\n      /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;\n    return EMAIL_REGEXP.test(control.value) ? null : { 'email': true };\n  }\n}\n","import isEqual from 'lodash/isEqual';\n\nimport {\n  isArray, isEmpty, isNumber, isObject, isString\n} from './validator.functions';\nimport { hasOwn, uniqueItems, commonItems } from './utility.functions';\nimport { JsonPointer, Pointer } from './jsonpointer.functions';\n\n/**\n * 'mergeSchemas' function\n *\n * Merges multiple JSON schemas into a single schema with combined rules.\n *\n * If able to logically merge properties from all schemas,\n * returns a single schema object containing all merged properties.\n *\n * Example: ({ a: b, max: 1 }, { c: d, max: 2 }) => { a: b, c: d, max: 1 }\n *\n * If unable to logically merge, returns an allOf schema object containing\n * an array of the original schemas;\n *\n * Example: ({ a: b }, { a: d }) => { allOf: [ { a: b }, { a: d } ] }\n *\n * //   schemas - one or more input schemas\n * //  - merged schema\n */\nexport function mergeSchemas(...schemas) {\n  schemas = schemas.filter(schema => !isEmpty(schema));\n  if (schemas.some(schema => !isObject(schema))) { return null; }\n  const combinedSchema: any = {};\n  for (const schema of schemas) {\n    for (const key of Object.keys(schema)) {\n      const combinedValue = combinedSchema[key];\n      const schemaValue = schema[key];\n      if (!hasOwn(combinedSchema, key) || isEqual(combinedValue, schemaValue)) {\n        combinedSchema[key] = schemaValue;\n      } else {\n        switch (key) {\n          case 'allOf':\n            // Combine all items from both arrays\n            if (isArray(combinedValue) && isArray(schemaValue)) {\n              combinedSchema.allOf = mergeSchemas(...combinedValue, ...schemaValue);\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'additionalItems': case 'additionalProperties':\n          case 'contains': case 'propertyNames':\n            // Merge schema objects\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              combinedSchema[key] = mergeSchemas(combinedValue, schemaValue);\n            // additionalProperties == false in any schema overrides all other values\n            } else if (\n              key === 'additionalProperties' &&\n              (combinedValue === false || schemaValue === false)\n            ) {\n              combinedSchema.combinedSchema = false;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'anyOf': case 'oneOf': case 'enum':\n            // Keep only items that appear in both arrays\n            if (isArray(combinedValue) && isArray(schemaValue)) {\n              combinedSchema[key] = combinedValue.filter(item1 =>\n                schemaValue.findIndex(item2 => isEqual(item1, item2)) > -1\n              );\n              if (!combinedSchema[key].length) { return { allOf: [ ...schemas ] }; }\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'definitions':\n            // Combine keys from both objects\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const combinedObject = { ...combinedValue };\n              for (const subKey of Object.keys(schemaValue)) {\n                if (!hasOwn(combinedObject, subKey) ||\n                  isEqual(combinedObject[subKey], schemaValue[subKey])\n                ) {\n                  combinedObject[subKey] = schemaValue[subKey];\n                // Don't combine matching keys with different values\n                } else {\n                  return { allOf: [ ...schemas ] };\n                }\n              }\n              combinedSchema.definitions = combinedObject;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'dependencies':\n            // Combine all keys from both objects\n            // and merge schemas on matching keys,\n            // converting from arrays to objects if necessary\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const combinedObject = { ...combinedValue };\n              for (const subKey of Object.keys(schemaValue)) {\n                if (!hasOwn(combinedObject, subKey) ||\n                  isEqual(combinedObject[subKey], schemaValue[subKey])\n                ) {\n                  combinedObject[subKey] = schemaValue[subKey];\n                // If both keys are arrays, include all items from both arrays,\n                // excluding duplicates\n                } else if (\n                  isArray(schemaValue[subKey]) && isArray(combinedObject[subKey])\n                ) {\n                  combinedObject[subKey] =\n                    uniqueItems(...combinedObject[subKey], ...schemaValue[subKey]);\n                // If either key is an object, merge the schemas\n                } else if (\n                  (isArray(schemaValue[subKey]) || isObject(schemaValue[subKey])) &&\n                  (isArray(combinedObject[subKey]) || isObject(combinedObject[subKey]))\n                ) {\n                  // If either key is an array, convert it to an object first\n                  const required = isArray(combinedSchema.required) ?\n                    combinedSchema.required : [];\n                  const combinedDependency = isArray(combinedObject[subKey]) ?\n                    { required: uniqueItems(...required, combinedObject[subKey]) } :\n                    combinedObject[subKey];\n                  const schemaDependency = isArray(schemaValue[subKey]) ?\n                    { required: uniqueItems(...required, schemaValue[subKey]) } :\n                    schemaValue[subKey];\n                  combinedObject[subKey] =\n                    mergeSchemas(combinedDependency, schemaDependency);\n                } else {\n                  return { allOf: [ ...schemas ] };\n                }\n              }\n              combinedSchema.dependencies = combinedObject;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'items':\n            // If arrays, keep only items that appear in both arrays\n            if (isArray(combinedValue) && isArray(schemaValue)) {\n              combinedSchema.items = combinedValue.filter(item1 =>\n                schemaValue.findIndex(item2 => isEqual(item1, item2)) > -1\n              );\n              if (!combinedSchema.items.length) { return { allOf: [ ...schemas ] }; }\n            // If both keys are objects, merge them\n            } else if (isObject(combinedValue) && isObject(schemaValue)) {\n              combinedSchema.items = mergeSchemas(combinedValue, schemaValue);\n            // If object + array, combine object with each array item\n            } else if (isArray(combinedValue) && isObject(schemaValue)) {\n              combinedSchema.items =\n                combinedValue.map(item => mergeSchemas(item, schemaValue));\n            } else if (isObject(combinedValue) && isArray(schemaValue)) {\n              combinedSchema.items =\n                schemaValue.map(item => mergeSchemas(item, combinedValue));\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'multipleOf':\n            // TODO: Adjust to correctly handle decimal values\n            // If numbers, set to least common multiple\n            if (isNumber(combinedValue) && isNumber(schemaValue)) {\n              const gcd = (x, y) => !y ? x : gcd(y, x % y);\n              const lcm = (x, y) => (x * y) / gcd(x, y);\n              combinedSchema.multipleOf = lcm(combinedValue, schemaValue);\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'maximum': case 'exclusiveMaximum': case 'maxLength':\n          case 'maxItems': case 'maxProperties':\n            // If numbers, set to lowest value\n            if (isNumber(combinedValue) && isNumber(schemaValue)) {\n              combinedSchema[key] = Math.min(combinedValue, schemaValue);\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'minimum': case 'exclusiveMinimum': case 'minLength':\n          case 'minItems': case 'minProperties':\n            // If numbers, set to highest value\n            if (isNumber(combinedValue) && isNumber(schemaValue)) {\n              combinedSchema[key] = Math.max(combinedValue, schemaValue);\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'not':\n            // Combine not values into anyOf array\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const notAnyOf = [combinedValue, schemaValue]\n                .reduce((notAnyOfArray, notSchema) =>\n                  isArray(notSchema.anyOf) &&\n                  Object.keys(notSchema).length === 1 ?\n                    [ ...notAnyOfArray, ...notSchema.anyOf ] :\n                    [ ...notAnyOfArray, notSchema ]\n                , []);\n              // TODO: Remove duplicate items from array\n              combinedSchema.not = { anyOf: notAnyOf };\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'patternProperties':\n            // Combine all keys from both objects\n            // and merge schemas on matching keys\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const combinedObject = { ...combinedValue };\n              for (const subKey of Object.keys(schemaValue)) {\n                if (!hasOwn(combinedObject, subKey) ||\n                  isEqual(combinedObject[subKey], schemaValue[subKey])\n                ) {\n                  combinedObject[subKey] = schemaValue[subKey];\n                // If both keys are objects, merge them\n                } else if (\n                  isObject(schemaValue[subKey]) && isObject(combinedObject[subKey])\n                ) {\n                  combinedObject[subKey] =\n                    mergeSchemas(combinedObject[subKey], schemaValue[subKey]);\n                } else {\n                  return { allOf: [ ...schemas ] };\n                }\n              }\n              combinedSchema.patternProperties = combinedObject;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'properties':\n            // Combine all keys from both objects\n            // unless additionalProperties === false\n            // and merge schemas on matching keys\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const combinedObject = { ...combinedValue };\n              // If new schema has additionalProperties,\n              // merge or remove non-matching property keys in combined schema\n              if (hasOwn(schemaValue, 'additionalProperties')) {\n                Object.keys(combinedValue)\n                  .filter(combinedKey => !Object.keys(schemaValue).includes(combinedKey))\n                  .forEach(nonMatchingKey => {\n                    if (schemaValue.additionalProperties === false) {\n                      delete combinedObject[nonMatchingKey];\n                    } else if (isObject(schemaValue.additionalProperties)) {\n                      combinedObject[nonMatchingKey] = mergeSchemas(\n                        combinedObject[nonMatchingKey],\n                        schemaValue.additionalProperties\n                      );\n                    }\n                  });\n              }\n              for (const subKey of Object.keys(schemaValue)) {\n                if (isEqual(combinedObject[subKey], schemaValue[subKey]) || (\n                  !hasOwn(combinedObject, subKey) &&\n                  !hasOwn(combinedObject, 'additionalProperties')\n                )) {\n                  combinedObject[subKey] = schemaValue[subKey];\n                // If combined schema has additionalProperties,\n                // merge or ignore non-matching property keys in new schema\n                } else if (\n                  !hasOwn(combinedObject, subKey) &&\n                  hasOwn(combinedObject, 'additionalProperties')\n                ) {\n                  // If combinedObject.additionalProperties === false,\n                  // do nothing (don't set key)\n                  // If additionalProperties is object, merge with new key\n                  if (isObject(combinedObject.additionalProperties)) {\n                    combinedObject[subKey] = mergeSchemas(\n                      combinedObject.additionalProperties, schemaValue[subKey]\n                    );\n                  }\n                // If both keys are objects, merge them\n                } else if (\n                  isObject(schemaValue[subKey]) &&\n                  isObject(combinedObject[subKey])\n                ) {\n                  combinedObject[subKey] =\n                    mergeSchemas(combinedObject[subKey], schemaValue[subKey]);\n                } else {\n                  return { allOf: [ ...schemas ] };\n                }\n              }\n              combinedSchema.properties = combinedObject;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'required':\n            // If arrays, include all items from both arrays, excluding duplicates\n            if (isArray(combinedValue) && isArray(schemaValue)) {\n              combinedSchema.required = uniqueItems(...combinedValue, ...schemaValue);\n            // If booleans, aet true if either true\n            } else if (\n              typeof schemaValue === 'boolean' &&\n              typeof combinedValue === 'boolean'\n            ) {\n              combinedSchema.required = !!combinedValue || !!schemaValue;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case '$schema': case '$id': case 'id':\n            // Don't combine these keys\n          break;\n          case 'title': case 'description': case '$comment':\n            // Return the last value, overwriting any previous one\n            // These properties are not used for validation, so conflicts don't matter\n            combinedSchema[key] = schemaValue;\n          break;\n          case 'type':\n            if (\n              (isArray(schemaValue) || isString(schemaValue)) &&\n              (isArray(combinedValue) || isString(combinedValue))\n            ) {\n              const combinedTypes = commonItems(combinedValue, schemaValue);\n              if (!combinedTypes.length) { return { allOf: [ ...schemas ] }; }\n              combinedSchema.type = combinedTypes.length > 1 ? combinedTypes : combinedTypes[0];\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'uniqueItems':\n            // Set true if either true\n            combinedSchema.uniqueItems = !!combinedValue || !!schemaValue;\n          break;\n          default:\n            return { allOf: [ ...schemas ] };\n        }\n      }\n    }\n  }\n  return combinedSchema;\n}\n","import cloneDeep from 'lodash/cloneDeep';\nimport { forEach, hasOwn, mergeFilteredObject } from './utility.functions';\nimport {\n  getType,\n  hasValue,\n  inArray,\n  isArray,\n  isNumber,\n  isObject,\n  isString\n  } from './validator.functions';\nimport { JsonPointer } from './jsonpointer.functions';\nimport { mergeSchemas } from './merge-schemas.function';\n\n\n/**\n * JSON Schema function library:\n *\n * buildSchemaFromLayout:   TODO: Write this function\n *\n * buildSchemaFromData:\n *\n * getFromSchema:\n *\n * removeRecursiveReferences:\n *\n * getInputType:\n *\n * checkInlineType:\n *\n * isInputRequired:\n *\n * updateInputOptions:\n *\n * getTitleMapFromOneOf:\n *\n * getControlValidators:\n *\n * resolveSchemaReferences:\n *\n * getSubSchema:\n *\n * combineAllOf:\n *\n * fixRequiredArrayProperties:\n */\n\n/**\n * 'buildSchemaFromLayout' function\n *\n * TODO: Build a JSON Schema from a JSON Form layout\n *\n * //   layout - The JSON Form layout\n * //  - The new JSON Schema\n */\nexport function buildSchemaFromLayout(layout) {\n  return;\n  // let newSchema: any = { };\n  // const walkLayout = (layoutItems: any[], callback: Function): any[] => {\n  //   let returnArray: any[] = [];\n  //   for (let layoutItem of layoutItems) {\n  //     const returnItem: any = callback(layoutItem);\n  //     if (returnItem) { returnArray = returnArray.concat(callback(layoutItem)); }\n  //     if (layoutItem.items) {\n  //       returnArray = returnArray.concat(walkLayout(layoutItem.items, callback));\n  //     }\n  //   }\n  //   return returnArray;\n  // };\n  // walkLayout(layout, layoutItem => {\n  //   let itemKey: string;\n  //   if (typeof layoutItem === 'string') {\n  //     itemKey = layoutItem;\n  //   } else if (layoutItem.key) {\n  //     itemKey = layoutItem.key;\n  //   }\n  //   if (!itemKey) { return; }\n  //   //\n  // });\n}\n\n/**\n * 'buildSchemaFromData' function\n *\n * Build a JSON Schema from a data object\n *\n * //   data - The data object\n * //  { boolean = false } requireAllFields - Require all fields?\n * //  { boolean = true } isRoot - is root\n * //  - The new JSON Schema\n */\nexport function buildSchemaFromData(\n  data, requireAllFields = false, isRoot = true\n) {\n  const newSchema: any = {};\n  const getFieldType = (value: any): string => {\n    const fieldType = getType(value, 'strict');\n    return { integer: 'number', null: 'string' }[fieldType] || fieldType;\n  };\n  const buildSubSchema = (value) =>\n    buildSchemaFromData(value, requireAllFields, false);\n  if (isRoot) { newSchema.$schema = 'http://json-schema.org/draft-06/schema#'; }\n  newSchema.type = getFieldType(data);\n  if (newSchema.type === 'object') {\n    newSchema.properties = {};\n    if (requireAllFields) { newSchema.required = []; }\n    for (const key of Object.keys(data)) {\n      newSchema.properties[key] = buildSubSchema(data[key]);\n      if (requireAllFields) { newSchema.required.push(key); }\n    }\n  } else if (newSchema.type === 'array') {\n    newSchema.items = data.map(buildSubSchema);\n    // If all items are the same type, use an object for items instead of an array\n    if ((new Set(data.map(getFieldType))).size === 1) {\n      newSchema.items = newSchema.items.reduce((a, b) => ({ ...a, ...b }), {});\n    }\n    if (requireAllFields) { newSchema.minItems = 1; }\n  }\n  return newSchema;\n}\n\n/**\n * 'getFromSchema' function\n *\n * Uses a JSON Pointer for a value within a data object to retrieve\n * the schema for that value within schema for the data object.\n *\n * The optional third parameter can also be set to return something else:\n * 'schema' (default): the schema for the value indicated by the data pointer\n * 'parentSchema': the schema for the value's parent object or array\n * 'schemaPointer': a pointer to the value's schema within the object's schema\n * 'parentSchemaPointer': a pointer to the schema for the value's parent object or array\n *\n * //   schema - The schema to get the sub-schema from\n * //  { Pointer } dataPointer - JSON Pointer (string or array)\n * //  { string = 'schema' } returnType - what to return?\n * //  - The located sub-schema\n */\nexport function getFromSchema(schema, dataPointer, returnType = 'schema') {\n  const dataPointerArray: any[] = JsonPointer.parse(dataPointer);\n  if (dataPointerArray === null) {\n    console.error(`getFromSchema error: Invalid JSON Pointer: ${dataPointer}`);\n    return null;\n  }\n  let subSchema = schema;\n  const schemaPointer = [];\n  const length = dataPointerArray.length;\n  if (returnType.slice(0, 6) === 'parent') { dataPointerArray.length--; }\n  for (let i = 0; i < length; ++i) {\n    const parentSchema = subSchema;\n    const key = dataPointerArray[i];\n    let subSchemaFound = false;\n    if (typeof subSchema !== 'object') {\n      console.error(`getFromSchema error: Unable to find \"${key}\" key in schema.`);\n      console.error(schema);\n      console.error(dataPointer);\n      return null;\n    }\n    if (subSchema.type === 'array' && (!isNaN(key) || key === '-')) {\n      if (hasOwn(subSchema, 'items')) {\n        if (isObject(subSchema.items)) {\n          subSchemaFound = true;\n          subSchema = subSchema.items;\n          schemaPointer.push('items');\n        } else if (isArray(subSchema.items)) {\n          if (!isNaN(key) && subSchema.items.length >= +key) {\n            subSchemaFound = true;\n            subSchema = subSchema.items[+key];\n            schemaPointer.push('items', key);\n          }\n        }\n      }\n      if (!subSchemaFound && isObject(subSchema.additionalItems)) {\n        subSchemaFound = true;\n        subSchema = subSchema.additionalItems;\n        schemaPointer.push('additionalItems');\n      } else if (subSchema.additionalItems !== false) {\n        subSchemaFound = true;\n        subSchema = { };\n        schemaPointer.push('additionalItems');\n      }\n    } else if (subSchema.type === 'object') {\n      if (isObject(subSchema.properties) && hasOwn(subSchema.properties, key)) {\n        subSchemaFound = true;\n        subSchema = subSchema.properties[key];\n        schemaPointer.push('properties', key);\n      } else if (isObject(subSchema.additionalProperties)) {\n        subSchemaFound = true;\n        subSchema = subSchema.additionalProperties;\n        schemaPointer.push('additionalProperties');\n      } else if (subSchema.additionalProperties !== false) {\n        subSchemaFound = true;\n        subSchema = { };\n        schemaPointer.push('additionalProperties');\n      }\n    }\n    if (!subSchemaFound) {\n      console.error(`getFromSchema error: Unable to find \"${key}\" item in schema.`);\n      console.error(schema);\n      console.error(dataPointer);\n      return;\n    }\n  }\n  return returnType.slice(-7) === 'Pointer' ? schemaPointer : subSchema;\n}\n\n/**\n * 'removeRecursiveReferences' function\n *\n * Checks a JSON Pointer against a map of recursive references and returns\n * a JSON Pointer to the shallowest equivalent location in the same object.\n *\n * Using this functions enables an object to be constructed with unlimited\n * recursion, while maintaing a fixed set of metadata, such as field data types.\n * The object can grow as large as it wants, and deeply recursed nodes can\n * just refer to the metadata for their shallow equivalents, instead of having\n * to add additional redundant metadata for each recursively added node.\n *\n * Example:\n *\n * pointer:         '/stuff/and/more/and/more/and/more/and/more/stuff'\n * recursiveRefMap: [['/stuff/and/more/and/more', '/stuff/and/more/']]\n * returned:        '/stuff/and/more/stuff'\n *\n * //  { Pointer } pointer -\n * //  { Map<string, string> } recursiveRefMap -\n * //  { Map<string, number> = new Map() } arrayMap - optional\n * // { string } -\n */\nexport function removeRecursiveReferences(\n  pointer, recursiveRefMap, arrayMap = new Map()\n) {\n  if (!pointer) { return ''; }\n  let genericPointer =\n    JsonPointer.toGenericPointer(JsonPointer.compile(pointer), arrayMap);\n  if (genericPointer.indexOf('/') === -1) { return genericPointer; }\n  let possibleReferences = true;\n  while (possibleReferences) {\n    possibleReferences = false;\n    recursiveRefMap.forEach((toPointer, fromPointer) => {\n      if (JsonPointer.isSubPointer(toPointer, fromPointer)) {\n        while (JsonPointer.isSubPointer(fromPointer, genericPointer, true)) {\n          genericPointer = JsonPointer.toGenericPointer(\n            toPointer + genericPointer.slice(fromPointer.length), arrayMap\n          );\n          possibleReferences = true;\n        }\n      }\n    });\n  }\n  return genericPointer;\n}\n\n/**\n * 'getInputType' function\n *\n * //   schema\n * //  { any = null } layoutNode\n * // { string }\n */\nexport function getInputType(schema, layoutNode: any = null) {\n  // x-schema-form = Angular Schema Form compatibility\n  // widget & component = React Jsonschema Form compatibility\n  const controlType = JsonPointer.getFirst([\n    [schema, '/x-schema-form/type'],\n    [schema, '/x-schema-form/widget/component'],\n    [schema, '/x-schema-form/widget'],\n    [schema, '/widget/component'],\n    [schema, '/widget']\n  ]);\n  if (isString(controlType)) { return checkInlineType(controlType, schema, layoutNode); }\n  let schemaType = schema.type;\n  if (schemaType) {\n    if (isArray(schemaType)) { // If multiple types listed, use most inclusive type\n      schemaType =\n        inArray('object', schemaType) && hasOwn(schema, 'properties') ? 'object' :\n        inArray('array', schemaType) && hasOwn(schema, 'items') ? 'array' :\n        inArray('array', schemaType) && hasOwn(schema, 'additionalItems') ? 'array' :\n        inArray('string', schemaType) ? 'string' :\n        inArray('number', schemaType) ? 'number' :\n        inArray('integer', schemaType) ? 'integer' :\n        inArray('boolean', schemaType) ? 'boolean' : 'unknown';\n    }\n    if (schemaType === 'boolean') { return 'checkbox'; }\n    if (schemaType === 'object') {\n      if (hasOwn(schema, 'properties') || hasOwn(schema, 'additionalProperties')) {\n        return 'section';\n      }\n      // TODO: Figure out how to handle additionalProperties\n      if (hasOwn(schema, '$ref')) { return '$ref'; }\n    }\n    if (schemaType === 'array') {\n      const itemsObject = JsonPointer.getFirst([\n        [schema, '/items'],\n        [schema, '/additionalItems']\n      ]) || {};\n      return hasOwn(itemsObject, 'enum') && schema.maxItems !== 1 ?\n        checkInlineType('checkboxes', schema, layoutNode) : 'array';\n    }\n    if (schemaType === 'null') { return 'none'; }\n    if (JsonPointer.has(layoutNode, '/options/titleMap') ||\n      hasOwn(schema, 'enum') || getTitleMapFromOneOf(schema, null, true)\n    ) { return 'select'; }\n    if (schemaType === 'number' || schemaType === 'integer') {\n      return (schemaType === 'integer' || hasOwn(schema, 'multipleOf')) &&\n        hasOwn(schema, 'maximum') && hasOwn(schema, 'minimum') ? 'range' : schemaType;\n    }\n    if (schemaType === 'string') {\n      return {\n        'color': 'color',\n        'date': 'date',\n        'date-time': 'datetime-local',\n        'email': 'email',\n        'uri': 'url',\n      }[schema.format] || 'text';\n    }\n  }\n  if (hasOwn(schema, '$ref')) { return '$ref'; }\n  if (isArray(schema.oneOf) || isArray(schema.anyOf)) { return 'one-of'; }\n  console.error(`getInputType error: Unable to determine input type for ${schemaType}`);\n  console.error('schema', schema);\n  if (layoutNode) { console.error('layoutNode', layoutNode); }\n  return 'none';\n}\n\n/**\n * 'checkInlineType' function\n *\n * Checks layout and schema nodes for 'inline: true', and converts\n * 'radios' or 'checkboxes' to 'radios-inline' or 'checkboxes-inline'\n *\n * //  { string } controlType -\n * //   schema -\n * //  { any = null } layoutNode -\n * // { string }\n */\nexport function checkInlineType(controlType, schema, layoutNode: any = null) {\n  if (!isString(controlType) || (\n    controlType.slice(0, 8) !== 'checkbox' && controlType.slice(0, 5) !== 'radio'\n  )) {\n    return controlType;\n  }\n  if (\n    JsonPointer.getFirst([\n      [layoutNode, '/inline'],\n      [layoutNode, '/options/inline'],\n      [schema, '/inline'],\n      [schema, '/x-schema-form/inline'],\n      [schema, '/x-schema-form/options/inline'],\n      [schema, '/x-schema-form/widget/inline'],\n      [schema, '/x-schema-form/widget/component/inline'],\n      [schema, '/x-schema-form/widget/component/options/inline'],\n      [schema, '/widget/inline'],\n      [schema, '/widget/component/inline'],\n      [schema, '/widget/component/options/inline'],\n    ]) === true\n  ) {\n    return controlType.slice(0, 5) === 'radio' ?\n      'radios-inline' : 'checkboxes-inline';\n  } else {\n    return controlType;\n  }\n}\n\n/**\n * 'isInputRequired' function\n *\n * Checks a JSON Schema to see if an item is required\n *\n * //   schema - the schema to check\n * //  { string } schemaPointer - the pointer to the item to check\n * // { boolean } - true if the item is required, false if not\n */\nexport function isInputRequired(schema, schemaPointer) {\n  if (!isObject(schema)) {\n    console.error('isInputRequired error: Input schema must be an object.');\n    return false;\n  }\n  const listPointerArray = JsonPointer.parse(schemaPointer);\n  if (isArray(listPointerArray)) {\n    if (!listPointerArray.length) { return schema.required === true; }\n    const keyName = listPointerArray.pop();\n    const nextToLastKey = listPointerArray[listPointerArray.length - 1];\n    if (['properties', 'additionalProperties', 'patternProperties', 'items', 'additionalItems']\n      .includes(nextToLastKey)\n    ) {\n      listPointerArray.pop();\n    }\n    const parentSchema = JsonPointer.get(schema, listPointerArray) || {};\n    if (isArray(parentSchema.required)) {\n      return parentSchema.required.includes(keyName);\n    }\n    if (parentSchema.type === 'array') {\n      return hasOwn(parentSchema, 'minItems') &&\n        isNumber(keyName) &&\n        +parentSchema.minItems > +keyName;\n    }\n  }\n  return false;\n}\n\n/**\n * 'updateInputOptions' function\n *\n * //   layoutNode\n * //   schema\n * //   jsf\n * // { void }\n */\nexport function updateInputOptions(layoutNode, schema, jsf) {\n  if (!isObject(layoutNode) || !isObject(layoutNode.options)) { return; }\n\n  // Set all option values in layoutNode.options\n  const newOptions: any = { };\n  const fixUiKeys = key => key.slice(0, 3).toLowerCase() === 'ui:' ? key.slice(3) : key;\n  mergeFilteredObject(newOptions, jsf.formOptions.defautWidgetOptions, [], fixUiKeys);\n  [ [ JsonPointer.get(schema, '/ui:widget/options'), [] ],\n    [ JsonPointer.get(schema, '/ui:widget'), [] ],\n    [ schema, [\n      'additionalProperties', 'additionalItems', 'properties', 'items',\n      'required', 'type', 'x-schema-form', '$ref'\n    ] ],\n    [ JsonPointer.get(schema, '/x-schema-form/options'), [] ],\n    [ JsonPointer.get(schema, '/x-schema-form'), ['items', 'options'] ],\n    [ layoutNode, [\n      '_id', '$ref', 'arrayItem', 'arrayItemType', 'dataPointer', 'dataType',\n      'items', 'key', 'name', 'options', 'recursiveReference', 'type', 'widget'\n    ] ],\n    [ layoutNode.options, [] ],\n  ].forEach(([ object, excludeKeys ]) =>\n    mergeFilteredObject(newOptions, object, excludeKeys, fixUiKeys)\n  );\n  if (!hasOwn(newOptions, 'titleMap')) {\n    let newTitleMap: any = null;\n    newTitleMap = getTitleMapFromOneOf(schema, newOptions.flatList);\n    if (newTitleMap) { newOptions.titleMap = newTitleMap; }\n    if (!hasOwn(newOptions, 'titleMap') && !hasOwn(newOptions, 'enum') && hasOwn(schema, 'items')) {\n      if (JsonPointer.has(schema, '/items/titleMap')) {\n        newOptions.titleMap = schema.items.titleMap;\n      } else if (JsonPointer.has(schema, '/items/enum')) {\n        newOptions.enum = schema.items.enum;\n        if (!hasOwn(newOptions, 'enumNames') && JsonPointer.has(schema, '/items/enumNames')) {\n          newOptions.enumNames = schema.items.enumNames;\n        }\n      } else if (JsonPointer.has(schema, '/items/oneOf')) {\n        newTitleMap = getTitleMapFromOneOf(schema.items, newOptions.flatList);\n        if (newTitleMap) { newOptions.titleMap = newTitleMap; }\n      }\n    }\n  }\n\n  // If schema type is integer, enforce by setting multipleOf = 1\n  if (schema.type === 'integer' && !hasValue(newOptions.multipleOf)) {\n    newOptions.multipleOf = 1;\n  }\n\n  // Copy any typeahead word lists to options.typeahead.source\n  if (JsonPointer.has(newOptions, '/autocomplete/source')) {\n    newOptions.typeahead = newOptions.autocomplete;\n  } else if (JsonPointer.has(newOptions, '/tagsinput/source')) {\n    newOptions.typeahead = newOptions.tagsinput;\n  } else if (JsonPointer.has(newOptions, '/tagsinput/typeahead/source')) {\n    newOptions.typeahead = newOptions.tagsinput.typeahead;\n  }\n\n  layoutNode.options = newOptions;\n}\n\n/**\n * 'getTitleMapFromOneOf' function\n *\n * //  { schema } schema\n * //  { boolean = null } flatList\n * //  { boolean = false } validateOnly\n * // { validators }\n */\nexport function getTitleMapFromOneOf(\n  schema: any = {}, flatList: boolean = null, validateOnly = false\n) {\n  let titleMap = null;\n  const oneOf = schema.oneOf || schema.anyOf || null;\n  if (isArray(oneOf) && oneOf.every(item => item.title)) {\n    if (oneOf.every(item => isArray(item.enum) && item.enum.length === 1)) {\n      if (validateOnly) { return true; }\n      titleMap = oneOf.map(item => ({ name: item.title, value: item.enum[0] }));\n    } else if (oneOf.every(item => item.const)) {\n      if (validateOnly) { return true; }\n      titleMap = oneOf.map(item => ({ name: item.title, value: item.const }));\n    }\n\n    // if flatList !== false and some items have colons, make grouped map\n    if (flatList !== false && (titleMap || [])\n      .filter(title => ((title || {}).name || '').indexOf(': ')).length > 1\n    ) {\n\n      // Split name on first colon to create grouped map (name -> group: name)\n      const newTitleMap = titleMap.map(title => {\n        const [group, name] = title.name.split(/: (.+)/);\n        return group && name ? { ...title, group, name } : title;\n      });\n\n      // If flatList === true or at least one group has multiple items, use grouped map\n      if (flatList === true || newTitleMap.some((title, index) => index &&\n        hasOwn(title, 'group') && title.group === newTitleMap[index - 1].group\n      )) {\n        titleMap = newTitleMap;\n      }\n    }\n  }\n  return validateOnly ? false : titleMap;\n}\n\n/**\n * 'getControlValidators' function\n *\n * //  schema\n * // { validators }\n */\nexport function getControlValidators(schema) {\n  if (!isObject(schema)) { return null; }\n  const validators: any = { };\n  if (hasOwn(schema, 'type')) {\n    switch (schema.type) {\n      case 'string':\n        forEach(['pattern', 'format', 'minLength', 'maxLength'], (prop) => {\n          if (hasOwn(schema, prop)) { validators[prop] = [schema[prop]]; }\n        });\n      break;\n      case 'number': case 'integer':\n        forEach(['Minimum', 'Maximum'], (ucLimit) => {\n          const eLimit = 'exclusive' + ucLimit;\n          const limit = ucLimit.toLowerCase();\n          if (hasOwn(schema, limit)) {\n            const exclusive = hasOwn(schema, eLimit) && schema[eLimit] === true;\n            validators[limit] = [schema[limit], exclusive];\n          }\n        });\n        forEach(['multipleOf', 'type'], (prop) => {\n          if (hasOwn(schema, prop)) { validators[prop] = [schema[prop]]; }\n        });\n      break;\n      case 'object':\n        forEach(['minProperties', 'maxProperties', 'dependencies'], (prop) => {\n          if (hasOwn(schema, prop)) { validators[prop] = [schema[prop]]; }\n        });\n      break;\n      case 'array':\n        forEach(['minItems', 'maxItems', 'uniqueItems'], (prop) => {\n          if (hasOwn(schema, prop)) { validators[prop] = [schema[prop]]; }\n        });\n      break;\n    }\n  }\n  if (hasOwn(schema, 'enum')) { validators.enum = [schema.enum]; }\n  return validators;\n}\n\n/**\n * 'resolveSchemaReferences' function\n *\n * Find all $ref links in schema and save links and referenced schemas in\n * schemaRefLibrary, schemaRecursiveRefMap, and dataRecursiveRefMap\n *\n * //  schema\n * //  schemaRefLibrary\n * // { Map<string, string> } schemaRecursiveRefMap\n * // { Map<string, string> } dataRecursiveRefMap\n * // { Map<string, number> } arrayMap\n * //\n */\nexport function resolveSchemaReferences(\n  schema, schemaRefLibrary, schemaRecursiveRefMap, dataRecursiveRefMap, arrayMap\n) {\n  if (!isObject(schema)) {\n    console.error('resolveSchemaReferences error: schema must be an object.');\n    return;\n  }\n  const refLinks = new Set<string>();\n  const refMapSet = new Set<string>();\n  const refMap = new Map<string, string>();\n  const recursiveRefMap = new Map<string, string>();\n  const refLibrary: any = {};\n\n  // Search schema for all $ref links, and build full refLibrary\n  JsonPointer.forEachDeep(schema, (subSchema, subSchemaPointer) => {\n    if (hasOwn(subSchema, '$ref') && isString(subSchema['$ref'])) {\n      const refPointer = JsonPointer.compile(subSchema['$ref']);\n      refLinks.add(refPointer);\n      refMapSet.add(subSchemaPointer + '~~' + refPointer);\n      refMap.set(subSchemaPointer, refPointer);\n    }\n  });\n  refLinks.forEach(ref => refLibrary[ref] = getSubSchema(schema, ref));\n\n  // Follow all ref links and save in refMapSet,\n  // to find any multi-link recursive refernces\n  let checkRefLinks = true;\n  while (checkRefLinks) {\n    checkRefLinks = false;\n    Array.from(refMap).forEach(([fromRef1, toRef1]) => Array.from(refMap)\n      .filter(([fromRef2, toRef2]) =>\n        JsonPointer.isSubPointer(toRef1, fromRef2, true) &&\n        !JsonPointer.isSubPointer(toRef2, toRef1, true) &&\n        !refMapSet.has(fromRef1 + fromRef2.slice(toRef1.length) + '~~' + toRef2)\n      )\n      .forEach(([fromRef2, toRef2]) => {\n        refMapSet.add(fromRef1 + fromRef2.slice(toRef1.length) + '~~' + toRef2);\n        checkRefLinks = true;\n      })\n    );\n  }\n\n  // Build full recursiveRefMap\n  // First pass - save all internally recursive refs from refMapSet\n  Array.from(refMapSet)\n    .map(refLink => refLink.split('~~'))\n    .filter(([fromRef, toRef]) => JsonPointer.isSubPointer(toRef, fromRef))\n    .forEach(([fromRef, toRef]) => recursiveRefMap.set(fromRef, toRef));\n  // Second pass - create recursive versions of any other refs that link to recursive refs\n  Array.from(refMap)\n    .filter(([fromRef1, toRef1]) => Array.from(recursiveRefMap.keys())\n      .every(fromRef2 => !JsonPointer.isSubPointer(fromRef1, fromRef2, true))\n    )\n    .forEach(([fromRef1, toRef1]) => Array.from(recursiveRefMap)\n      .filter(([fromRef2, toRef2]) =>\n        !recursiveRefMap.has(fromRef1 + fromRef2.slice(toRef1.length)) &&\n        JsonPointer.isSubPointer(toRef1, fromRef2, true) &&\n        !JsonPointer.isSubPointer(toRef1, fromRef1, true)\n      )\n      .forEach(([fromRef2, toRef2]) => recursiveRefMap.set(\n        fromRef1 + fromRef2.slice(toRef1.length),\n        fromRef1 + toRef2.slice(toRef1.length)\n      ))\n    );\n\n  // Create compiled schema by replacing all non-recursive $ref links with\n  // thieir linked schemas and, where possible, combining schemas in allOf arrays.\n  let compiledSchema = { ...schema };\n  delete compiledSchema.definitions;\n  compiledSchema =\n    getSubSchema(compiledSchema, '', refLibrary, recursiveRefMap);\n\n  // Make sure all remaining schema $refs are recursive, and build final\n  // schemaRefLibrary, schemaRecursiveRefMap, dataRecursiveRefMap, & arrayMap\n  JsonPointer.forEachDeep(compiledSchema, (subSchema, subSchemaPointer) => {\n    if (isString(subSchema['$ref'])) {\n      let refPointer = JsonPointer.compile(subSchema['$ref']);\n      if (!JsonPointer.isSubPointer(refPointer, subSchemaPointer, true)) {\n        refPointer = removeRecursiveReferences(subSchemaPointer, recursiveRefMap);\n        JsonPointer.set(compiledSchema, subSchemaPointer, { $ref: `#${refPointer}` });\n      }\n      if (!hasOwn(schemaRefLibrary, 'refPointer')) {\n        schemaRefLibrary[refPointer] = !refPointer.length ? compiledSchema :\n          getSubSchema(compiledSchema, refPointer, schemaRefLibrary, recursiveRefMap);\n      }\n      if (!schemaRecursiveRefMap.has(subSchemaPointer)) {\n        schemaRecursiveRefMap.set(subSchemaPointer, refPointer);\n      }\n      const fromDataRef = JsonPointer.toDataPointer(subSchemaPointer, compiledSchema);\n      if (!dataRecursiveRefMap.has(fromDataRef)) {\n        const toDataRef = JsonPointer.toDataPointer(refPointer, compiledSchema);\n        dataRecursiveRefMap.set(fromDataRef, toDataRef);\n      }\n    }\n    if (subSchema.type === 'array' &&\n      (hasOwn(subSchema, 'items') || hasOwn(subSchema, 'additionalItems'))\n    ) {\n      const dataPointer = JsonPointer.toDataPointer(subSchemaPointer, compiledSchema);\n      if (!arrayMap.has(dataPointer)) {\n        const tupleItems = isArray(subSchema.items) ? subSchema.items.length : 0;\n        arrayMap.set(dataPointer, tupleItems);\n      }\n    }\n  }, true);\n  return compiledSchema;\n}\n\n/**\n * 'getSubSchema' function\n *\n * //   schema\n * //  { Pointer } pointer\n * //  { object } schemaRefLibrary\n * //  { Map<string, string> } schemaRecursiveRefMap\n * //  { string[] = [] } usedPointers\n * //\n */\nexport function getSubSchema(\n  schema, pointer, schemaRefLibrary = null,\n  schemaRecursiveRefMap: Map<string, string> = null, usedPointers: string[] = []\n) {\n  if (!schemaRefLibrary || !schemaRecursiveRefMap) {\n    return JsonPointer.getCopy(schema, pointer);\n  }\n  if (typeof pointer !== 'string') { pointer = JsonPointer.compile(pointer); }\n  usedPointers = [ ...usedPointers, pointer ];\n  let newSchema: any = null;\n  if (pointer === '') {\n    newSchema = cloneDeep(schema);\n  } else {\n    const shortPointer = removeRecursiveReferences(pointer, schemaRecursiveRefMap);\n    if (shortPointer !== pointer) { usedPointers = [ ...usedPointers, shortPointer ]; }\n    newSchema = JsonPointer.getFirstCopy([\n      [schemaRefLibrary, [shortPointer]],\n      [schema, pointer],\n      [schema, shortPointer]\n    ]);\n  }\n  return JsonPointer.forEachDeepCopy(newSchema, (subSchema, subPointer) => {\n    if (isObject(subSchema)) {\n\n      // Replace non-recursive $ref links with referenced schemas\n      if (isString(subSchema.$ref)) {\n        const refPointer = JsonPointer.compile(subSchema.$ref);\n        if (refPointer.length && usedPointers.every(ptr =>\n          !JsonPointer.isSubPointer(refPointer, ptr, true)\n        )) {\n          const refSchema = getSubSchema(\n            schema, refPointer, schemaRefLibrary, schemaRecursiveRefMap, usedPointers\n          );\n          if (Object.keys(subSchema).length === 1) {\n            return refSchema;\n          } else {\n            const extraKeys = { ...subSchema };\n            delete extraKeys.$ref;\n            return mergeSchemas(refSchema, extraKeys);\n          }\n        }\n      }\n\n      // TODO: Convert schemas with 'type' arrays to 'oneOf'\n\n      // Combine allOf subSchemas\n      if (isArray(subSchema.allOf)) { return combineAllOf(subSchema); }\n\n      // Fix incorrectly placed array object required lists\n      if (subSchema.type === 'array' && isArray(subSchema.required)) {\n        return fixRequiredArrayProperties(subSchema);\n      }\n    }\n    return subSchema;\n  }, true, <string>pointer);\n}\n\n/**\n * 'combineAllOf' function\n *\n * Attempt to convert an allOf schema object into\n * a non-allOf schema object with equivalent rules.\n *\n * //   schema - allOf schema object\n * //  - converted schema object\n */\nexport function combineAllOf(schema) {\n  if (!isObject(schema) || !isArray(schema.allOf)) { return schema; }\n  let mergedSchema = mergeSchemas(...schema.allOf);\n  if (Object.keys(schema).length > 1) {\n    const extraKeys = { ...schema };\n    delete extraKeys.allOf;\n    mergedSchema = mergeSchemas(mergedSchema, extraKeys);\n  }\n  return mergedSchema;\n}\n\n/**\n * 'fixRequiredArrayProperties' function\n *\n * Fixes an incorrectly placed required list inside an array schema, by moving\n * it into items.properties or additionalItems.properties, where it belongs.\n *\n * //   schema - allOf schema object\n * //  - converted schema object\n */\nexport function fixRequiredArrayProperties(schema) {\n  if (schema.type === 'array' && isArray(schema.required)) {\n    const itemsObject = hasOwn(schema.items, 'properties') ? 'items' :\n      hasOwn(schema.additionalItems, 'properties') ? 'additionalItems' : null;\n    if (itemsObject && !hasOwn(schema[itemsObject], 'required') && (\n      hasOwn(schema[itemsObject], 'additionalProperties') ||\n      schema.required.every(key => hasOwn(schema[itemsObject].properties, key))\n    )) {\n      schema = cloneDeep(schema);\n      schema[itemsObject].required = schema.required;\n      delete schema.required;\n    }\n  }\n  return schema;\n}\n","import cloneDeep from 'lodash/cloneDeep';\nimport filter from 'lodash/filter';\nimport map from 'lodash/map';\nimport {\n  AbstractControl,\n  FormArray,\n  FormControl,\n  FormGroup,\n  ValidatorFn\n} from '@angular/forms';\nimport { forEach, hasOwn } from './utility.functions';\nimport { getControlValidators, removeRecursiveReferences } from './json-schema.functions';\nimport {\n  hasValue,\n  inArray,\n  isArray,\n  isDate,\n  isDefined,\n  isEmpty,\n  isObject,\n  isPrimitive,\n  SchemaPrimitiveType,\n  toJavaScriptType,\n  toSchemaType\n} from './validator.functions';\nimport { JsonPointer, Pointer } from './jsonpointer.functions';\nimport { JsonValidators } from './json.validators';\n\n\n\n/**\n * FormGroup function library:\n *\n * buildFormGroupTemplate:  Builds a FormGroupTemplate from schema\n *\n * buildFormGroup:          Builds an Angular FormGroup from a FormGroupTemplate\n *\n * mergeValues:\n *\n * setRequiredFields:\n *\n * formatFormData:\n *\n * getControl:\n *\n * ---- TODO: ----\n * TODO: add buildFormGroupTemplateFromLayout function\n * buildFormGroupTemplateFromLayout: Builds a FormGroupTemplate from a form layout\n */\n\n/**\n * 'buildFormGroupTemplate' function\n *\n * Builds a template for an Angular FormGroup from a JSON Schema.\n *\n * TODO: add support for pattern properties\n * https://spacetelescope.github.io/understanding-json-schema/reference/object.html\n *\n * //  {any} jsf -\n * //  {any = null} nodeValue -\n * //  {boolean = true} mapArrays -\n * //  {string = ''} schemaPointer -\n * //  {string = ''} dataPointer -\n * //  {any = ''} templatePointer -\n * // {any} -\n */\nexport function buildFormGroupTemplate(\n  jsf: any, nodeValue: any = null, setValues = true,\n  schemaPointer = '', dataPointer = '', templatePointer = ''\n) {\n  const schema = JsonPointer.get(jsf.schema, schemaPointer);\n  if (setValues) {\n    if (!isDefined(nodeValue) && (\n      jsf.formOptions.setSchemaDefaults === true ||\n      (jsf.formOptions.setSchemaDefaults === 'auto' && isEmpty(jsf.formValues))\n    )) {\n      nodeValue = JsonPointer.get(jsf.schema, schemaPointer + '/default');\n    }\n  } else {\n    nodeValue = null;\n  }\n  // TODO: If nodeValue still not set, check layout for default value\n  const schemaType: string | string[] = JsonPointer.get(schema, '/type');\n  const controlType =\n    (hasOwn(schema, 'properties') || hasOwn(schema, 'additionalProperties')) &&\n      schemaType === 'object' ? 'FormGroup' :\n      (hasOwn(schema, 'items') || hasOwn(schema, 'additionalItems')) &&\n        schemaType === 'array' ? 'FormArray' :\n        !schemaType && hasOwn(schema, '$ref') ? '$ref' : 'FormControl';\n  const shortDataPointer =\n    removeRecursiveReferences(dataPointer, jsf.dataRecursiveRefMap, jsf.arrayMap);\n  if (!jsf.dataMap.has(shortDataPointer)) {\n    jsf.dataMap.set(shortDataPointer, new Map());\n  }\n  const nodeOptions = jsf.dataMap.get(shortDataPointer);\n  if (!nodeOptions.has('schemaType')) {\n    nodeOptions.set('schemaPointer', schemaPointer);\n    nodeOptions.set('schemaType', schema.type);\n    if (schema.format) {\n      nodeOptions.set('schemaFormat', schema.format);\n      if (!schema.type) { nodeOptions.set('schemaType', 'string'); }\n    }\n    if (controlType) {\n      nodeOptions.set('templatePointer', templatePointer);\n      nodeOptions.set('templateType', controlType);\n    }\n  }\n  let controls: any;\n  const validators = getControlValidators(schema);\n  switch (controlType) {\n\n    case 'FormGroup':\n      controls = {};\n      if (hasOwn(schema, 'ui:order') || hasOwn(schema, 'properties')) {\n        const propertyKeys = schema['ui:order'] || Object.keys(schema.properties);\n        if (propertyKeys.includes('*') && !hasOwn(schema.properties, '*')) {\n          const unnamedKeys = Object.keys(schema.properties)\n            .filter(key => !propertyKeys.includes(key));\n          for (let i = propertyKeys.length - 1; i >= 0; i--) {\n            if (propertyKeys[i] === '*') {\n              propertyKeys.splice(i, 1, ...unnamedKeys);\n            }\n          }\n        }\n        propertyKeys\n          .filter(key => hasOwn(schema.properties, key) ||\n            hasOwn(schema, 'additionalProperties')\n          )\n          .forEach(key => controls[key] = buildFormGroupTemplate(\n            jsf, JsonPointer.get(nodeValue, [<string>key]), setValues,\n            schemaPointer + (hasOwn(schema.properties, key) ?\n              '/properties/' + key : '/additionalProperties'\n            ),\n            dataPointer + '/' + key,\n            templatePointer + '/controls/' + key\n          ));\n        jsf.formOptions.fieldsRequired = setRequiredFields(schema, controls);\n      }\n      return { controlType, controls, validators };\n\n    case 'FormArray':\n      controls = [];\n      const minItems =\n        Math.max(schema.minItems || 0, nodeOptions.get('minItems') || 0);\n      const maxItems =\n        Math.min(schema.maxItems || 1000, nodeOptions.get('maxItems') || 1000);\n      let additionalItemsPointer: string = null;\n      if (isArray(schema.items)) { // 'items' is an array = tuple items\n        const tupleItems = nodeOptions.get('tupleItems') ||\n          (isArray(schema.items) ? Math.min(schema.items.length, maxItems) : 0);\n        for (let i = 0; i < tupleItems; i++) {\n          if (i < minItems) {\n            controls.push(buildFormGroupTemplate(\n              jsf, isArray(nodeValue) ? nodeValue[i] : nodeValue, setValues,\n              schemaPointer + '/items/' + i,\n              dataPointer + '/' + i,\n              templatePointer + '/controls/' + i\n            ));\n          } else {\n            const schemaRefPointer = removeRecursiveReferences(\n              schemaPointer + '/items/' + i, jsf.schemaRecursiveRefMap\n            );\n            const itemRefPointer = removeRecursiveReferences(\n              shortDataPointer + '/' + i, jsf.dataRecursiveRefMap, jsf.arrayMap\n            );\n            const itemRecursive = itemRefPointer !== shortDataPointer + '/' + i;\n            if (!hasOwn(jsf.templateRefLibrary, itemRefPointer)) {\n              jsf.templateRefLibrary[itemRefPointer] = null;\n              jsf.templateRefLibrary[itemRefPointer] = buildFormGroupTemplate(\n                jsf, null, setValues,\n                schemaRefPointer,\n                itemRefPointer,\n                templatePointer + '/controls/' + i\n              );\n            }\n            controls.push(\n              isArray(nodeValue) ?\n                buildFormGroupTemplate(\n                  jsf, nodeValue[i], setValues,\n                  schemaPointer + '/items/' + i,\n                  dataPointer + '/' + i,\n                  templatePointer + '/controls/' + i\n                ) :\n                itemRecursive ?\n                  null : cloneDeep(jsf.templateRefLibrary[itemRefPointer])\n            );\n          }\n        }\n\n        // If 'additionalItems' is an object = additional list items (after tuple items)\n        if (schema.items.length < maxItems && isObject(schema.additionalItems)) {\n          additionalItemsPointer = schemaPointer + '/additionalItems';\n        }\n\n        // If 'items' is an object = list items only (no tuple items)\n      } else {\n        additionalItemsPointer = schemaPointer + '/items';\n      }\n\n      if (additionalItemsPointer) {\n        const schemaRefPointer = removeRecursiveReferences(\n          additionalItemsPointer, jsf.schemaRecursiveRefMap\n        );\n        const itemRefPointer = removeRecursiveReferences(\n          shortDataPointer + '/-', jsf.dataRecursiveRefMap, jsf.arrayMap\n        );\n        const itemRecursive = itemRefPointer !== shortDataPointer + '/-';\n        if (!hasOwn(jsf.templateRefLibrary, itemRefPointer)) {\n          jsf.templateRefLibrary[itemRefPointer] = null;\n          jsf.templateRefLibrary[itemRefPointer] = buildFormGroupTemplate(\n            jsf, null, setValues,\n            schemaRefPointer,\n            itemRefPointer,\n            templatePointer + '/controls/-'\n          );\n        }\n        // const itemOptions = jsf.dataMap.get(itemRefPointer) || new Map();\n        const itemOptions = nodeOptions;\n        if (!itemRecursive || hasOwn(validators, 'required')) {\n          const arrayLength = Math.min(Math.max(\n            itemRecursive ? 0 :\n              (itemOptions.get('tupleItems') + itemOptions.get('listItems')) || 0,\n            isArray(nodeValue) ? nodeValue.length : 0\n          ), maxItems);\n          for (let i = controls.length; i < arrayLength; i++) {\n            controls.push(\n              isArray(nodeValue) ?\n                buildFormGroupTemplate(\n                  jsf, nodeValue[i], setValues,\n                  schemaRefPointer,\n                  dataPointer + '/-',\n                  templatePointer + '/controls/-'\n                ) :\n                itemRecursive ?\n                  null : cloneDeep(jsf.templateRefLibrary[itemRefPointer])\n            );\n          }\n        }\n      }\n      return { controlType, controls, validators };\n\n    case '$ref':\n      const schemaRef = JsonPointer.compile(schema.$ref);\n      const dataRef = JsonPointer.toDataPointer(schemaRef, schema);\n      const refPointer = removeRecursiveReferences(\n        dataRef, jsf.dataRecursiveRefMap, jsf.arrayMap\n      );\n      if (refPointer && !hasOwn(jsf.templateRefLibrary, refPointer)) {\n        // Set to null first to prevent recursive reference from causing endless loop\n        jsf.templateRefLibrary[refPointer] = null;\n        const newTemplate = buildFormGroupTemplate(jsf, setValues, setValues, schemaRef);\n        if (newTemplate) {\n          jsf.templateRefLibrary[refPointer] = newTemplate;\n        } else {\n          delete jsf.templateRefLibrary[refPointer];\n        }\n      }\n      return null;\n\n    case 'FormControl':\n      const value = {\n        value: setValues && isPrimitive(nodeValue) ? nodeValue : null,\n        disabled: nodeOptions.get('disabled') || false\n      };\n      return { controlType, value, validators };\n\n    default:\n      return null;\n  }\n}\n\n/**\n * 'buildFormGroup' function\n *\n * // {any} template -\n * // {AbstractControl}\n*/\nexport function buildFormGroup(template: any): AbstractControl {\n  const validatorFns: ValidatorFn[] = [];\n  let validatorFn: ValidatorFn = null;\n  if (hasOwn(template, 'validators')) {\n    forEach(template.validators, (parameters, validator) => {\n      if (typeof JsonValidators[validator] === 'function') {\n        validatorFns.push(JsonValidators[validator].apply(null, parameters));\n      }\n    });\n    if (validatorFns.length &&\n      inArray(template.controlType, ['FormGroup', 'FormArray'])\n    ) {\n      validatorFn = validatorFns.length > 1 ?\n        JsonValidators.compose(validatorFns) : validatorFns[0];\n    }\n  }\n  if (hasOwn(template, 'controlType')) {\n    switch (template.controlType) {\n      case 'FormGroup':\n        const groupControls: { [key: string]: AbstractControl } = {};\n        forEach(template.controls, (controls, key) => {\n          const newControl: AbstractControl = buildFormGroup(controls);\n          if (newControl) { groupControls[key] = newControl; }\n        });\n        return new FormGroup(groupControls, validatorFn);\n      case 'FormArray':\n        return new FormArray(filter(map(template.controls,\n          controls => buildFormGroup(controls)\n        )), validatorFn);\n      case 'FormControl':\n        return new FormControl(template.value, validatorFns);\n    }\n  }\n  return null;\n}\n\n/**\n * 'mergeValues' function\n *\n * //  {any[]} ...valuesToMerge - Multiple values to merge\n * // {any} - Merged values\n */\nexport function mergeValues(...valuesToMerge) {\n  let mergedValues: any = null;\n  for (const currentValue of valuesToMerge) {\n    if (!isEmpty(currentValue)) {\n      if (typeof currentValue === 'object' &&\n        (isEmpty(mergedValues) || typeof mergedValues !== 'object')\n      ) {\n        if (isArray(currentValue)) {\n          mergedValues = [...currentValue];\n        } else if (isObject(currentValue)) {\n          mergedValues = { ...currentValue };\n        }\n      } else if (typeof currentValue !== 'object') {\n        mergedValues = currentValue;\n      } else if (isObject(mergedValues) && isObject(currentValue)) {\n        Object.assign(mergedValues, currentValue);\n      } else if (isObject(mergedValues) && isArray(currentValue)) {\n        const newValues = [];\n        for (const value of currentValue) {\n          newValues.push(mergeValues(mergedValues, value));\n        }\n        mergedValues = newValues;\n      } else if (isArray(mergedValues) && isObject(currentValue)) {\n        const newValues = [];\n        for (const value of mergedValues) {\n          newValues.push(mergeValues(value, currentValue));\n        }\n        mergedValues = newValues;\n      } else if (isArray(mergedValues) && isArray(currentValue)) {\n        const newValues = [];\n        for (let i = 0; i < Math.max(mergedValues.length, currentValue.length); i++) {\n          if (i < mergedValues.length && i < currentValue.length) {\n            newValues.push(mergeValues(mergedValues[i], currentValue[i]));\n          } else if (i < mergedValues.length) {\n            newValues.push(mergedValues[i]);\n          } else if (i < currentValue.length) {\n            newValues.push(currentValue[i]);\n          }\n        }\n        mergedValues = newValues;\n      }\n    }\n  }\n  return mergedValues;\n}\n\n/**\n * 'setRequiredFields' function\n *\n * // {schema} schema - JSON Schema\n * // {object} formControlTemplate - Form Control Template object\n * // {boolean} - true if any fields have been set to required, false if not\n */\nexport function setRequiredFields(schema: any, formControlTemplate: any): boolean {\n  let fieldsRequired = false;\n  if (hasOwn(schema, 'required') && !isEmpty(schema.required)) {\n    fieldsRequired = true;\n    let requiredArray = isArray(schema.required) ? schema.required : [schema.required];\n    requiredArray = forEach(requiredArray,\n      key => JsonPointer.set(formControlTemplate, '/' + key + '/validators/required', [])\n    );\n  }\n  return fieldsRequired;\n\n  // TODO: Add support for patternProperties\n  // https://spacetelescope.github.io/understanding-json-schema/reference/object.html#pattern-properties\n}\n\n/**\n * 'formatFormData' function\n *\n * // {any} formData - Angular FormGroup data object\n * // {Map<string, any>} dataMap -\n * // {Map<string, string>} recursiveRefMap -\n * // {Map<string, number>} arrayMap -\n * // {boolean = false} fixErrors - if TRUE, tries to fix data\n * // {any} - formatted data object\n */\nexport function formatFormData(\n  formData: any, dataMap: Map<string, any>,\n  recursiveRefMap: Map<string, string>, arrayMap: Map<string, number>,\n  returnEmptyFields = false, fixErrors = false\n): any {\n  if (formData === null || typeof formData !== 'object') { return formData; }\n  const formattedData = isArray(formData) ? [] : {};\n  JsonPointer.forEachDeep(formData, (value, dataPointer) => {\n\n    // If returnEmptyFields === true,\n    // add empty arrays and objects to all allowed keys\n    if (returnEmptyFields && isArray(value)) {\n      JsonPointer.set(formattedData, dataPointer, []);\n    } else if (returnEmptyFields && isObject(value) && !isDate(value)) {\n      JsonPointer.set(formattedData, dataPointer, {});\n    } else {\n      const genericPointer =\n        JsonPointer.has(dataMap, [dataPointer, 'schemaType']) ? dataPointer :\n          removeRecursiveReferences(dataPointer, recursiveRefMap, arrayMap);\n      if (JsonPointer.has(dataMap, [genericPointer, 'schemaType'])) {\n        const schemaType: SchemaPrimitiveType | SchemaPrimitiveType[] =\n          dataMap.get(genericPointer).get('schemaType');\n        if (schemaType === 'null') {\n          JsonPointer.set(formattedData, dataPointer, null);\n        } else if ((hasValue(value) || returnEmptyFields) &&\n          inArray(schemaType, ['string', 'integer', 'number', 'boolean'])\n        ) {\n          const newValue = (fixErrors || (value === null && returnEmptyFields)) ?\n            toSchemaType(value, schemaType) : toJavaScriptType(value, schemaType);\n          if (isDefined(newValue) || returnEmptyFields) {\n            JsonPointer.set(formattedData, dataPointer, newValue);\n          }\n        }\n\n        // Finish incomplete 'date-time' entries\n        if (dataMap.get(genericPointer).get('schemaFormat') === 'date-time') {\n          // \"2000-03-14T01:59:26.535\" -> \"2000-03-14T01:59:26.535Z\" (add \"Z\")\n          if (/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?$/i.test(value)) {\n            JsonPointer.set(formattedData, dataPointer, `${value}Z`);\n            // \"2000-03-14T01:59\" -> \"2000-03-14T01:59:00Z\" (add \":00Z\")\n          } else if (/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d$/i.test(value)) {\n            JsonPointer.set(formattedData, dataPointer, `${value}:00Z`);\n            // \"2000-03-14\" -> \"2000-03-14T00:00:00Z\" (add \"T00:00:00Z\")\n          } else if (fixErrors && /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/i.test(value)) {\n            JsonPointer.set(formattedData, dataPointer, `${value}:00:00:00Z`);\n          }\n        }\n      } else if (typeof value !== 'object' || isDate(value) ||\n        (value === null && returnEmptyFields)\n      ) {\n        console.error('formatFormData error: ' +\n          `Schema type not found for form value at ${genericPointer}`);\n        console.error('dataMap', dataMap);\n        console.error('recursiveRefMap', recursiveRefMap);\n        console.error('genericPointer', genericPointer);\n      }\n    }\n  });\n  return formattedData;\n}\n\n/**\n * 'getControl' function\n *\n * Uses a JSON Pointer for a data object to retrieve a control from\n * an Angular formGroup or formGroup template. (Note: though a formGroup\n * template is much simpler, its basic structure is idential to a formGroup).\n *\n * If the optional third parameter 'returnGroup' is set to TRUE, the group\n * containing the control is returned, rather than the control itself.\n *\n * // {FormGroup} formGroup - Angular FormGroup to get value from\n * // {Pointer} dataPointer - JSON Pointer (string or array)\n * // {boolean = false} returnGroup - If true, return group containing control\n * // {group} - Located value (or null, if no control found)\n */\nexport function getControl(\n  formGroup: any, dataPointer: Pointer, returnGroup = false\n): any {\n  if (!isObject(formGroup) || !JsonPointer.isJsonPointer(dataPointer)) {\n    if (!JsonPointer.isJsonPointer(dataPointer)) {\n      // If dataPointer input is not a valid JSON pointer, check to\n      // see if it is instead a valid object path, using dot notaion\n      if (typeof dataPointer === 'string') {\n        const formControl = formGroup.get(dataPointer);\n        if (formControl) { return formControl; }\n      }\n      console.error(`getControl error: Invalid JSON Pointer: ${dataPointer}`);\n    }\n    if (!isObject(formGroup)) {\n      console.error(`getControl error: Invalid formGroup: ${formGroup}`);\n    }\n    return null;\n  }\n  let dataPointerArray = JsonPointer.parse(dataPointer);\n  if (returnGroup) { dataPointerArray = dataPointerArray.slice(0, -1); }\n\n  // If formGroup input is a real formGroup (not a formGroup template)\n  // try using formGroup.get() to return the control\n  if (typeof formGroup.get === 'function' &&\n    dataPointerArray.every(key => key.indexOf('.') === -1)\n  ) {\n    const formControl = formGroup.get(dataPointerArray.join('.'));\n    if (formControl) { return formControl; }\n  }\n\n  // If formGroup input is a formGroup template,\n  // or formGroup.get() failed to return the control,\n  // search the formGroup object for dataPointer's control\n  let subGroup = formGroup;\n  for (const key of dataPointerArray) {\n    if (hasOwn(subGroup, 'controls')) { subGroup = subGroup.controls; }\n    if (isArray(subGroup) && (key === '-')) {\n      subGroup = subGroup[subGroup.length - 1];\n    } else if (hasOwn(subGroup, key)) {\n      subGroup = subGroup[key];\n    } else {\n      console.error(`getControl error: Unable to find \"${key}\" item in FormGroup.`);\n      console.error(dataPointer);\n      console.error(formGroup);\n      return;\n    }\n  }\n  return subGroup;\n}\n","import uniqueId from 'lodash/uniqueId';\nimport cloneDeep from 'lodash/cloneDeep';\nimport {\n  checkInlineType,\n  getFromSchema,\n  getInputType,\n  isInputRequired,\n  removeRecursiveReferences,\n  updateInputOptions\n  } from './json-schema.functions';\nimport {\n  copy,\n  fixTitle,\n  forEach,\n  hasOwn\n  } from './utility.functions';\nimport {\n  inArray,\n  isArray,\n  isDefined,\n  isEmpty,\n  isNumber,\n  isObject,\n  isString\n  } from './validator.functions';\nimport { JsonPointer } from './jsonpointer.functions';\nimport { TitleMapItem } from '../json-schema-form.service';\n\n\n\n/**\n * Layout function library:\n *\n * buildLayout:            Builds a complete layout from an input layout and schema\n *\n * buildLayoutFromSchema:  Builds a complete layout entirely from an input schema\n *\n * mapLayout:\n *\n * getLayoutNode:\n *\n * buildTitleMap:\n */\n\n/**\n * 'buildLayout' function\n *\n * //   jsf\n * //   widgetLibrary\n * //\n */\nexport function buildLayout(jsf, widgetLibrary) {\n  let hasSubmitButton = !JsonPointer.get(jsf, '/formOptions/addSubmit');\n  const formLayout = mapLayout(jsf.layout, (layoutItem, index, layoutPointer) => {\n    const newNode: any = {\n      _id: uniqueId(),\n      options: {},\n    };\n    if (isObject(layoutItem)) {\n      Object.assign(newNode, layoutItem);\n      Object.keys(newNode)\n        .filter(option => !inArray(option, [\n          '_id', '$ref', 'arrayItem', 'arrayItemType', 'dataPointer', 'dataType',\n          'items', 'key', 'name', 'options', 'recursiveReference', 'type', 'widget'\n        ]))\n        .forEach(option => {\n          newNode.options[option] = newNode[option];\n          delete newNode[option];\n        });\n      if (!hasOwn(newNode, 'type') && isString(newNode.widget)) {\n        newNode.type = newNode.widget;\n        delete newNode.widget;\n      }\n      if (!hasOwn(newNode.options, 'title')) {\n        if (hasOwn(newNode.options, 'legend')) {\n          newNode.options.title = newNode.options.legend;\n          delete newNode.options.legend;\n        }\n      }\n      if (!hasOwn(newNode.options, 'validationMessages')) {\n        if (hasOwn(newNode.options, 'errorMessages')) {\n          newNode.options.validationMessages = newNode.options.errorMessages;\n          delete newNode.options.errorMessages;\n\n          // Convert Angular Schema Form (AngularJS) 'validationMessage' to\n          // Angular JSON Schema Form 'validationMessages'\n          // TV4 codes from https://github.com/geraintluff/tv4/blob/master/source/api.js\n        } else if (hasOwn(newNode.options, 'validationMessage')) {\n          if (typeof newNode.options.validationMessage === 'string') {\n            newNode.options.validationMessages = newNode.options.validationMessage;\n          } else {\n            newNode.options.validationMessages = {};\n            Object.keys(newNode.options.validationMessage).forEach(key => {\n              const code = key + '';\n              const newKey =\n                code === '0' ? 'type' :\n                  code === '1' ? 'enum' :\n                    code === '100' ? 'multipleOf' :\n                      code === '101' ? 'minimum' :\n                        code === '102' ? 'exclusiveMinimum' :\n                          code === '103' ? 'maximum' :\n                            code === '104' ? 'exclusiveMaximum' :\n                              code === '200' ? 'minLength' :\n                                code === '201' ? 'maxLength' :\n                                  code === '202' ? 'pattern' :\n                                    code === '300' ? 'minProperties' :\n                                      code === '301' ? 'maxProperties' :\n                                        code === '302' ? 'required' :\n                                          code === '304' ? 'dependencies' :\n                                            code === '400' ? 'minItems' :\n                                              code === '401' ? 'maxItems' :\n                                                code === '402' ? 'uniqueItems' :\n                                                  code === '500' ? 'format' : code + '';\n              newNode.options.validationMessages[newKey] = newNode.options.validationMessage[key];\n            });\n          }\n          delete newNode.options.validationMessage;\n        }\n      }\n    } else if (JsonPointer.isJsonPointer(layoutItem)) {\n      newNode.dataPointer = layoutItem;\n    } else if (isString(layoutItem)) {\n      newNode.key = layoutItem;\n    } else {\n      console.error('buildLayout error: Form layout element not recognized:');\n      console.error(layoutItem);\n      return null;\n    }\n    let nodeSchema: any = null;\n\n    // If newNode does not have a dataPointer, try to find an equivalent\n    if (!hasOwn(newNode, 'dataPointer')) {\n\n      // If newNode has a key, change it to a dataPointer\n      if (hasOwn(newNode, 'key')) {\n        newNode.dataPointer = newNode.key === '*' ? newNode.key :\n          JsonPointer.compile(JsonPointer.parseObjectPath(newNode.key), '-');\n        delete newNode.key;\n\n        // If newNode is an array, search for dataPointer in child nodes\n      } else if (hasOwn(newNode, 'type') && newNode.type.slice(-5) === 'array') {\n        const findDataPointer = (items) => {\n          if (items === null || typeof items !== 'object') { return; }\n          if (hasOwn(items, 'dataPointer')) { return items.dataPointer; }\n          if (isArray(items.items)) {\n            for (const item of items.items) {\n              if (hasOwn(item, 'dataPointer') && item.dataPointer.indexOf('/-') !== -1) {\n                return item.dataPointer;\n              }\n              if (hasOwn(item, 'items')) {\n                const searchItem = findDataPointer(item);\n                if (searchItem) { return searchItem; }\n              }\n            }\n          }\n        };\n        const childDataPointer = findDataPointer(newNode);\n        if (childDataPointer) {\n          newNode.dataPointer =\n            childDataPointer.slice(0, childDataPointer.lastIndexOf('/-'));\n        }\n      }\n    }\n\n    if (hasOwn(newNode, 'dataPointer')) {\n      if (newNode.dataPointer === '*') {\n        return buildLayoutFromSchema(jsf, widgetLibrary, jsf.formValues);\n      }\n      const nodeValue =\n        JsonPointer.get(jsf.formValues, newNode.dataPointer.replace(/\\/-/g, '/1'));\n\n      // TODO: Create function getFormValues(jsf, dataPointer, forRefLibrary)\n      // check formOptions.setSchemaDefaults and formOptions.setLayoutDefaults\n      // then set apropriate values from initialVaues, schema, or layout\n\n      newNode.dataPointer =\n        JsonPointer.toGenericPointer(newNode.dataPointer, jsf.arrayMap);\n      const LastKey = JsonPointer.toKey(newNode.dataPointer);\n      if (!newNode.name && isString(LastKey) && LastKey !== '-') {\n        newNode.name = LastKey;\n      }\n      const shortDataPointer = removeRecursiveReferences(\n        newNode.dataPointer, jsf.dataRecursiveRefMap, jsf.arrayMap\n      );\n      const recursive = !shortDataPointer.length ||\n        shortDataPointer !== newNode.dataPointer;\n      let schemaPointer: string;\n      if (!jsf.dataMap.has(shortDataPointer)) {\n        jsf.dataMap.set(shortDataPointer, new Map());\n      }\n      const nodeDataMap = jsf.dataMap.get(shortDataPointer);\n      if (nodeDataMap.has('schemaPointer')) {\n        schemaPointer = nodeDataMap.get('schemaPointer');\n      } else {\n        schemaPointer = JsonPointer.toSchemaPointer(shortDataPointer, jsf.schema);\n        nodeDataMap.set('schemaPointer', schemaPointer);\n      }\n      nodeDataMap.set('disabled', !!newNode.options.disabled);\n      nodeSchema = JsonPointer.get(jsf.schema, schemaPointer);\n      if (nodeSchema) {\n        if (!hasOwn(newNode, 'type')) {\n          newNode.type = getInputType(nodeSchema, newNode);\n        } else if (!widgetLibrary.hasWidget(newNode.type)) {\n          const oldWidgetType = newNode.type;\n          newNode.type = getInputType(nodeSchema, newNode);\n          console.error(`error: widget type \"${oldWidgetType}\" ` +\n            `not found in library. Replacing with \"${newNode.type}\".`);\n        } else {\n          newNode.type = checkInlineType(newNode.type, nodeSchema, newNode);\n        }\n        if (nodeSchema.type === 'object' && isArray(nodeSchema.required)) {\n          nodeDataMap.set('required', nodeSchema.required);\n        }\n        newNode.dataType =\n          nodeSchema.type || (hasOwn(nodeSchema, '$ref') ? '$ref' : null);\n        updateInputOptions(newNode, nodeSchema, jsf);\n\n        // Present checkboxes as single control, rather than array\n        if (newNode.type === 'checkboxes' && hasOwn(nodeSchema, 'items')) {\n          updateInputOptions(newNode, nodeSchema.items, jsf);\n        } else if (newNode.dataType === 'array') {\n          newNode.options.maxItems = Math.min(\n            nodeSchema.maxItems || 1000, newNode.options.maxItems || 1000\n          );\n          newNode.options.minItems = Math.max(\n            nodeSchema.minItems || 0, newNode.options.minItems || 0\n          );\n          newNode.options.listItems = Math.max(\n            newNode.options.listItems || 0, isArray(nodeValue) ? nodeValue.length : 0\n          );\n          newNode.options.tupleItems =\n            isArray(nodeSchema.items) ? nodeSchema.items.length : 0;\n          if (newNode.options.maxItems < newNode.options.tupleItems) {\n            newNode.options.tupleItems = newNode.options.maxItems;\n            newNode.options.listItems = 0;\n          } else if (newNode.options.maxItems <\n            newNode.options.tupleItems + newNode.options.listItems\n          ) {\n            newNode.options.listItems =\n              newNode.options.maxItems - newNode.options.tupleItems;\n          } else if (newNode.options.minItems >\n            newNode.options.tupleItems + newNode.options.listItems\n          ) {\n            newNode.options.listItems =\n              newNode.options.minItems - newNode.options.tupleItems;\n          }\n          if (!nodeDataMap.has('maxItems')) {\n            nodeDataMap.set('maxItems', newNode.options.maxItems);\n            nodeDataMap.set('minItems', newNode.options.minItems);\n            nodeDataMap.set('tupleItems', newNode.options.tupleItems);\n            nodeDataMap.set('listItems', newNode.options.listItems);\n          }\n          if (!jsf.arrayMap.has(shortDataPointer)) {\n            jsf.arrayMap.set(shortDataPointer, newNode.options.tupleItems);\n          }\n        }\n        if (isInputRequired(jsf.schema, schemaPointer)) {\n          newNode.options.required = true;\n          jsf.fieldsRequired = true;\n        }\n      } else {\n        // TODO: create item in FormGroup model from layout key (?)\n        updateInputOptions(newNode, {}, jsf);\n      }\n\n      if (!newNode.options.title && !/^\\d+$/.test(newNode.name)) {\n        newNode.options.title = fixTitle(newNode.name);\n      }\n\n      if (hasOwn(newNode.options, 'copyValueTo')) {\n        if (typeof newNode.options.copyValueTo === 'string') {\n          newNode.options.copyValueTo = [newNode.options.copyValueTo];\n        }\n        if (isArray(newNode.options.copyValueTo)) {\n          newNode.options.copyValueTo = newNode.options.copyValueTo.map(item =>\n            JsonPointer.compile(JsonPointer.parseObjectPath(item), '-')\n          );\n        }\n      }\n\n      newNode.widget = widgetLibrary.getWidget(newNode.type);\n      nodeDataMap.set('inputType', newNode.type);\n      nodeDataMap.set('widget', newNode.widget);\n\n      if (newNode.dataType === 'array' &&\n        (hasOwn(newNode, 'items') || hasOwn(newNode, 'additionalItems'))\n      ) {\n        const itemRefPointer = removeRecursiveReferences(\n          newNode.dataPointer + '/-', jsf.dataRecursiveRefMap, jsf.arrayMap\n        );\n        if (!jsf.dataMap.has(itemRefPointer)) {\n          jsf.dataMap.set(itemRefPointer, new Map());\n        }\n        jsf.dataMap.get(itemRefPointer).set('inputType', 'section');\n\n        // Fix insufficiently nested array item groups\n        if (newNode.items.length > 1) {\n          const arrayItemGroup = [];\n          for (let i = newNode.items.length - 1; i >= 0; i--) {\n            const subItem = newNode.items[i];\n            if (hasOwn(subItem, 'dataPointer') &&\n              subItem.dataPointer.slice(0, itemRefPointer.length) === itemRefPointer\n            ) {\n              const arrayItem = newNode.items.splice(i, 1)[0];\n              arrayItem.dataPointer = newNode.dataPointer + '/-' +\n                arrayItem.dataPointer.slice(itemRefPointer.length);\n              arrayItemGroup.unshift(arrayItem);\n            } else {\n              subItem.arrayItem = true;\n              // TODO: Check schema to get arrayItemType and removable\n              subItem.arrayItemType = 'list';\n              subItem.removable = newNode.options.removable !== false;\n            }\n          }\n          if (arrayItemGroup.length) {\n            newNode.items.push({\n              _id: uniqueId(),\n              arrayItem: true,\n              arrayItemType: newNode.options.tupleItems > newNode.items.length ?\n                'tuple' : 'list',\n              items: arrayItemGroup,\n              options: { removable: newNode.options.removable !== false, },\n              dataPointer: newNode.dataPointer + '/-',\n              type: 'section',\n              widget: widgetLibrary.getWidget('section'),\n            });\n          }\n        } else {\n          // TODO: Fix to hndle multiple items\n          newNode.items[0].arrayItem = true;\n          if (!newNode.items[0].dataPointer) {\n            newNode.items[0].dataPointer =\n              JsonPointer.toGenericPointer(itemRefPointer, jsf.arrayMap);\n          }\n          if (!JsonPointer.has(newNode, '/items/0/options/removable')) {\n            newNode.items[0].options.removable = true;\n          }\n          if (newNode.options.orderable === false) {\n            newNode.items[0].options.orderable = false;\n          }\n          newNode.items[0].arrayItemType =\n            newNode.options.tupleItems ? 'tuple' : 'list';\n        }\n\n        if (isArray(newNode.items)) {\n          const arrayListItems =\n            newNode.items.filter(item => item.type !== '$ref').length -\n            newNode.options.tupleItems;\n          if (arrayListItems > newNode.options.listItems) {\n            newNode.options.listItems = arrayListItems;\n            nodeDataMap.set('listItems', arrayListItems);\n          }\n        }\n\n        if (!hasOwn(jsf.layoutRefLibrary, itemRefPointer)) {\n          jsf.layoutRefLibrary[itemRefPointer] =\n            cloneDeep(newNode.items[newNode.items.length - 1]);\n          if (recursive) {\n            jsf.layoutRefLibrary[itemRefPointer].recursiveReference = true;\n          }\n          forEach(jsf.layoutRefLibrary[itemRefPointer], (item, key) => {\n            if (hasOwn(item, '_id')) { item._id = null; }\n            if (recursive) {\n              if (hasOwn(item, 'dataPointer')) {\n                item.dataPointer = item.dataPointer.slice(itemRefPointer.length);\n              }\n            }\n          }, 'top-down');\n        }\n\n        // Add any additional default items\n        if (!newNode.recursiveReference || newNode.options.required) {\n          const arrayLength = Math.min(Math.max(\n            newNode.options.tupleItems + newNode.options.listItems,\n            isArray(nodeValue) ? nodeValue.length : 0\n          ), newNode.options.maxItems);\n          for (let i = newNode.items.length; i < arrayLength; i++) {\n            newNode.items.push(getLayoutNode({\n              $ref: itemRefPointer,\n              dataPointer: newNode.dataPointer,\n              recursiveReference: newNode.recursiveReference,\n            }, jsf, widgetLibrary));\n          }\n        }\n\n        // If needed, add button to add items to array\n        if (newNode.options.addable !== false &&\n          newNode.options.minItems < newNode.options.maxItems &&\n          (newNode.items[newNode.items.length - 1] || {}).type !== '$ref'\n        ) {\n          let buttonText = 'Add';\n          if (newNode.options.title) {\n            if (/^add\\b/i.test(newNode.options.title)) {\n              buttonText = newNode.options.title;\n            } else {\n              buttonText += ' ' + newNode.options.title;\n            }\n          } else if (newNode.name && !/^\\d+$/.test(newNode.name)) {\n            if (/^add\\b/i.test(newNode.name)) {\n              buttonText += ' ' + fixTitle(newNode.name);\n            } else {\n              buttonText = fixTitle(newNode.name);\n            }\n\n            // If newNode doesn't have a title, look for title of parent array item\n          } else {\n            const parentSchema =\n              getFromSchema(jsf.schema, newNode.dataPointer, 'parentSchema');\n            if (hasOwn(parentSchema, 'title')) {\n              buttonText += ' to ' + parentSchema.title;\n            } else {\n              const pointerArray = JsonPointer.parse(newNode.dataPointer);\n              buttonText += ' to ' + fixTitle(pointerArray[pointerArray.length - 2]);\n            }\n          }\n          newNode.items.push({\n            _id: uniqueId(),\n            arrayItem: true,\n            arrayItemType: 'list',\n            dataPointer: newNode.dataPointer + '/-',\n            options: {\n              listItems: newNode.options.listItems,\n              maxItems: newNode.options.maxItems,\n              minItems: newNode.options.minItems,\n              removable: false,\n              title: buttonText,\n              tupleItems: newNode.options.tupleItems,\n            },\n            recursiveReference: recursive,\n            type: '$ref',\n            widget: widgetLibrary.getWidget('$ref'),\n            $ref: itemRefPointer,\n          });\n          if (isString(JsonPointer.get(newNode, '/style/add'))) {\n            newNode.items[newNode.items.length - 1].options.fieldStyle =\n              newNode.style.add;\n            delete newNode.style.add;\n            if (isEmpty(newNode.style)) { delete newNode.style; }\n          }\n        }\n      } else {\n        newNode.arrayItem = false;\n      }\n    } else if (hasOwn(newNode, 'type') || hasOwn(newNode, 'items')) {\n      const parentType: string =\n        JsonPointer.get(jsf.layout, layoutPointer, 0, -2).type;\n      if (!hasOwn(newNode, 'type')) {\n        newNode.type =\n          inArray(parentType, ['tabs', 'tabarray']) ? 'tab' : 'array';\n      }\n      newNode.arrayItem = parentType === 'array';\n      newNode.widget = widgetLibrary.getWidget(newNode.type);\n      updateInputOptions(newNode, {}, jsf);\n    }\n    if (newNode.type === 'submit') { hasSubmitButton = true; }\n    return newNode;\n  });\n  if (jsf.hasRootReference) {\n    const fullLayout = cloneDeep(formLayout);\n    if (fullLayout[fullLayout.length - 1].type === 'submit') { fullLayout.pop(); }\n    jsf.layoutRefLibrary[''] = {\n      _id: null,\n      dataPointer: '',\n      dataType: 'object',\n      items: fullLayout,\n      name: '',\n      options: cloneDeep(jsf.formOptions.defautWidgetOptions),\n      recursiveReference: true,\n      required: false,\n      type: 'section',\n      widget: widgetLibrary.getWidget('section'),\n    };\n  }\n  if (!hasSubmitButton) {\n    formLayout.push({\n      _id: uniqueId(),\n      options: { title: 'Submit' },\n      type: 'submit',\n      widget: widgetLibrary.getWidget('submit'),\n    });\n  }\n  return formLayout;\n}\n\n/**\n * 'buildLayoutFromSchema' function\n *\n * //   jsf -\n * //   widgetLibrary -\n * //   nodeValue -\n * //  { string = '' } schemaPointer -\n * //  { string = '' } dataPointer -\n * //  { boolean = false } arrayItem -\n * //  { string = null } arrayItemType -\n * //  { boolean = null } removable -\n * //  { boolean = false } forRefLibrary -\n * //  { string = '' } dataPointerPrefix -\n * //\n */\nexport function buildLayoutFromSchema(\n  jsf, widgetLibrary, nodeValue = null, schemaPointer = '',\n  dataPointer = '', arrayItem = false, arrayItemType: string = null,\n  removable: boolean = null, forRefLibrary = false, dataPointerPrefix = ''\n) {\n  const schema = JsonPointer.get(jsf.schema, schemaPointer);\n  if (!hasOwn(schema, 'type') && !hasOwn(schema, '$ref') &&\n    !hasOwn(schema, 'x-schema-form')\n  ) { return null; }\n  const newNodeType: string = getInputType(schema);\n  if (!isDefined(nodeValue) && (\n    jsf.formOptions.setSchemaDefaults === true ||\n    (jsf.formOptions.setSchemaDefaults === 'auto' && isEmpty(jsf.formValues))\n  )) {\n    nodeValue = JsonPointer.get(jsf.schema, schemaPointer + '/default');\n  }\n  let newNode: any = {\n    _id: forRefLibrary ? null : uniqueId(),\n    arrayItem: arrayItem,\n    dataPointer: JsonPointer.toGenericPointer(dataPointer, jsf.arrayMap),\n    dataType: schema.type || (hasOwn(schema, '$ref') ? '$ref' : null),\n    options: {},\n    required: isInputRequired(jsf.schema, schemaPointer),\n    type: newNodeType,\n    widget: widgetLibrary.getWidget(newNodeType),\n  };\n  const lastDataKey = JsonPointer.toKey(newNode.dataPointer);\n  if (lastDataKey !== '-') { newNode.name = lastDataKey; }\n  if (newNode.arrayItem) {\n    newNode.arrayItemType = arrayItemType;\n    newNode.options.removable = removable !== false;\n  }\n  const shortDataPointer = removeRecursiveReferences(\n    dataPointerPrefix + dataPointer, jsf.dataRecursiveRefMap, jsf.arrayMap\n  );\n  const recursive = !shortDataPointer.length ||\n    shortDataPointer !== dataPointerPrefix + dataPointer;\n  if (!jsf.dataMap.has(shortDataPointer)) {\n    jsf.dataMap.set(shortDataPointer, new Map());\n  }\n  const nodeDataMap = jsf.dataMap.get(shortDataPointer);\n  if (!nodeDataMap.has('inputType')) {\n    nodeDataMap.set('schemaPointer', schemaPointer);\n    nodeDataMap.set('inputType', newNode.type);\n    nodeDataMap.set('widget', newNode.widget);\n    nodeDataMap.set('disabled', !!newNode.options.disabled);\n  }\n  updateInputOptions(newNode, schema, jsf);\n  if (!newNode.options.title && newNode.name && !/^\\d+$/.test(newNode.name)) {\n    newNode.options.title = fixTitle(newNode.name);\n  }\n\n  if (newNode.dataType === 'object') {\n    if (isArray(schema.required) && !nodeDataMap.has('required')) {\n      nodeDataMap.set('required', schema.required);\n    }\n    if (isObject(schema.properties)) {\n      const newSection: any[] = [];\n      const propertyKeys = schema['ui:order'] || Object.keys(schema.properties);\n      if (propertyKeys.includes('*') && !hasOwn(schema.properties, '*')) {\n        const unnamedKeys = Object.keys(schema.properties)\n          .filter(key => !propertyKeys.includes(key));\n        for (let i = propertyKeys.length - 1; i >= 0; i--) {\n          if (propertyKeys[i] === '*') {\n            propertyKeys.splice(i, 1, ...unnamedKeys);\n          }\n        }\n      }\n      propertyKeys\n        .filter(key => hasOwn(schema.properties, key) ||\n          hasOwn(schema, 'additionalProperties')\n        )\n        .forEach(key => {\n          const keySchemaPointer = hasOwn(schema.properties, key) ?\n            '/properties/' + key : '/additionalProperties';\n          const innerItem = buildLayoutFromSchema(\n            jsf, widgetLibrary, isObject(nodeValue) ? nodeValue[key] : null,\n            schemaPointer + keySchemaPointer,\n            dataPointer + '/' + key,\n            false, null, null, forRefLibrary, dataPointerPrefix\n          );\n          if (innerItem) {\n            if (isInputRequired(schema, '/' + key)) {\n              innerItem.options.required = true;\n              jsf.fieldsRequired = true;\n            }\n            newSection.push(innerItem);\n          }\n        });\n      if (dataPointer === '' && !forRefLibrary) {\n        newNode = newSection;\n      } else {\n        newNode.items = newSection;\n      }\n    }\n    // TODO: Add patternProperties and additionalProperties inputs?\n    // ... possibly provide a way to enter both key names and values?\n    // if (isObject(schema.patternProperties)) { }\n    // if (isObject(schema.additionalProperties)) { }\n\n  } else if (newNode.dataType === 'array') {\n    newNode.items = [];\n    newNode.options.maxItems = Math.min(\n      schema.maxItems || 1000, newNode.options.maxItems || 1000\n    );\n    newNode.options.minItems = Math.max(\n      schema.minItems || 0, newNode.options.minItems || 0\n    );\n    if (!newNode.options.minItems && isInputRequired(jsf.schema, schemaPointer)) {\n      newNode.options.minItems = 1;\n    }\n    if (!hasOwn(newNode.options, 'listItems')) { newNode.options.listItems = 1; }\n    newNode.options.tupleItems = isArray(schema.items) ? schema.items.length : 0;\n    if (newNode.options.maxItems <= newNode.options.tupleItems) {\n      newNode.options.tupleItems = newNode.options.maxItems;\n      newNode.options.listItems = 0;\n    } else if (newNode.options.maxItems <\n      newNode.options.tupleItems + newNode.options.listItems\n    ) {\n      newNode.options.listItems = newNode.options.maxItems - newNode.options.tupleItems;\n    } else if (newNode.options.minItems >\n      newNode.options.tupleItems + newNode.options.listItems\n    ) {\n      newNode.options.listItems = newNode.options.minItems - newNode.options.tupleItems;\n    }\n    if (!nodeDataMap.has('maxItems')) {\n      nodeDataMap.set('maxItems', newNode.options.maxItems);\n      nodeDataMap.set('minItems', newNode.options.minItems);\n      nodeDataMap.set('tupleItems', newNode.options.tupleItems);\n      nodeDataMap.set('listItems', newNode.options.listItems);\n    }\n    if (!jsf.arrayMap.has(shortDataPointer)) {\n      jsf.arrayMap.set(shortDataPointer, newNode.options.tupleItems);\n    }\n    removable = newNode.options.removable !== false;\n    let additionalItemsSchemaPointer: string = null;\n\n    // If 'items' is an array = tuple items\n    if (isArray(schema.items)) {\n      newNode.items = [];\n      for (let i = 0; i < newNode.options.tupleItems; i++) {\n        let newItem: any;\n        const itemRefPointer = removeRecursiveReferences(\n          shortDataPointer + '/' + i, jsf.dataRecursiveRefMap, jsf.arrayMap\n        );\n        const itemRecursive = !itemRefPointer.length ||\n          itemRefPointer !== shortDataPointer + '/' + i;\n\n        // If removable, add tuple item layout to layoutRefLibrary\n        if (removable && i >= newNode.options.minItems) {\n          if (!hasOwn(jsf.layoutRefLibrary, itemRefPointer)) {\n            // Set to null first to prevent recursive reference from causing endless loop\n            jsf.layoutRefLibrary[itemRefPointer] = null;\n            jsf.layoutRefLibrary[itemRefPointer] = buildLayoutFromSchema(\n              jsf, widgetLibrary, isArray(nodeValue) ? nodeValue[i] : null,\n              schemaPointer + '/items/' + i,\n              itemRecursive ? '' : dataPointer + '/' + i,\n              true, 'tuple', true, true, itemRecursive ? dataPointer + '/' + i : ''\n            );\n            if (itemRecursive) {\n              jsf.layoutRefLibrary[itemRefPointer].recursiveReference = true;\n            }\n          }\n          newItem = getLayoutNode({\n            $ref: itemRefPointer,\n            dataPointer: dataPointer + '/' + i,\n            recursiveReference: itemRecursive,\n          }, jsf, widgetLibrary, isArray(nodeValue) ? nodeValue[i] : null);\n        } else {\n          newItem = buildLayoutFromSchema(\n            jsf, widgetLibrary, isArray(nodeValue) ? nodeValue[i] : null,\n            schemaPointer + '/items/' + i,\n            dataPointer + '/' + i,\n            true, 'tuple', false, forRefLibrary, dataPointerPrefix\n          );\n        }\n        if (newItem) { newNode.items.push(newItem); }\n      }\n\n      // If 'additionalItems' is an object = additional list items, after tuple items\n      if (isObject(schema.additionalItems)) {\n        additionalItemsSchemaPointer = schemaPointer + '/additionalItems';\n      }\n\n      // If 'items' is an object = list items only (no tuple items)\n    } else if (isObject(schema.items)) {\n      additionalItemsSchemaPointer = schemaPointer + '/items';\n    }\n\n    if (additionalItemsSchemaPointer) {\n      const itemRefPointer = removeRecursiveReferences(\n        shortDataPointer + '/-', jsf.dataRecursiveRefMap, jsf.arrayMap\n      );\n      const itemRecursive = !itemRefPointer.length ||\n        itemRefPointer !== shortDataPointer + '/-';\n      const itemSchemaPointer = removeRecursiveReferences(\n        additionalItemsSchemaPointer, jsf.schemaRecursiveRefMap, jsf.arrayMap\n      );\n      // Add list item layout to layoutRefLibrary\n      if (itemRefPointer.length && !hasOwn(jsf.layoutRefLibrary, itemRefPointer)) {\n        // Set to null first to prevent recursive reference from causing endless loop\n        jsf.layoutRefLibrary[itemRefPointer] = null;\n        jsf.layoutRefLibrary[itemRefPointer] = buildLayoutFromSchema(\n          jsf, widgetLibrary, null,\n          itemSchemaPointer,\n          itemRecursive ? '' : dataPointer + '/-',\n          true, 'list', removable, true, itemRecursive ? dataPointer + '/-' : ''\n        );\n        if (itemRecursive) {\n          jsf.layoutRefLibrary[itemRefPointer].recursiveReference = true;\n        }\n      }\n\n      // Add any additional default items\n      if (!itemRecursive || newNode.options.required) {\n        const arrayLength = Math.min(Math.max(\n          itemRecursive ? 0 :\n            newNode.options.tupleItems + newNode.options.listItems,\n          isArray(nodeValue) ? nodeValue.length : 0\n        ), newNode.options.maxItems);\n        if (newNode.items.length < arrayLength) {\n          for (let i = newNode.items.length; i < arrayLength; i++) {\n            newNode.items.push(getLayoutNode({\n              $ref: itemRefPointer,\n              dataPointer: dataPointer + '/-',\n              recursiveReference: itemRecursive,\n            }, jsf, widgetLibrary, isArray(nodeValue) ? nodeValue[i] : null));\n          }\n        }\n      }\n\n      // If needed, add button to add items to array\n      if (newNode.options.addable !== false &&\n        newNode.options.minItems < newNode.options.maxItems &&\n        (newNode.items[newNode.items.length - 1] || {}).type !== '$ref'\n      ) {\n        let buttonText =\n          ((jsf.layoutRefLibrary[itemRefPointer] || {}).options || {}).title;\n        const prefix = buttonText ? 'Add ' : 'Add to ';\n        if (!buttonText) {\n          buttonText = schema.title || fixTitle(JsonPointer.toKey(dataPointer));\n        }\n        if (!/^add\\b/i.test(buttonText)) { buttonText = prefix + buttonText; }\n        newNode.items.push({\n          _id: uniqueId(),\n          arrayItem: true,\n          arrayItemType: 'list',\n          dataPointer: newNode.dataPointer + '/-',\n          options: {\n            listItems: newNode.options.listItems,\n            maxItems: newNode.options.maxItems,\n            minItems: newNode.options.minItems,\n            removable: false,\n            title: buttonText,\n            tupleItems: newNode.options.tupleItems,\n          },\n          recursiveReference: itemRecursive,\n          type: '$ref',\n          widget: widgetLibrary.getWidget('$ref'),\n          $ref: itemRefPointer,\n        });\n      }\n    }\n\n  } else if (newNode.dataType === '$ref') {\n    const schemaRef = JsonPointer.compile(schema.$ref);\n    const dataRef = JsonPointer.toDataPointer(schemaRef, jsf.schema);\n    let buttonText = '';\n\n    // Get newNode title\n    if (newNode.options.add) {\n      buttonText = newNode.options.add;\n    } else if (newNode.name && !/^\\d+$/.test(newNode.name)) {\n      buttonText =\n        (/^add\\b/i.test(newNode.name) ? '' : 'Add ') + fixTitle(newNode.name);\n\n      // If newNode doesn't have a title, look for title of parent array item\n    } else {\n      const parentSchema =\n        JsonPointer.get(jsf.schema, schemaPointer, 0, -1);\n      if (hasOwn(parentSchema, 'title')) {\n        buttonText = 'Add to ' + parentSchema.title;\n      } else {\n        const pointerArray = JsonPointer.parse(newNode.dataPointer);\n        buttonText = 'Add to ' + fixTitle(pointerArray[pointerArray.length - 2]);\n      }\n    }\n    Object.assign(newNode, {\n      recursiveReference: true,\n      widget: widgetLibrary.getWidget('$ref'),\n      $ref: dataRef,\n    });\n    Object.assign(newNode.options, {\n      removable: false,\n      title: buttonText,\n    });\n    if (isNumber(JsonPointer.get(jsf.schema, schemaPointer, 0, -1).maxItems)) {\n      newNode.options.maxItems =\n        JsonPointer.get(jsf.schema, schemaPointer, 0, -1).maxItems;\n    }\n\n    // Add layout template to layoutRefLibrary\n    if (dataRef.length) {\n      if (!hasOwn(jsf.layoutRefLibrary, dataRef)) {\n        // Set to null first to prevent recursive reference from causing endless loop\n        jsf.layoutRefLibrary[dataRef] = null;\n        const newLayout = buildLayoutFromSchema(\n          jsf, widgetLibrary, null, schemaRef, '',\n          newNode.arrayItem, newNode.arrayItemType, true, true, dataPointer\n        );\n        if (newLayout) {\n          newLayout.recursiveReference = true;\n          jsf.layoutRefLibrary[dataRef] = newLayout;\n        } else {\n          delete jsf.layoutRefLibrary[dataRef];\n        }\n      } else if (!jsf.layoutRefLibrary[dataRef].recursiveReference) {\n        jsf.layoutRefLibrary[dataRef].recursiveReference = true;\n      }\n    }\n  }\n  return newNode;\n}\n\n/**\n * 'mapLayout' function\n *\n * Creates a new layout by running each element in an existing layout through\n * an iteratee. Recursively maps within array elements 'items' and 'tabs'.\n * The iteratee is invoked with four arguments: (value, index, layout, path)\n *\n * The returned layout may be longer (or shorter) then the source layout.\n *\n * If an item from the source layout returns multiple items (as '*' usually will),\n * this function will keep all returned items in-line with the surrounding items.\n *\n * If an item from the source layout causes an error and returns null, it is\n * skipped without error, and the function will still return all non-null items.\n *\n * //   layout - the layout to map\n * //  { (v: any, i?: number, l?: any, p?: string) => any }\n *   function - the funciton to invoke on each element\n * //  { string|string[] = '' } layoutPointer - the layoutPointer to layout, inside rootLayout\n * //  { any[] = layout } rootLayout - the root layout, which conatins layout\n * //\n */\nexport function mapLayout(layout, fn, layoutPointer = '', rootLayout = layout) {\n  let indexPad = 0;\n  let newLayout: any[] = [];\n  forEach(layout, (item, index) => {\n    const realIndex = +index + indexPad;\n    const newLayoutPointer = layoutPointer + '/' + realIndex;\n    let newNode: any = copy(item);\n    let itemsArray: any[] = [];\n    if (isObject(item)) {\n      if (hasOwn(item, 'tabs')) {\n        item.items = item.tabs;\n        delete item.tabs;\n      }\n      if (hasOwn(item, 'items')) {\n        itemsArray = isArray(item.items) ? item.items : [item.items];\n      }\n    }\n    if (itemsArray.length) {\n      newNode.items = mapLayout(itemsArray, fn, newLayoutPointer + '/items', rootLayout);\n    }\n    newNode = fn(newNode, realIndex, newLayoutPointer, rootLayout);\n    if (!isDefined(newNode)) {\n      indexPad--;\n    } else {\n      if (isArray(newNode)) { indexPad += newNode.length - 1; }\n      newLayout = newLayout.concat(newNode);\n    }\n  });\n  return newLayout;\n}\n\n/**\n * 'getLayoutNode' function\n * Copy a new layoutNode from layoutRefLibrary\n *\n * //   refNode -\n * //   layoutRefLibrary -\n * //  { any = null } widgetLibrary -\n * //  { any = null } nodeValue -\n * //  copied layoutNode\n */\nexport function getLayoutNode(\n  refNode, jsf, widgetLibrary: any = null, nodeValue: any = null\n) {\n\n  // If recursive reference and building initial layout, return Add button\n  if (refNode.recursiveReference && widgetLibrary) {\n    const newLayoutNode = cloneDeep(refNode);\n    if (!newLayoutNode.options) { newLayoutNode.options = {}; }\n    Object.assign(newLayoutNode, {\n      recursiveReference: true,\n      widget: widgetLibrary.getWidget('$ref'),\n    });\n    Object.assign(newLayoutNode.options, {\n      removable: false,\n      title: 'Add ' + newLayoutNode.$ref,\n    });\n    return newLayoutNode;\n\n    // Otherwise, return referenced layout\n  } else {\n    let newLayoutNode = jsf.layoutRefLibrary[refNode.$ref];\n    // If value defined, build new node from schema (to set array lengths)\n    if (isDefined(nodeValue)) {\n      newLayoutNode = buildLayoutFromSchema(\n        jsf, widgetLibrary, nodeValue,\n        JsonPointer.toSchemaPointer(refNode.$ref, jsf.schema),\n        refNode.$ref, newLayoutNode.arrayItem,\n        newLayoutNode.arrayItemType, newLayoutNode.options.removable, false\n      );\n    } else {\n      // If value not defined, copy node from layoutRefLibrary\n      newLayoutNode = cloneDeep(newLayoutNode);\n      JsonPointer.forEachDeep(newLayoutNode, (subNode, pointer) => {\n\n        // Reset all _id's in newLayoutNode to unique values\n        if (hasOwn(subNode, '_id')) { subNode._id = uniqueId(); }\n\n        // If adding a recursive item, prefix current dataPointer\n        // to all dataPointers in new layoutNode\n        if (refNode.recursiveReference && hasOwn(subNode, 'dataPointer')) {\n          subNode.dataPointer = refNode.dataPointer + subNode.dataPointer;\n        }\n      });\n    }\n    return newLayoutNode;\n  }\n}\n\n/**\n * 'buildTitleMap' function\n *\n * //   titleMap -\n * //   enumList -\n * //  { boolean = true } fieldRequired -\n * //  { boolean = true } flatList -\n * // { TitleMapItem[] }\n */\nexport function buildTitleMap(\n  titleMap, enumList, fieldRequired = true, flatList = true\n) {\n  let newTitleMap: TitleMapItem[] = [];\n  let hasEmptyValue = false;\n  if (titleMap) {\n    if (isArray(titleMap)) {\n      if (enumList) {\n        for (const i of Object.keys(titleMap)) {\n          if (isObject(titleMap[i])) { // JSON Form style\n            const value = titleMap[i].value;\n            if (enumList.includes(value)) {\n              const name = titleMap[i].name;\n              newTitleMap.push({ name, value });\n              if (value === undefined || value === null) { hasEmptyValue = true; }\n            }\n          } else if (isString(titleMap[i])) { // React Jsonschema Form style\n            if (i < enumList.length) {\n              const name = titleMap[i];\n              const value = enumList[i];\n              newTitleMap.push({ name, value });\n              if (value === undefined || value === null) { hasEmptyValue = true; }\n            }\n          }\n        }\n      } else { // If array titleMap and no enum list, just return the titleMap - Angular Schema Form style\n        newTitleMap = titleMap;\n        if (!fieldRequired) {\n          hasEmptyValue = !!newTitleMap\n            .filter(i => i.value === undefined || i.value === null)\n            .length;\n        }\n      }\n    } else if (enumList) { // Alternate JSON Form style, with enum list\n      for (const i of Object.keys(enumList)) {\n        const value = enumList[i];\n        if (hasOwn(titleMap, value)) {\n          const name = titleMap[value];\n          newTitleMap.push({ name, value });\n          if (value === undefined || value === null) { hasEmptyValue = true; }\n        }\n      }\n    } else { // Alternate JSON Form style, without enum list\n      for (const value of Object.keys(titleMap)) {\n        const name = titleMap[value];\n        newTitleMap.push({ name, value });\n        if (value === undefined || value === null) { hasEmptyValue = true; }\n      }\n    }\n  } else if (enumList) { // Build map from enum list alone\n    for (const i of Object.keys(enumList)) {\n      const name = enumList[i];\n      const value = enumList[i];\n      newTitleMap.push({ name, value });\n      if (value === undefined || value === null) { hasEmptyValue = true; }\n    }\n  } else { // If no titleMap and no enum list, return default map of boolean values\n    newTitleMap = [{ name: 'True', value: true }, { name: 'False', value: false }];\n  }\n\n  // Does titleMap have groups?\n  if (newTitleMap.some(title => hasOwn(title, 'group'))) {\n    hasEmptyValue = false;\n\n    // If flatList = true, flatten items & update name to group: name\n    if (flatList) {\n      newTitleMap = newTitleMap.reduce((groupTitleMap, title) => {\n        if (hasOwn(title, 'group')) {\n          if (isArray(title.items)) {\n            groupTitleMap = [\n              ...groupTitleMap,\n              ...title.items.map(item =>\n                ({ ...item, ...{ name: `${title.group}: ${item.name}` } })\n              )\n            ];\n            if (title.items.some(item => item.value === undefined || item.value === null)) {\n              hasEmptyValue = true;\n            }\n          }\n          if (hasOwn(title, 'name') && hasOwn(title, 'value')) {\n            title.name = `${title.group}: ${title.name}`;\n            delete title.group;\n            groupTitleMap.push(title);\n            if (title.value === undefined || title.value === null) {\n              hasEmptyValue = true;\n            }\n          }\n        } else {\n          groupTitleMap.push(title);\n          if (title.value === undefined || title.value === null) {\n            hasEmptyValue = true;\n          }\n        }\n        return groupTitleMap;\n      }, []);\n\n      // If flatList = false, combine items from matching groups\n    } else {\n      newTitleMap = newTitleMap.reduce((groupTitleMap, title) => {\n        if (hasOwn(title, 'group')) {\n          if (title.group !== (groupTitleMap[groupTitleMap.length - 1] || {}).group) {\n            groupTitleMap.push({ group: title.group, items: title.items || [] });\n          }\n          if (hasOwn(title, 'name') && hasOwn(title, 'value')) {\n            groupTitleMap[groupTitleMap.length - 1].items\n              .push({ name: title.name, value: title.value });\n            if (title.value === undefined || title.value === null) {\n              hasEmptyValue = true;\n            }\n          }\n        } else {\n          groupTitleMap.push(title);\n          if (title.value === undefined || title.value === null) {\n            hasEmptyValue = true;\n          }\n        }\n        return groupTitleMap;\n      }, []);\n    }\n  }\n  if (!fieldRequired && !hasEmptyValue) {\n    newTitleMap.unshift({ name: '<em>None</em>', value: null });\n  }\n  return newTitleMap;\n}\n","export const longMonths = ['January', 'February', 'March', 'April', 'May', 'June',\n    'July', 'August', 'September', 'October', 'November', 'December'];\nexport const longDays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\nexport const shortMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\nexport const shortDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n","export const deValidationMessages: any = { // Default German error messages\n  required: 'Darf nicht leer sein',\n  minLength: 'Mindestens {{minimumLength}} Zeichen benötigt (aktuell: {{currentLength}})',\n  maxLength: 'Maximal {{maximumLength}} Zeichen erlaubt (aktuell: {{currentLength}})',\n  pattern: 'Entspricht nicht diesem regulären Ausdruck: {{requiredPattern}}',\n  format: function (error) {\n    switch (error.requiredFormat) {\n      case 'date':\n        return 'Muss ein Datum sein, z. B. \"2000-12-31\"';\n      case 'time':\n        return 'Muss eine Zeitangabe sein, z. B. \"16:20\" oder \"03:14:15.9265\"';\n      case 'date-time':\n        return 'Muss Datum mit Zeit beinhalten, z. B. \"2000-03-14T01:59\" oder \"2000-03-14T01:59:26.535Z\"';\n      case 'email':\n        return 'Keine gültige E-Mail-Adresse (z. B. \"name@example.com\")';\n      case 'hostname':\n        return 'Kein gültiger Hostname (z. B. \"example.com\")';\n      case 'ipv4':\n        return 'Keine gültige IPv4-Adresse (z. B. \"127.0.0.1\")';\n      case 'ipv6':\n        return 'Keine gültige IPv6-Adresse (z. B. \"1234:5678:9ABC:DEF0:1234:5678:9ABC:DEF0\")';\n      // TODO: add examples for 'uri', 'uri-reference', and 'uri-template'\n      // case 'uri': case 'uri-reference': case 'uri-template':\n      case 'url':\n        return 'Keine gültige URL (z. B. \"http://www.example.com/page.html\")';\n      case 'uuid':\n        return 'Keine gültige UUID (z. B. \"12345678-9ABC-DEF0-1234-56789ABCDEF0\")';\n      case 'color':\n        return 'Kein gültiger Farbwert (z. B. \"#FFFFFF\" oder \"rgb(255, 255, 255)\")';\n      case 'json-pointer':\n        return 'Kein gültiger JSON-Pointer (z. B. \"/pointer/to/something\")';\n      case 'relative-json-pointer':\n        return 'Kein gültiger relativer JSON-Pointer (z. B. \"2/pointer/to/something\")';\n      case 'regex':\n        return 'Kein gültiger regulärer Ausdruck (z. B. \"(1-)?\\\\d{3}-\\\\d{3}-\\\\d{4}\")';\n      default:\n        return 'Muss diesem Format entsprechen: ' + error.requiredFormat;\n    }\n  },\n  minimum: 'Muss mindestens {{minimumValue}} sein',\n  exclusiveMinimum: 'Muss größer als {{exclusiveMinimumValue}} sein',\n  maximum: 'Darf maximal {{maximumValue}} sein',\n  exclusiveMaximum: 'Muss kleiner als {{exclusiveMaximumValue}} sein',\n  multipleOf: function (error) {\n    if ((1 / error.multipleOfValue) % 10 === 0) {\n      const decimals = Math.log10(1 / error.multipleOfValue);\n      return `Maximal ${decimals} Dezimalstellen erlaubt`;\n    } else {\n      return `Muss ein Vielfaches von ${error.multipleOfValue} sein`;\n    }\n  },\n  minProperties: 'Mindestens {{minimumProperties}} Attribute erforderlich (aktuell: {{currentProperties}})',\n  maxProperties: 'Maximal {{maximumProperties}} Attribute erlaubt (aktuell: {{currentProperties}})',\n  minItems: 'Mindestens {{minimumItems}} Werte erforderlich (aktuell: {{currentItems}})',\n  maxItems: 'Maximal {{maximumItems}} Werte erlaubt (aktuell: {{currentItems}})',\n  uniqueItems: 'Alle Werte müssen eindeutig sein',\n  // Note: No default error messages for 'type', 'const', 'enum', or 'dependencies'\n};\n","export const enValidationMessages: any = { // Default English error messages\n  required: 'This field is required.',\n  minLength: 'Must be {{minimumLength}} characters or longer (current length: {{currentLength}})',\n  maxLength: 'Must be {{maximumLength}} characters or shorter (current length: {{currentLength}})',\n  pattern: 'Must match pattern: {{requiredPattern}}',\n  format: function (error) {\n    switch (error.requiredFormat) {\n      case 'date':\n        return 'Must be a date, like \"2000-12-31\"';\n      case 'time':\n        return 'Must be a time, like \"16:20\" or \"03:14:15.9265\"';\n      case 'date-time':\n        return 'Must be a date-time, like \"2000-03-14T01:59\" or \"2000-03-14T01:59:26.535Z\"';\n      case 'email':\n        return 'Must be an email address, like \"name@example.com\"';\n      case 'hostname':\n        return 'Must be a hostname, like \"example.com\"';\n      case 'ipv4':\n        return 'Must be an IPv4 address, like \"127.0.0.1\"';\n      case 'ipv6':\n        return 'Must be an IPv6 address, like \"1234:5678:9ABC:DEF0:1234:5678:9ABC:DEF0\"';\n      // TODO: add examples for 'uri', 'uri-reference', and 'uri-template'\n      // case 'uri': case 'uri-reference': case 'uri-template':\n      case 'url':\n        return 'Must be a url, like \"http://www.example.com/page.html\"';\n      case 'uuid':\n        return 'Must be a uuid, like \"12345678-9ABC-DEF0-1234-56789ABCDEF0\"';\n      case 'color':\n        return 'Must be a color, like \"#FFFFFF\" or \"rgb(255, 255, 255)\"';\n      case 'json-pointer':\n        return 'Must be a JSON Pointer, like \"/pointer/to/something\"';\n      case 'relative-json-pointer':\n        return 'Must be a relative JSON Pointer, like \"2/pointer/to/something\"';\n      case 'regex':\n        return 'Must be a regular expression, like \"(1-)?\\\\d{3}-\\\\d{3}-\\\\d{4}\"';\n      default:\n        return 'Must be a correctly formatted ' + error.requiredFormat;\n    }\n  },\n  minimum: 'Must be {{minimumValue}} or more',\n  exclusiveMinimum: 'Must be more than {{exclusiveMinimumValue}}',\n  maximum: 'Must be {{maximumValue}} or less',\n  exclusiveMaximum: 'Must be less than {{exclusiveMaximumValue}}',\n  multipleOf: function (error) {\n    if ((1 / error.multipleOfValue) % 10 === 0) {\n      const decimals = Math.log10(1 / error.multipleOfValue);\n      return `Must have ${decimals} or fewer decimal places.`;\n    } else {\n      return `Must be a multiple of ${error.multipleOfValue}.`;\n    }\n  },\n  minProperties: 'Must have {{minimumProperties}} or more items (current items: {{currentProperties}})',\n  maxProperties: 'Must have {{maximumProperties}} or fewer items (current items: {{currentProperties}})',\n  minItems: 'Must have {{minimumItems}} or more items (current items: {{currentItems}})',\n  maxItems: 'Must have {{maximumItems}} or fewer items (current items: {{currentItems}})',\n  uniqueItems: 'All items must be unique',\n  // Note: No default error messages for 'type', 'const', 'enum', or 'dependencies'\n};\n","export const esValidationMessages: any = { // Default Spanish error messages\n  required: 'Este campo está requerido.',\n  minLength: 'Debe tener {{minimumLength}} caracteres o más longitud (longitud actual: {{currentLength}})',\n  maxLength: 'Debe tener {{maximumLength}} caracteres o menos longitud (longitud actual: {{currentLength}})',\n  pattern: 'Must match pattern: {{requiredPattern}}',\n  format: function (error) {\n    switch (error.requiredFormat) {\n      case 'date':\n        return 'Debe tener una fecha, ej \"2000-12-31\"';\n      case 'time':\n        return 'Debe tener una hora, ej \"16:20\" o \"03:14:15.9265\"';\n      case 'date-time':\n        return 'Debe tener fecha y hora, ej \"2000-03-14T01:59\" o \"2000-03-14T01:59:26.535Z\"';\n      case 'email':\n        return 'No hay dirección de correo electrónico válida, ej \"name@example.com\"';\n      case 'hostname':\n        return 'Debe ser un nombre de host válido, ej \"example.com\"';\n      case 'ipv4':\n        return 'Debe ser una dirección de IPv4, ej \"127.0.0.1\"';\n      case 'ipv6':\n        return 'Debe ser una dirección de IPv6, ej \"1234:5678:9ABC:DEF0:1234:5678:9ABC:DEF0\"';\n      case 'url':\n        return 'Debe ser una URL, ej \"http://www.example.com/page.html\"';\n      case 'uuid':\n        return 'Debe ser un UUID, ej \"12345678-9ABC-DEF0-1234-56789ABCDEF0\"';\n      case 'color':\n        return 'Debe ser un color, ej \"#FFFFFF\" or \"rgb(255, 255, 255)\"';\n      case 'json-pointer':\n        return 'Debe ser un JSON Pointer, ej \"/pointer/to/something\"';\n      case 'relative-json-pointer':\n        return 'Debe ser un JSON Pointer relativo, ej \"2/pointer/to/something\"';\n      case 'regex':\n        return 'Debe ser una expresión regular, ej \"(1-)?\\\\d{3}-\\\\d{3}-\\\\d{4}\"';\n      default:\n        return 'Debe tener el formato correcto ' + error.requiredFormat;\n    }\n  },\n  minimum: 'Debe ser {{minimumValue}} o más',\n  exclusiveMinimum: 'Debe ser superior a {{exclusiveMinimumValue}}',\n  maximum: 'Debe ser {{maximumValue}} o menos',\n  exclusiveMaximum: 'Debe ser menor que {{exclusiveMaximumValue}}',\n  multipleOf: function (error) {\n    if ((1 / error.multipleOfValue) % 10 === 0) {\n      const decimals = Math.log10(1 / error.multipleOfValue);\n      return `Se permite un máximo de ${decimals} decimales`;\n    } else {\n      return `Debe ser múltiplo de ${error.multipleOfValue}.`;\n    }\n  },\n  minProperties: 'Debe tener {{minimumProperties}} o más elementos (elementos actuales: {{currentProperties}})',\n  maxProperties: 'Debe tener {{maximumProperties}} o menos elementos (elementos actuales: {{currentProperties}})',\n  minItems: 'Debe tener {{minimumItems}} o más elementos (elementos actuales: {{currentItems}})',\n  maxItems: 'Debe tener {{maximumItems}} o menos elementos (elementos actuales: {{currentItems}})',\n  uniqueItems: 'Todos los elementos deben ser únicos',\n};\n","export const frValidationMessages: any = { // French error messages\n  required: 'Est obligatoire.',\n  minLength: 'Doit avoir minimum {{minimumLength}} caractères (actuellement: {{currentLength}})',\n  maxLength: 'Doit avoir maximum {{maximumLength}} caractères (actuellement: {{currentLength}})',\n  pattern: 'Doit respecter: {{requiredPattern}}',\n  format: function (error) {\n    switch (error.requiredFormat) {\n      case 'date':\n        return 'Doit être une date, tel que \"2000-12-31\"';\n      case 'time':\n        return 'Doit être une heure, tel que \"16:20\" ou \"03:14:15.9265\"';\n      case 'date-time':\n        return 'Doit être une date et une heure, tel que \"2000-03-14T01:59\" ou \"2000-03-14T01:59:26.535Z\"';\n      case 'email':\n        return 'Doit être une adresse e-mail, tel que \"name@example.com\"';\n      case 'hostname':\n        return 'Doit être un nom de domaine, tel que \"example.com\"';\n      case 'ipv4':\n        return 'Doit être une adresse IPv4, tel que \"127.0.0.1\"';\n      case 'ipv6':\n        return 'Doit être une adresse IPv6, tel que \"1234:5678:9ABC:DEF0:1234:5678:9ABC:DEF0\"';\n      // TODO: add examples for 'uri', 'uri-reference', and 'uri-template'\n      // case 'uri': case 'uri-reference': case 'uri-template':\n      case 'url':\n        return 'Doit être une URL, tel que \"http://www.example.com/page.html\"';\n      case 'uuid':\n        return 'Doit être un UUID, tel que \"12345678-9ABC-DEF0-1234-56789ABCDEF0\"';\n      case 'color':\n        return 'Doit être une couleur, tel que \"#FFFFFF\" or \"rgb(255, 255, 255)\"';\n      case 'json-pointer':\n        return 'Doit être un JSON Pointer, tel que \"/pointer/to/something\"';\n      case 'relative-json-pointer':\n        return 'Doit être un relative JSON Pointer, tel que \"2/pointer/to/something\"';\n      case 'regex':\n        return 'Doit être une expression régulière, tel que \"(1-)?\\\\d{3}-\\\\d{3}-\\\\d{4}\"';\n      default:\n        return 'Doit être avoir le format correct: ' + error.requiredFormat;\n    }\n  },\n  minimum: 'Doit être supérieur à {{minimumValue}}',\n  exclusiveMinimum: 'Doit avoir minimum {{exclusiveMinimumValue}} charactères',\n  maximum: 'Doit être inférieur à {{maximumValue}}',\n  exclusiveMaximum: 'Doit avoir maximum {{exclusiveMaximumValue}} charactères',\n  multipleOf: function (error) {\n    if ((1 / error.multipleOfValue) % 10 === 0) {\n      const decimals = Math.log10(1 / error.multipleOfValue);\n      return `Doit comporter ${decimals} ou moins de decimales.`;\n    } else {\n      return `Doit être un multiple de ${error.multipleOfValue}.`;\n    }\n  },\n  minProperties: 'Doit comporter au minimum {{minimumProperties}} éléments',\n  maxProperties: 'Doit comporter au maximum {{maximumProperties}} éléments',\n  minItems: 'Doit comporter au minimum {{minimumItems}} éléments',\n  maxItems: 'Doit comporter au maximum {{minimumItems}} éléments',\n  uniqueItems: 'Tous les éléments doivent être uniques',\n  // Note: No default error messages for 'type', 'const', 'enum', or 'dependencies'\n};\n","export const itValidationMessages: any = { // Default Italian error messages\n  required: 'Il campo è obbligatorio',\n  minLength: 'Deve inserire almeno {{minimumLength}} caratteri (lunghezza corrente: {{currentLength}})',\n  maxLength: 'Il numero massimo di caratteri consentito è {{maximumLength}} (lunghezza corrente: {{currentLength}})',\n  pattern: 'Devi rispettare il pattern : {{requiredPattern}}',\n  format: function (error) {\n    switch (error.requiredFormat) {\n      case 'date':\n        return 'Deve essere una data, come \"31-12-2000\"';\n      case 'time':\n        return 'Deve essere un orario, come \"16:20\" o \"03:14:15.9265\"';\n      case 'date-time':\n        return 'Deve essere data-orario, come \"14-03-2000T01:59\" or \"14-03-2000T01:59:26.535Z\"';\n      case 'email':\n        return 'Deve essere un indirzzo email, come \"name@example.com\"';\n      case 'hostname':\n        return 'Deve essere un hostname, come \"example.com\"';\n      case 'ipv4':\n        return 'Deve essere un indirizzo IPv4, come \"127.0.0.1\"';\n      case 'ipv6':\n        return 'Deve essere un indirizzo IPv6, come \"1234:5678:9ABC:DEF0:1234:5678:9ABC:DEF0\"';\n      // TODO: add examples for 'uri', 'uri-reference', and 'uri-template'\n      // case 'uri': case 'uri-reference': case 'uri-template':\n      case 'url':\n        return 'Deve essere un url, come \"http://www.example.com/page.html\"';\n      case 'uuid':\n        return 'Deve essere un uuid, come \"12345678-9ABC-DEF0-1234-56789ABCDEF0\"';\n      case 'color':\n        return 'Deve essere un colore, come \"#FFFFFF\" o \"rgb(255, 255, 255)\"';\n      case 'json-pointer':\n        return 'Deve essere un JSON Pointer, come \"/pointer/to/something\"';\n      case 'relative-json-pointer':\n        return 'Deve essere un JSON Pointer relativo, come \"2/pointer/to/something\"';\n      case 'regex':\n        return 'Deve essere una regular expression, come \"(1-)?\\\\d{3}-\\\\d{3}-\\\\d{4}\"';\n      default:\n        return 'Deve essere formattato correttamente ' + error.requiredFormat;\n    }\n  },\n  minimum: 'Deve essere {{minimumValue}} o più',\n  exclusiveMinimum: 'Deve essere più di {{exclusiveMinimumValue}}',\n  maximum: 'Deve essere {{maximumValue}} o meno',\n  exclusiveMaximum: 'Deve essere minore di {{exclusiveMaximumValue}}',\n  multipleOf: function (error) {\n    if ((1 / error.multipleOfValue) % 10 === 0) {\n      const decimals = Math.log10(1 / error.multipleOfValue);\n      return `Deve avere ${decimals} o meno decimali.`;\n    } else {\n      return `Deve essere multiplo di ${error.multipleOfValue}.`;\n    }\n  },\n  minProperties: 'Deve avere {{minimumProperties}} o più elementi (elementi correnti: {{currentProperties}})',\n  maxProperties: 'Deve avere {{maximumProperties}} o meno elementi (elementi correnti: {{currentProperties}})',\n  minItems: 'Deve avere {{minimumItems}} o più elementi (elementi correnti: {{currentItems}})',\n  maxItems: 'Deve avere {{maximumItems}} o meno elementi (elementi correnti: {{currentItems}})',\n  uniqueItems: 'Tutti gli elementi devono essere unici',\n  // Note: No default error messages for 'type', 'const', 'enum', or 'dependencies'\n};\n","export const ptValidationMessages: any = { // Brazilian Portuguese error messages\n  required: 'Este campo é obrigatório.',\n  minLength: 'É preciso no mínimo {{minimumLength}} caracteres ou mais (tamanho atual: {{currentLength}})',\n  maxLength: 'É preciso no máximo  {{maximumLength}} caracteres ou menos (tamanho atual: {{currentLength}})',\n  pattern: 'Tem que ajustar ao formato: {{requiredPattern}}',\n  format: function (error) {\n    switch (error.requiredFormat) {\n      case 'date':\n        return 'Tem que ser uma data, por exemplo \"2000-12-31\"';\n      case 'time':\n        return 'Tem que ser horário, por exemplo \"16:20\" ou \"03:14:15.9265\"';\n      case 'date-time':\n        return 'Tem que ser data e hora, por exemplo \"2000-03-14T01:59\" ou \"2000-03-14T01:59:26.535Z\"';\n      case 'email':\n        return 'Tem que ser um email, por exemplo \"fulano@exemplo.com.br\"';\n      case 'hostname':\n        return 'Tem que ser uma nome de domínio, por exemplo \"exemplo.com.br\"';\n      case 'ipv4':\n        return 'Tem que ser um endereço IPv4, por exemplo \"127.0.0.1\"';\n      case 'ipv6':\n        return 'Tem que ser um endereço IPv6, por exemplo \"1234:5678:9ABC:DEF0:1234:5678:9ABC:DEF0\"';\n      // TODO: add examples for 'uri', 'uri-reference', and 'uri-template'\n      // case 'uri': case 'uri-reference': case 'uri-template':\n      case 'url':\n        return 'Tem que ser uma URL, por exemplo \"http://www.exemplo.com.br/pagina.html\"';\n      case 'uuid':\n        return 'Tem que ser um uuid, por exemplo \"12345678-9ABC-DEF0-1234-56789ABCDEF0\"';\n      case 'color':\n        return 'Tem que ser uma cor, por exemplo \"#FFFFFF\" ou \"rgb(255, 255, 255)\"';\n      case 'json-pointer':\n        return 'Tem que ser um JSON Pointer, por exemplo \"/referencia/para/algo\"';\n      case 'relative-json-pointer':\n        return 'Tem que ser um JSON Pointer relativo, por exemplo \"2/referencia/para/algo\"';\n      case 'regex':\n        return 'Tem que ser uma expressão regular, por exemplo \"(1-)?\\\\d{3}-\\\\d{3}-\\\\d{4}\"';\n      default:\n        return 'Tem que ser no formato: ' + error.requiredFormat;\n    }\n  },\n  minimum: 'Tem que ser {{minimumValue}} ou mais',\n  exclusiveMinimum: 'Tem que ser mais que {{exclusiveMinimumValue}}',\n  maximum: 'Tem que ser {{maximumValue}} ou menos',\n  exclusiveMaximum: 'Tem que ser menor que {{exclusiveMaximumValue}}',\n  multipleOf: function (error) {\n    if ((1 / error.multipleOfValue) % 10 === 0) {\n      const decimals = Math.log10(1 / error.multipleOfValue);\n      return `Tem que ter ${decimals} ou menos casas decimais.`;\n    } else {\n      return `Tem que ser um múltiplo de ${error.multipleOfValue}.`;\n    }\n  },\n  minProperties: 'Deve ter {{minimumProperties}} ou mais itens (itens até o momento: {{currentProperties}})',\n  maxProperties: 'Deve ter {{maximumProperties}} ou menos intens (itens até o momento: {{currentProperties}})',\n  minItems: 'Deve ter {{minimumItems}} ou mais itens (itens até o momento: {{currentItems}})',\n  maxItems: 'Deve ter {{maximumItems}} ou menos itens (itens até o momento: {{currentItems}})',\n  uniqueItems: 'Todos os itens devem ser únicos',\n  // Note: No default error messages for 'type', 'const', 'enum', or 'dependencies'\n};\n","export const zhValidationMessages: any = { // Chinese error messages\n  required: '必填字段.',\n  minLength: '字符长度必须大于或者等于 {{minimumLength}} (当前长度: {{currentLength}})',\n  maxLength: '字符长度必须小于或者等于 {{maximumLength}} (当前长度: {{currentLength}})',\n  pattern: '必须匹配正则表达式: {{requiredPattern}}',\n  format: function (error) {\n    switch (error.requiredFormat) {\n      case 'date':\n        return '必须为日期格式, 比如 \"2000-12-31\"';\n      case 'time':\n        return '必须为时间格式, 比如 \"16:20\" 或者 \"03:14:15.9265\"';\n      case 'date-time':\n        return '必须为日期时间格式, 比如 \"2000-03-14T01:59\" 或者 \"2000-03-14T01:59:26.535Z\"';\n      case 'email':\n        return '必须为邮箱地址, 比如 \"name@example.com\"';\n      case 'hostname':\n        return '必须为主机名, 比如 \"example.com\"';\n      case 'ipv4':\n        return '必须为 IPv4 地址, 比如 \"127.0.0.1\"';\n      case 'ipv6':\n        return '必须为 IPv6 地址, 比如 \"1234:5678:9ABC:DEF0:1234:5678:9ABC:DEF0\"';\n      // TODO: add examples for 'uri', 'uri-reference', and 'uri-template'\n      // case 'uri': case 'uri-reference': case 'uri-template':\n      case 'url':\n        return '必须为 url, 比如 \"http://www.example.com/page.html\"';\n      case 'uuid':\n        return '必须为 uuid, 比如 \"12345678-9ABC-DEF0-1234-56789ABCDEF0\"';\n      case 'color':\n        return '必须为颜色值, 比如 \"#FFFFFF\" 或者 \"rgb(255, 255, 255)\"';\n      case 'json-pointer':\n        return '必须为 JSON Pointer, 比如 \"/pointer/to/something\"';\n      case 'relative-json-pointer':\n        return '必须为相对的 JSON Pointer, 比如 \"2/pointer/to/something\"';\n      case 'regex':\n        return '必须为正则表达式, 比如 \"(1-)?\\\\d{3}-\\\\d{3}-\\\\d{4}\"';\n      default:\n        return '必须为格式正确的 ' + error.requiredFormat;\n    }\n  },\n  minimum: '必须大于或者等于最小值: {{minimumValue}}',\n  exclusiveMinimum: '必须大于最小值: {{exclusiveMinimumValue}}',\n  maximum: '必须小于或者等于最大值: {{maximumValue}}',\n  exclusiveMaximum: '必须小于最大值: {{exclusiveMaximumValue}}',\n  multipleOf: function (error) {\n    if ((1 / error.multipleOfValue) % 10 === 0) {\n      const decimals = Math.log10(1 / error.multipleOfValue);\n      return `必须有 ${decimals} 位或更少的小数位`;\n    } else {\n      return `必须为 ${error.multipleOfValue} 的倍数`;\n    }\n  },\n  minProperties: '项目数必须大于或者等于 {{minimumProperties}} (当前项目数: {{currentProperties}})',\n  maxProperties: '项目数必须小于或者等于 {{maximumProperties}} (当前项目数: {{currentProperties}})',\n  minItems: '项目数必须大于或者等于 {{minimumItems}} (当前项目数: {{currentItems}})',\n  maxItems: '项目数必须小于或者等于 {{maximumItems}} (当前项目数: {{currentItems}})',\n  uniqueItems: '所有项目必须是唯一的',\n  // Note: No default error messages for 'type', 'const', 'enum', or 'dependencies'\n};\n","import { Injectable } from '@angular/core';\nimport { AbstractControl, FormArray, FormGroup } from '@angular/forms';\nimport { Subject } from 'rxjs';\nimport cloneDeep from 'lodash/cloneDeep';\nimport Ajv from 'ajv';\nimport jsonDraft6 from 'ajv/lib/refs/json-schema-draft-06.json';\nimport {\n  buildFormGroup,\n  buildFormGroupTemplate,\n  formatFormData,\n  getControl,\n  fixTitle,\n  forEach,\n  hasOwn,\n  toTitleCase,\n  buildLayout,\n  getLayoutNode,\n  buildSchemaFromData,\n  buildSchemaFromLayout,\n  removeRecursiveReferences,\n  hasValue,\n  isArray,\n  isDefined,\n  isEmpty,\n  isObject,\n  JsonPointer\n} from './shared';\nimport {\n  deValidationMessages,\n  enValidationMessages,\n  esValidationMessages,\n  frValidationMessages,\n  itValidationMessages,\n  ptValidationMessages,\n  zhValidationMessages\n} from './locale';\n\n\nexport interface TitleMapItem {\n  name?: string;\n  value?: any;\n  checked?: boolean;\n  group?: string;\n  items?: TitleMapItem[];\n}\nexport interface ErrorMessages {\n  [control_name: string]: {\n    message: string | Function | Object;\n    code: string;\n  }[];\n}\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class JsonSchemaFormService {\n  JsonFormCompatibility = false;\n  ReactJsonSchemaFormCompatibility = false;\n  AngularSchemaFormCompatibility = false;\n  tpldata: any = {};\n\n  ajvOptions: any = {\n    allErrors: true,\n    jsonPointers: true,\n    unknownFormats: 'ignore'\n  };\n  ajv: any = new Ajv(this.ajvOptions); // AJV: Another JSON Schema Validator\n  validateFormData: any = null; // Compiled AJV function to validate active form's schema\n\n  formValues: any = {}; // Internal form data (may not have correct types)\n  data: any = {}; // Output form data (formValues, formatted with correct data types)\n  schema: any = {}; // Internal JSON Schema\n  layout: any[] = []; // Internal form layout\n  formGroupTemplate: any = {}; // Template used to create formGroup\n  formGroup: any = null; // Angular formGroup, which powers the reactive form\n  framework: any = null; // Active framework component\n  formOptions: any; // Active options, used to configure the form\n\n  validData: any = null; // Valid form data (or null) (=== isValid ? data : null)\n  isValid: boolean = null; // Is current form data valid?\n  ajvErrors: any = null; // Ajv errors for current data\n  validationErrors: any = null; // Any validation errors for current data\n  dataErrors: any = new Map(); //\n  formValueSubscription: any = null; // Subscription to formGroup.valueChanges observable (for un- and re-subscribing)\n  dataChanges: Subject<any> = new Subject(); // Form data observable\n  isValidChanges: Subject<any> = new Subject(); // isValid observable\n  validationErrorChanges: Subject<any> = new Subject(); // validationErrors observable\n\n  arrayMap: Map<string, number> = new Map(); // Maps arrays in data object and number of tuple values\n  dataMap: Map<string, any> = new Map(); // Maps paths in form data to schema and formGroup paths\n  dataRecursiveRefMap: Map<string, string> = new Map(); // Maps recursive reference points in form data\n  schemaRecursiveRefMap: Map<string, string> = new Map(); // Maps recursive reference points in schema\n  schemaRefLibrary: any = {}; // Library of schemas for resolving schema $refs\n  layoutRefLibrary: any = { '': null }; // Library of layout nodes for adding to form\n  templateRefLibrary: any = {}; // Library of formGroup templates for adding to form\n  hasRootReference = false; // Does the form include a recursive reference to itself?\n\n  language = 'en-US'; // Does the form include a recursive reference to itself?\n\n  // Default global form options\n  defaultFormOptions: any = {\n    autocomplete: true, // Allow the web browser to remember previous form submission values as defaults\n    addSubmit: 'auto', // Add a submit button if layout does not have one?\n    // for addSubmit: true = always, false = never,\n    // 'auto' = only if layout is undefined (form is built from schema alone)\n    debug: false, // Show debugging output?\n    disableInvalidSubmit: true, // Disable submit if form invalid?\n    formDisabled: false, // Set entire form as disabled? (not editable, and disables outputs)\n    formReadonly: false, // Set entire form as read only? (not editable, but outputs still enabled)\n    fieldsRequired: false, // (set automatically) Are there any required fields in the form?\n    framework: 'no-framework', // The framework to load\n    loadExternalAssets: false, // Load external css and JavaScript for framework?\n    pristine: { errors: true, success: true },\n    supressPropertyTitles: false,\n    setSchemaDefaults: 'auto', // Set fefault values from schema?\n    // true = always set (unless overridden by layout default or formValues)\n    // false = never set\n    // 'auto' = set in addable components, and everywhere if formValues not set\n    setLayoutDefaults: 'auto', // Set fefault values from layout?\n    // true = always set (unless overridden by formValues)\n    // false = never set\n    // 'auto' = set in addable components, and everywhere if formValues not set\n    validateOnRender: 'auto', // Validate fields immediately, before they are touched?\n    // true = validate all fields immediately\n    // false = only validate fields after they are touched by user\n    // 'auto' = validate fields with values immediately, empty fields after they are touched\n    widgets: {}, // Any custom widgets to load\n    defautWidgetOptions: {\n      // Default options for form control widgets\n      listItems: 1, // Number of list items to initially add to arrays with no default value\n      addable: true, // Allow adding items to an array or $ref point?\n      orderable: true, // Allow reordering items within an array?\n      removable: true, // Allow removing items from an array or $ref point?\n      enableErrorState: true, // Apply 'has-error' class when field fails validation?\n      // disableErrorState: false, // Don't apply 'has-error' class when field fails validation?\n      enableSuccessState: true, // Apply 'has-success' class when field validates?\n      // disableSuccessState: false, // Don't apply 'has-success' class when field validates?\n      feedback: false, // Show inline feedback icons?\n      feedbackOnRender: false, // Show errorMessage on Render?\n      notitle: false, // Hide title?\n      disabled: false, // Set control as disabled? (not editable, and excluded from output)\n      readonly: false, // Set control as read only? (not editable, but included in output)\n      returnEmptyFields: true, // return values for fields that contain no data?\n      validationMessages: {} // set by setLanguage()\n    }\n  };\n\n  constructor() {\n    this.setLanguage(this.language);\n    this.ajv.addMetaSchema(jsonDraft6);\n  }\n\n  setLanguage(language: string = 'en-US') {\n    this.language = language;\n    const languageValidationMessages = {\n      de: deValidationMessages,\n      en: enValidationMessages,\n      es: esValidationMessages,\n      fr: frValidationMessages,\n      it: itValidationMessages,\n      pt: ptValidationMessages,\n      zh: zhValidationMessages,\n    };\n    const languageCode = language.slice(0, 2);\n\n    const validationMessages = languageValidationMessages[languageCode];\n\n    this.defaultFormOptions.defautWidgetOptions.validationMessages = cloneDeep(\n      validationMessages\n    );\n  }\n\n  getData() {\n    return this.data;\n  }\n\n  getSchema() {\n    return this.schema;\n  }\n\n  getLayout() {\n    return this.layout;\n  }\n\n  resetAllValues() {\n    this.JsonFormCompatibility = false;\n    this.ReactJsonSchemaFormCompatibility = false;\n    this.AngularSchemaFormCompatibility = false;\n    this.tpldata = {};\n    this.validateFormData = null;\n    this.formValues = {};\n    this.schema = {};\n    this.layout = [];\n    this.formGroupTemplate = {};\n    this.formGroup = null;\n    this.framework = null;\n    this.data = {};\n    this.validData = null;\n    this.isValid = null;\n    this.validationErrors = null;\n    this.arrayMap = new Map();\n    this.dataMap = new Map();\n    this.dataRecursiveRefMap = new Map();\n    this.schemaRecursiveRefMap = new Map();\n    this.layoutRefLibrary = {};\n    this.schemaRefLibrary = {};\n    this.templateRefLibrary = {};\n    this.formOptions = cloneDeep(this.defaultFormOptions);\n  }\n\n  /**\n   * 'buildRemoteError' function\n   *\n   * Example errors:\n   * {\n   *   last_name: [ {\n   *     message: 'Last name must by start with capital letter.',\n   *     code: 'capital_letter'\n   *   } ],\n   *   email: [ {\n   *     message: 'Email must be from example.com domain.',\n   *     code: 'special_domain'\n   *   }, {\n   *     message: 'Email must contain an @ symbol.',\n   *     code: 'at_symbol'\n   *   } ]\n   * }\n   * //{ErrorMessages} errors\n   */\n  buildRemoteError(errors: ErrorMessages) {\n    forEach(errors, (value, key) => {\n      if (key in this.formGroup.controls) {\n        for (const error of value) {\n          const err = {};\n          err[error['code']] = error['message'];\n          this.formGroup.get(key).setErrors(err, { emitEvent: true });\n        }\n      }\n    });\n  }\n\n  validateData(newValue: any, updateSubscriptions = true): void {\n    // Format raw form data to correct data types\n    this.data = formatFormData(\n      newValue,\n      this.dataMap,\n      this.dataRecursiveRefMap,\n      this.arrayMap,\n      this.formOptions.returnEmptyFields\n    );\n    this.isValid = this.validateFormData(this.data);\n    this.validData = this.isValid ? this.data : null;\n    const compileErrors = errors => {\n      const compiledErrors = {};\n      (errors || []).forEach(error => {\n        if (!compiledErrors[error.dataPath]) {\n          compiledErrors[error.dataPath] = [];\n        }\n        compiledErrors[error.dataPath].push(error.message);\n      });\n      return compiledErrors;\n    };\n    this.ajvErrors = this.validateFormData.errors;\n    this.validationErrors = compileErrors(this.validateFormData.errors);\n    if (updateSubscriptions) {\n      this.dataChanges.next(this.data);\n      this.isValidChanges.next(this.isValid);\n      this.validationErrorChanges.next(this.ajvErrors);\n    }\n  }\n\n  buildFormGroupTemplate(formValues: any = null, setValues = true) {\n    this.formGroupTemplate = buildFormGroupTemplate(\n      this,\n      formValues,\n      setValues\n    );\n  }\n\n  buildFormGroup() {\n    this.formGroup = <FormGroup>buildFormGroup(this.formGroupTemplate);\n    if (this.formGroup) {\n      this.compileAjvSchema();\n      this.validateData(this.formGroup.value);\n\n      // Set up observables to emit data and validation info when form data changes\n      if (this.formValueSubscription) {\n        this.formValueSubscription.unsubscribe();\n      }\n      this.formValueSubscription = this.formGroup.valueChanges.subscribe(\n        formValue => this.validateData(formValue)\n      );\n    }\n  }\n\n  buildLayout(widgetLibrary: any) {\n    this.layout = buildLayout(this, widgetLibrary);\n  }\n\n  setOptions(newOptions: any) {\n    if (isObject(newOptions)) {\n      const addOptions = cloneDeep(newOptions);\n      // Backward compatibility for 'defaultOptions' (renamed 'defautWidgetOptions')\n      if (isObject(addOptions.defaultOptions)) {\n        Object.assign(\n          this.formOptions.defautWidgetOptions,\n          addOptions.defaultOptions\n        );\n        delete addOptions.defaultOptions;\n      }\n      if (isObject(addOptions.defautWidgetOptions)) {\n        Object.assign(\n          this.formOptions.defautWidgetOptions,\n          addOptions.defautWidgetOptions\n        );\n        delete addOptions.defautWidgetOptions;\n      }\n      Object.assign(this.formOptions, addOptions);\n\n      // convert disableErrorState / disableSuccessState to enable...\n      const globalDefaults = this.formOptions.defautWidgetOptions;\n      ['ErrorState', 'SuccessState']\n        .filter(suffix => hasOwn(globalDefaults, 'disable' + suffix))\n        .forEach(suffix => {\n          globalDefaults['enable' + suffix] = !globalDefaults[\n            'disable' + suffix\n          ];\n          delete globalDefaults['disable' + suffix];\n        });\n    }\n  }\n\n  compileAjvSchema() {\n    if (!this.validateFormData) {\n      // if 'ui:order' exists in properties, move it to root before compiling with ajv\n      if (Array.isArray(this.schema.properties['ui:order'])) {\n        this.schema['ui:order'] = this.schema.properties['ui:order'];\n        delete this.schema.properties['ui:order'];\n      }\n      this.ajv.removeSchema(this.schema);\n      this.validateFormData = this.ajv.compile(this.schema);\n    }\n  }\n\n  buildSchemaFromData(data?: any, requireAllFields = false): any {\n    if (data) {\n      return buildSchemaFromData(data, requireAllFields);\n    }\n    this.schema = buildSchemaFromData(this.formValues, requireAllFields);\n  }\n\n  buildSchemaFromLayout(layout?: any): any {\n    if (layout) {\n      return buildSchemaFromLayout(layout);\n    }\n    this.schema = buildSchemaFromLayout(this.layout);\n  }\n\n  setTpldata(newTpldata: any = {}): void {\n    this.tpldata = newTpldata;\n  }\n\n  parseText(\n    text = '',\n    value: any = {},\n    values: any = {},\n    key: number | string = null\n  ): string {\n    if (!text || !/{{.+?}}/.test(text)) {\n      return text;\n    }\n    return text.replace(/{{(.+?)}}/g, (...a) =>\n      this.parseExpression(a[1], value, values, key, this.tpldata)\n    );\n  }\n\n  parseExpression(\n    expression = '',\n    value: any = {},\n    values: any = {},\n    key: number | string = null,\n    tpldata: any = null\n  ) {\n    if (typeof expression !== 'string') {\n      return '';\n    }\n    const index = typeof key === 'number' ? key + 1 + '' : key || '';\n    expression = expression.trim();\n    if (\n      (expression[0] === \"'\" || expression[0] === '\"') &&\n      expression[0] === expression[expression.length - 1] &&\n      expression.slice(1, expression.length - 1).indexOf(expression[0]) === -1\n    ) {\n      return expression.slice(1, expression.length - 1);\n    }\n    if (expression === 'idx' || expression === '$index') {\n      return index;\n    }\n    if (expression === 'value' && !hasOwn(values, 'value')) {\n      return value;\n    }\n    if (\n      ['\"', \"'\", ' ', '||', '&&', '+'].every(\n        delim => expression.indexOf(delim) === -1\n      )\n    ) {\n      const pointer = JsonPointer.parseObjectPath(expression);\n      return pointer[0] === 'value' && JsonPointer.has(value, pointer.slice(1))\n        ? JsonPointer.get(value, pointer.slice(1))\n        : pointer[0] === 'values' && JsonPointer.has(values, pointer.slice(1))\n          ? JsonPointer.get(values, pointer.slice(1))\n          : pointer[0] === 'tpldata' && JsonPointer.has(tpldata, pointer.slice(1))\n            ? JsonPointer.get(tpldata, pointer.slice(1))\n            : JsonPointer.has(values, pointer)\n              ? JsonPointer.get(values, pointer)\n              : '';\n    }\n    if (expression.indexOf('[idx]') > -1) {\n      expression = expression.replace(/\\[idx\\]/g, <string>index);\n    }\n    if (expression.indexOf('[$index]') > -1) {\n      expression = expression.replace(/\\[$index\\]/g, <string>index);\n    }\n    // TODO: Improve expression evaluation by parsing quoted strings first\n    // let expressionArray = expression.match(/([^\"']+|\"[^\"]+\"|'[^']+')/g);\n    if (expression.indexOf('||') > -1) {\n      return expression\n        .split('||')\n        .reduce(\n          (all, term) =>\n            all || this.parseExpression(term, value, values, key, tpldata),\n          ''\n        );\n    }\n    if (expression.indexOf('&&') > -1) {\n      return expression\n        .split('&&')\n        .reduce(\n          (all, term) =>\n            all && this.parseExpression(term, value, values, key, tpldata),\n          ' '\n        )\n        .trim();\n    }\n    if (expression.indexOf('+') > -1) {\n      return expression\n        .split('+')\n        .map(term => this.parseExpression(term, value, values, key, tpldata))\n        .join('');\n    }\n    return '';\n  }\n\n  setArrayItemTitle(\n    parentCtx: any = {},\n    childNode: any = null,\n    index: number = null\n  ): string {\n    const parentNode = parentCtx.layoutNode;\n    const parentValues: any = this.getFormControlValue(parentCtx);\n    const isArrayItem =\n      (parentNode.type || '').slice(-5) === 'array' && isArray(parentValues);\n    const text = JsonPointer.getFirst(\n      isArrayItem && childNode.type !== '$ref'\n        ? [\n          [childNode, '/options/legend'],\n          [childNode, '/options/title'],\n          [parentNode, '/options/title'],\n          [parentNode, '/options/legend']\n        ]\n        : [\n          [childNode, '/options/title'],\n          [childNode, '/options/legend'],\n          [parentNode, '/options/title'],\n          [parentNode, '/options/legend']\n        ]\n    );\n    if (!text) {\n      return text;\n    }\n    const childValue =\n      isArray(parentValues) && index < parentValues.length\n        ? parentValues[index]\n        : parentValues;\n    return this.parseText(text, childValue, parentValues, index);\n  }\n\n  setItemTitle(ctx: any) {\n    return !ctx.options.title && /^(\\d+|-)$/.test(ctx.layoutNode.name)\n      ? null\n      : this.parseText(\n        ctx.options.title || toTitleCase(ctx.layoutNode.name),\n        this.getFormControlValue(this),\n        (this.getFormControlGroup(this) || <any>{}).value,\n        ctx.dataIndex[ctx.dataIndex.length - 1]\n      );\n  }\n\n  evaluateCondition(layoutNode: any, dataIndex: number[]): boolean {\n    const arrayIndex = dataIndex && dataIndex[dataIndex.length - 1];\n    let result = true;\n    if (hasValue((layoutNode.options || {}).condition)) {\n      if (typeof layoutNode.options.condition === 'string') {\n        let pointer = layoutNode.options.condition;\n        if (hasValue(arrayIndex)) {\n          pointer = pointer.replace('[arrayIndex]', `[${arrayIndex}]`);\n        }\n        pointer = JsonPointer.parseObjectPath(pointer);\n        result = !!JsonPointer.get(this.data, pointer);\n        if (!result && pointer[0] === 'model') {\n          result = !!JsonPointer.get({ model: this.data }, pointer);\n        }\n      } else if (typeof layoutNode.options.condition === 'function') {\n        result = layoutNode.options.condition(this.data);\n      } else if (\n        typeof layoutNode.options.condition.functionBody === 'string'\n      ) {\n        try {\n          const dynFn = new Function(\n            'model',\n            'arrayIndices',\n            layoutNode.options.condition.functionBody\n          );\n          result = dynFn(this.data, dataIndex);\n        } catch (e) {\n          result = true;\n          console.error(\n            'condition functionBody errored out on evaluation: ' +\n            layoutNode.options.condition.functionBody\n          );\n        }\n      }\n    }\n    return result;\n  }\n\n  initializeControl(ctx: any, bind = true): boolean {\n    if (!isObject(ctx)) {\n      return false;\n    }\n    if (isEmpty(ctx.options)) {\n      ctx.options = !isEmpty((ctx.layoutNode || {}).options)\n        ? ctx.layoutNode.options\n        : cloneDeep(this.formOptions);\n    }\n    ctx.formControl = this.getFormControl(ctx);\n    ctx.boundControl = bind && !!ctx.formControl;\n    if (ctx.formControl) {\n      ctx.controlName = this.getFormControlName(ctx);\n      ctx.controlValue = ctx.formControl.value;\n      ctx.controlDisabled = ctx.formControl.disabled;\n      ctx.options.errorMessage =\n        ctx.formControl.status === 'VALID'\n          ? null\n          : this.formatErrors(\n            ctx.formControl.errors,\n            ctx.options.validationMessages\n          );\n      ctx.options.showErrors =\n        this.formOptions.validateOnRender === true ||\n        (this.formOptions.validateOnRender === 'auto' &&\n          hasValue(ctx.controlValue));\n      ctx.formControl.statusChanges.subscribe(\n        status =>\n          (ctx.options.errorMessage =\n            status === 'VALID'\n              ? null\n              : this.formatErrors(\n                ctx.formControl.errors,\n                ctx.options.validationMessages\n              ))\n      );\n      ctx.formControl.valueChanges.subscribe(value => {\n        if (!!value) {\n          ctx.controlValue = value;\n        }\n      });\n    } else {\n      ctx.controlName = ctx.layoutNode.name;\n      ctx.controlValue = ctx.layoutNode.value || null;\n      const dataPointer = this.getDataPointer(ctx);\n      if (bind && dataPointer) {\n        console.error(\n          `warning: control \"${dataPointer}\" is not bound to the Angular FormGroup.`\n        );\n      }\n    }\n    return ctx.boundControl;\n  }\n\n  formatErrors(errors: any, validationMessages: any = {}): string {\n    if (isEmpty(errors)) {\n      return null;\n    }\n    if (!isObject(validationMessages)) {\n      validationMessages = {};\n    }\n    const addSpaces = string =>\n      string[0].toUpperCase() +\n      (string.slice(1) || '')\n        .replace(/([a-z])([A-Z])/g, '$1 $2')\n        .replace(/_/g, ' ');\n    const formatError = error =>\n      typeof error === 'object'\n        ? Object.keys(error)\n          .map(key =>\n            error[key] === true\n              ? addSpaces(key)\n              : error[key] === false\n                ? 'Not ' + addSpaces(key)\n                : addSpaces(key) + ': ' + formatError(error[key])\n          )\n          .join(', ')\n        : addSpaces(error.toString());\n    const messages = [];\n    return (\n      Object.keys(errors)\n        // Hide 'required' error, unless it is the only one\n        .filter(\n          errorKey =>\n            errorKey !== 'required' || Object.keys(errors).length === 1\n        )\n        .map(errorKey =>\n          // If validationMessages is a string, return it\n          typeof validationMessages === 'string'\n            ? validationMessages\n            : // If custom error message is a function, return function result\n            typeof validationMessages[errorKey] === 'function'\n              ? validationMessages[errorKey](errors[errorKey])\n              : // If custom error message is a string, replace placeholders and return\n              typeof validationMessages[errorKey] === 'string'\n                ? // Does error message have any {{property}} placeholders?\n                !/{{.+?}}/.test(validationMessages[errorKey])\n                  ? validationMessages[errorKey]\n                  : // Replace {{property}} placeholders with values\n                  Object.keys(errors[errorKey]).reduce(\n                    (errorMessage, errorProperty) =>\n                      errorMessage.replace(\n                        new RegExp('{{' + errorProperty + '}}', 'g'),\n                        errors[errorKey][errorProperty]\n                      ),\n                    validationMessages[errorKey]\n                  )\n                : // If no custom error message, return formatted error data instead\n                addSpaces(errorKey) + ' Error: ' + formatError(errors[errorKey])\n        )\n        .join('<br>')\n    );\n  }\n\n  updateValue(ctx: any, value: any): void {\n    // Set value of current control\n    ctx.controlValue = value;\n    if (ctx.boundControl) {\n      ctx.formControl.setValue(value);\n      ctx.formControl.markAsDirty();\n    }\n    ctx.layoutNode.value = value;\n\n    // Set values of any related controls in copyValueTo array\n    if (isArray(ctx.options.copyValueTo)) {\n      for (const item of ctx.options.copyValueTo) {\n        const targetControl = getControl(this.formGroup, item);\n        if (\n          isObject(targetControl) &&\n          typeof targetControl.setValue === 'function'\n        ) {\n          targetControl.setValue(value);\n          targetControl.markAsDirty();\n        }\n      }\n    }\n  }\n\n  updateArrayCheckboxList(ctx: any, checkboxList: TitleMapItem[]): void {\n    const formArray = <FormArray>this.getFormControl(ctx);\n\n    // Remove all existing items\n    while (formArray.value.length) {\n      formArray.removeAt(0);\n    }\n\n    // Re-add an item for each checked box\n    const refPointer = removeRecursiveReferences(\n      ctx.layoutNode.dataPointer + '/-',\n      this.dataRecursiveRefMap,\n      this.arrayMap\n    );\n    for (const checkboxItem of checkboxList) {\n      if (checkboxItem.checked) {\n        const newFormControl = buildFormGroup(\n          this.templateRefLibrary[refPointer]\n        );\n        newFormControl.setValue(checkboxItem.value);\n        formArray.push(newFormControl);\n      }\n    }\n    formArray.markAsDirty();\n  }\n\n  getFormControl(ctx: any): AbstractControl {\n    if (\n      !ctx.layoutNode ||\n      !isDefined(ctx.layoutNode.dataPointer) ||\n      ctx.layoutNode.type === '$ref'\n    ) {\n      return null;\n    }\n    return getControl(this.formGroup, this.getDataPointer(ctx));\n  }\n\n  getFormControlValue(ctx: any): AbstractControl {\n    if (\n      !ctx.layoutNode ||\n      !isDefined(ctx.layoutNode.dataPointer) ||\n      ctx.layoutNode.type === '$ref'\n    ) {\n      return null;\n    }\n    const control = getControl(this.formGroup, this.getDataPointer(ctx));\n    return control ? control.value : null;\n  }\n\n  getFormControlGroup(ctx: any): FormArray | FormGroup {\n    if (!ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer)) {\n      return null;\n    }\n    return getControl(this.formGroup, this.getDataPointer(ctx), true);\n  }\n\n  getFormControlName(ctx: any): string {\n    if (\n      !ctx.layoutNode ||\n      !isDefined(ctx.layoutNode.dataPointer) ||\n      !hasValue(ctx.dataIndex)\n    ) {\n      return null;\n    }\n    return JsonPointer.toKey(this.getDataPointer(ctx));\n  }\n\n  getLayoutArray(ctx: any): any[] {\n    return JsonPointer.get(this.layout, this.getLayoutPointer(ctx), 0, -1);\n  }\n\n  getParentNode(ctx: any): any {\n    return JsonPointer.get(this.layout, this.getLayoutPointer(ctx), 0, -2);\n  }\n\n  getDataPointer(ctx: any): string {\n    if (\n      !ctx.layoutNode ||\n      !isDefined(ctx.layoutNode.dataPointer) ||\n      !hasValue(ctx.dataIndex)\n    ) {\n      return null;\n    }\n    return JsonPointer.toIndexedPointer(\n      ctx.layoutNode.dataPointer,\n      ctx.dataIndex,\n      this.arrayMap\n    );\n  }\n\n  getLayoutPointer(ctx: any): string {\n    if (!hasValue(ctx.layoutIndex)) {\n      return null;\n    }\n    return '/' + ctx.layoutIndex.join('/items/');\n  }\n\n  isControlBound(ctx: any): boolean {\n    if (\n      !ctx.layoutNode ||\n      !isDefined(ctx.layoutNode.dataPointer) ||\n      !hasValue(ctx.dataIndex)\n    ) {\n      return false;\n    }\n    const controlGroup = this.getFormControlGroup(ctx);\n    const name = this.getFormControlName(ctx);\n    return controlGroup ? hasOwn(controlGroup.controls, name) : false;\n  }\n\n  addItem(ctx: any, name?: string): boolean {\n    if (\n      !ctx.layoutNode ||\n      !isDefined(ctx.layoutNode.$ref) ||\n      !hasValue(ctx.dataIndex) ||\n      !hasValue(ctx.layoutIndex)\n    ) {\n      return false;\n    }\n\n    // Create a new Angular form control from a template in templateRefLibrary\n    const newFormGroup = buildFormGroup(\n      this.templateRefLibrary[ctx.layoutNode.$ref]\n    );\n\n    // Add the new form control to the parent formArray or formGroup\n    if (ctx.layoutNode.arrayItem) {\n      // Add new array item to formArray\n      (<FormArray>this.getFormControlGroup(ctx)).push(newFormGroup);\n    } else {\n      // Add new $ref item to formGroup\n      (<FormGroup>this.getFormControlGroup(ctx)).addControl(\n        name || this.getFormControlName(ctx),\n        newFormGroup\n      );\n    }\n\n    // Copy a new layoutNode from layoutRefLibrary\n    const newLayoutNode = getLayoutNode(ctx.layoutNode, this);\n    newLayoutNode.arrayItem = ctx.layoutNode.arrayItem;\n    if (ctx.layoutNode.arrayItemType) {\n      newLayoutNode.arrayItemType = ctx.layoutNode.arrayItemType;\n    } else {\n      delete newLayoutNode.arrayItemType;\n    }\n    if (name) {\n      newLayoutNode.name = name;\n      newLayoutNode.dataPointer += '/' + JsonPointer.escape(name);\n      newLayoutNode.options.title = fixTitle(name);\n    }\n\n    // Add the new layoutNode to the form layout\n    JsonPointer.insert(this.layout, this.getLayoutPointer(ctx), newLayoutNode);\n\n    return true;\n  }\n\n  moveArrayItem(ctx: any, oldIndex: number, newIndex: number): boolean {\n    if (\n      !ctx.layoutNode ||\n      !isDefined(ctx.layoutNode.dataPointer) ||\n      !hasValue(ctx.dataIndex) ||\n      !hasValue(ctx.layoutIndex) ||\n      !isDefined(oldIndex) ||\n      !isDefined(newIndex) ||\n      oldIndex === newIndex\n    ) {\n      return false;\n    }\n\n    // Move item in the formArray\n    const formArray = <FormArray>this.getFormControlGroup(ctx);\n    const arrayItem = formArray.at(oldIndex);\n    formArray.removeAt(oldIndex);\n    formArray.insert(newIndex, arrayItem);\n    formArray.updateValueAndValidity();\n\n    // Move layout item\n    const layoutArray = this.getLayoutArray(ctx);\n    layoutArray.splice(newIndex, 0, layoutArray.splice(oldIndex, 1)[0]);\n    return true;\n  }\n\n  removeItem(ctx: any): boolean {\n    if (\n      !ctx.layoutNode ||\n      !isDefined(ctx.layoutNode.dataPointer) ||\n      !hasValue(ctx.dataIndex) ||\n      !hasValue(ctx.layoutIndex)\n    ) {\n      return false;\n    }\n\n    // Remove the Angular form control from the parent formArray or formGroup\n    if (ctx.layoutNode.arrayItem) {\n      // Remove array item from formArray\n      (<FormArray>this.getFormControlGroup(ctx)).removeAt(\n        ctx.dataIndex[ctx.dataIndex.length - 1]\n      );\n    } else {\n      // Remove $ref item from formGroup\n      (<FormGroup>this.getFormControlGroup(ctx)).removeControl(\n        this.getFormControlName(ctx)\n      );\n    }\n\n    // Remove layoutNode from layout\n    JsonPointer.remove(this.layout, this.getLayoutPointer(ctx));\n    return true;\n  }\n}\n","import {\n  ChangeDetectionStrategy,\n  Component,\n  Input,\n  OnInit\n  } from '@angular/core';\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'add-reference-widget',\n  template: `\n    <button *ngIf=\"showAddButton\"\n      [class]=\"options?.fieldHtmlClass || ''\"\n      [disabled]=\"options?.readonly\"\n      (click)=\"addItem($event)\">\n      <span *ngIf=\"options?.icon\" [class]=\"options?.icon\"></span>\n      <span *ngIf=\"options?.title\" [innerHTML]=\"buttonText\"></span>\n    </button>`,\n    changeDetection: ChangeDetectionStrategy.Default,\n})\nexport class AddReferenceComponent implements OnInit {\n  options: any;\n  itemCount: number;\n  previousLayoutIndex: number[];\n  previousDataIndex: number[];\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n  }\n\n  get showAddButton(): boolean {\n    return !this.layoutNode.arrayItem ||\n      this.layoutIndex[this.layoutIndex.length - 1] < this.options.maxItems;\n  }\n\n  addItem(event) {\n    event.preventDefault();\n    this.jsf.addItem(this);\n  }\n\n  get buttonText(): string {\n    const parent: any = {\n      dataIndex: this.dataIndex.slice(0, -1),\n      layoutIndex: this.layoutIndex.slice(0, -1),\n      layoutNode: this.jsf.getParentNode(this)\n    };\n    return parent.layoutNode.add ||\n      this.jsf.setArrayItemTitle(parent, this.layoutNode, this.itemCount);\n  }\n}\n","import { AbstractControl } from '@angular/forms';\nimport { Component, Input, OnInit } from '@angular/core';\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'button-widget',\n  template: `\n    <div\n      [class]=\"options?.htmlClass || ''\">\n      <button\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [name]=\"controlName\"\n        [type]=\"layoutNode?.type\"\n        [value]=\"controlValue\"\n        (click)=\"updateValue($event)\">\n        <span *ngIf=\"options?.icon || options?.title\"\n          [class]=\"options?.icon\"\n          [innerHTML]=\"options?.title\"></span>\n      </button>\n    </div>`,\n})\nexport class ButtonComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    if (typeof this.options.onClick === 'function') {\n      this.options.onClick(event);\n    } else {\n      this.jsf.updateValue(this, event.target.value);\n    }\n  }\n}\n","import { AbstractControl } from '@angular/forms';\nimport { Component, Input, OnInit } from '@angular/core';\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'checkbox-widget',\n  template: `\n    <label\n      [attr.for]=\"'control' + layoutNode?._id\"\n      [class]=\"options?.itemLabelHtmlClass || ''\">\n      <input *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [class]=\"(options?.fieldHtmlClass || '') + (isChecked ?\n          (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n          (' ' + (options?.style?.unselected || '')))\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        type=\"checkbox\">\n      <input *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [checked]=\"isChecked ? 'checked' : null\"\n        [class]=\"(options?.fieldHtmlClass || '') + (isChecked ?\n          (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n          (' ' + (options?.style?.unselected || '')))\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [value]=\"controlValue\"\n        type=\"checkbox\"\n        (change)=\"updateValue($event)\">\n      <span *ngIf=\"options?.title\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></span>\n    </label>`,\n})\nexport class CheckboxComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  trueValue: any = true;\n  falseValue: any = false;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n    if (this.controlValue === null || this.controlValue === undefined) {\n      this.controlValue = this.options.title;\n    }\n  }\n\n  updateValue(event) {\n    event.preventDefault();\n    this.jsf.updateValue(this, event.target.checked ? this.trueValue : this.falseValue);\n  }\n\n  get isChecked() {\n    return this.jsf.getFormControlValue(this) === this.trueValue;\n  }\n}\n","import { AbstractControl } from '@angular/forms';\nimport { buildTitleMap } from '../shared';\nimport { Component, Input, OnInit } from '@angular/core';\nimport { JsonSchemaFormService, TitleMapItem } from '../json-schema-form.service';\n\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'checkboxes-widget',\n  template: `\n    <label *ngIf=\"options?.title\"\n      [class]=\"options?.labelHtmlClass || ''\"\n      [style.display]=\"options?.notitle ? 'none' : ''\"\n      [innerHTML]=\"options?.title\"></label>\n\n    <!-- 'horizontal' = checkboxes-inline or checkboxbuttons -->\n    <div *ngIf=\"layoutOrientation === 'horizontal'\" [class]=\"options?.htmlClass || ''\">\n      <label *ngFor=\"let checkboxItem of checkboxList\"\n        [attr.for]=\"'control' + layoutNode?._id + '/' + checkboxItem.value\"\n        [class]=\"(options?.itemLabelHtmlClass || '') + (checkboxItem.checked ?\n          (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n          (' ' + (options?.style?.unselected || '')))\">\n        <input type=\"checkbox\"\n          [attr.required]=\"options?.required\"\n          [checked]=\"checkboxItem.checked\"\n          [class]=\"options?.fieldHtmlClass || ''\"\n          [disabled]=\"controlDisabled\"\n          [id]=\"'control' + layoutNode?._id + '/' + checkboxItem.value\"\n          [name]=\"checkboxItem?.name\"\n          [readonly]=\"options?.readonly ? 'readonly' : null\"\n          [value]=\"checkboxItem.value\"\n          (change)=\"updateValue($event)\">\n        <span [innerHTML]=\"checkboxItem.name\"></span>\n      </label>\n    </div>\n\n    <!-- 'vertical' = regular checkboxes -->\n    <div *ngIf=\"layoutOrientation === 'vertical'\">\n      <div *ngFor=\"let checkboxItem of checkboxList\" [class]=\"options?.htmlClass || ''\">\n        <label\n          [attr.for]=\"'control' + layoutNode?._id + '/' + checkboxItem.value\"\n          [class]=\"(options?.itemLabelHtmlClass || '') + (checkboxItem.checked ?\n            (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n            (' ' + (options?.style?.unselected || '')))\">\n          <input type=\"checkbox\"\n            [attr.required]=\"options?.required\"\n            [checked]=\"checkboxItem.checked\"\n            [class]=\"options?.fieldHtmlClass || ''\"\n            [disabled]=\"controlDisabled\"\n            [id]=\"options?.name + '/' + checkboxItem.value\"\n            [name]=\"checkboxItem?.name\"\n            [readonly]=\"options?.readonly ? 'readonly' : null\"\n            [value]=\"checkboxItem.value\"\n            (change)=\"updateValue($event)\">\n          <span [innerHTML]=\"checkboxItem?.name\"></span>\n        </label>\n      </div>\n    </div>`,\n})\nexport class CheckboxesComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  layoutOrientation: string;\n  formArray: AbstractControl;\n  checkboxList: TitleMapItem[] = [];\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.layoutOrientation = (this.layoutNode.type === 'checkboxes-inline' ||\n      this.layoutNode.type === 'checkboxbuttons') ? 'horizontal' : 'vertical';\n    this.jsf.initializeControl(this);\n    this.checkboxList = buildTitleMap(\n      this.options.titleMap || this.options.enumNames, this.options.enum, true\n    );\n    if (this.boundControl) {\n      const formArray = this.jsf.getFormControl(this);\n      this.checkboxList.forEach(checkboxItem =>\n        checkboxItem.checked = formArray.value.includes(checkboxItem.value)\n      );\n    }\n  }\n\n  updateValue(event) {\n    for (const checkboxItem of this.checkboxList) {\n      if (event.target.value === checkboxItem.value) {\n        checkboxItem.checked = event.target.checked;\n      }\n    }\n    if (this.boundControl) {\n      this.jsf.updateArrayCheckboxList(this, this.checkboxList);\n    }\n  }\n}\n","import { AbstractControl } from '@angular/forms';\nimport { Component, Input, OnInit } from '@angular/core';\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n\n// TODO: Add this control\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'file-widget',\n  template: ``,\n})\nexport class FileComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n","import { AbstractControl } from '@angular/forms';\nimport { Component, Input, OnInit } from '@angular/core';\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'input-widget',\n  template: `\n    <div [class]=\"options?.htmlClass || ''\">\n      <label *ngIf=\"options?.title\"\n        [attr.for]=\"'control' + layoutNode?._id\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></label>\n      <input *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.list]=\"'control' + layoutNode?._id + 'Autocomplete'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [type]=\"layoutNode?.type\">\n      <input *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.list]=\"'control' + layoutNode?._id + 'Autocomplete'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [type]=\"layoutNode?.type\"\n        [value]=\"controlValue\"\n        (input)=\"updateValue($event)\">\n        <datalist *ngIf=\"options?.typeahead?.source\"\n          [id]=\"'control' + layoutNode?._id + 'Autocomplete'\">\n          <option *ngFor=\"let word of options?.typeahead?.source\" [value]=\"word\">\n        </datalist>\n    </div>`,\n})\nexport class InputComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: string;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  autoCompleteList: string[] = [];\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n","import { Component, Input, OnInit } from '@angular/core';\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'message-widget',\n  template: `\n    <span *ngIf=\"message\"\n      [class]=\"options?.labelHtmlClass || ''\"\n      [innerHTML]=\"message\"></span>`,\n})\nexport class MessageComponent implements OnInit {\n  options: any;\n  message: string = null;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.message = this.options.help || this.options.helpvalue ||\n      this.options.msg || this.options.message;\n  }\n}\n","import { Component, Input } from '@angular/core';\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'none-widget',\n  template: ``,\n})\nexport class NoneComponent {\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n}\n","import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'number-widget',\n  template: `\n    <div [class]=\"options?.htmlClass || ''\">\n      <label *ngIf=\"options?.title\"\n        [attr.for]=\"'control' + layoutNode?._id\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></label>\n      <input *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.max]=\"options?.maximum\"\n        [attr.min]=\"options?.minimum\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.required]=\"options?.required\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.step]=\"options?.multipleOf || options?.step || 'any'\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [title]=\"lastValidNumber\"\n        [type]=\"layoutNode?.type === 'range' ? 'range' : 'number'\">\n      <input *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.max]=\"options?.maximum\"\n        [attr.min]=\"options?.minimum\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.required]=\"options?.required\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.step]=\"options?.multipleOf || options?.step || 'any'\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [title]=\"lastValidNumber\"\n        [type]=\"layoutNode?.type === 'range' ? 'range' : 'number'\"\n        [value]=\"controlValue\"\n        (input)=\"updateValue($event)\">\n      <span *ngIf=\"layoutNode?.type === 'range'\" [innerHTML]=\"controlValue\"></span>\n    </div>`,\n})\nexport class NumberComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  allowNegative = true;\n  allowDecimal = true;\n  allowExponents = false;\n  lastValidNumber = '';\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n    if (this.layoutNode.dataType === 'integer') { this.allowDecimal = false; }\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n","import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n// TODO: Add this control\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'one-of-widget',\n  template: ``,\n})\nexport class OneOfComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n","import { AbstractControl } from '@angular/forms';\nimport { buildTitleMap } from '../shared';\nimport { Component, Input, OnInit } from '@angular/core';\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'radios-widget',\n  template: `\n    <label *ngIf=\"options?.title\"\n      [attr.for]=\"'control' + layoutNode?._id\"\n      [class]=\"options?.labelHtmlClass || ''\"\n      [style.display]=\"options?.notitle ? 'none' : ''\"\n      [innerHTML]=\"options?.title\"></label>\n\n    <!-- 'horizontal' = radios-inline or radiobuttons -->\n    <div *ngIf=\"layoutOrientation === 'horizontal'\"\n      [class]=\"options?.htmlClass || ''\">\n      <label *ngFor=\"let radioItem of radiosList\"\n        [attr.for]=\"'control' + layoutNode?._id + '/' + radioItem?.value\"\n        [class]=\"(options?.itemLabelHtmlClass || '') +\n          ((controlValue + '' === radioItem?.value + '') ?\n          (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n          (' ' + (options?.style?.unselected || '')))\">\n        <input type=\"radio\"\n          [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n          [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n          [attr.required]=\"options?.required\"\n          [checked]=\"radioItem?.value === controlValue\"\n          [class]=\"options?.fieldHtmlClass || ''\"\n          [disabled]=\"controlDisabled\"\n          [id]=\"'control' + layoutNode?._id + '/' + radioItem?.value\"\n          [name]=\"controlName\"\n          [value]=\"radioItem?.value\"\n          (change)=\"updateValue($event)\">\n        <span [innerHTML]=\"radioItem?.name\"></span>\n      </label>\n    </div>\n\n    <!-- 'vertical' = regular radios -->\n    <div *ngIf=\"layoutOrientation !== 'horizontal'\">\n      <div *ngFor=\"let radioItem of radiosList\"\n        [class]=\"options?.htmlClass || ''\">\n        <label\n          [attr.for]=\"'control' + layoutNode?._id + '/' + radioItem?.value\"\n          [class]=\"(options?.itemLabelHtmlClass || '') +\n            ((controlValue + '' === radioItem?.value + '') ?\n            (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n            (' ' + (options?.style?.unselected || '')))\">\n          <input type=\"radio\"\n            [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n            [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n            [attr.required]=\"options?.required\"\n            [checked]=\"radioItem?.value === controlValue\"\n            [class]=\"options?.fieldHtmlClass || ''\"\n            [disabled]=\"controlDisabled\"\n            [id]=\"'control' + layoutNode?._id + '/' + radioItem?.value\"\n            [name]=\"controlName\"\n            [value]=\"radioItem?.value\"\n            (change)=\"updateValue($event)\">\n          <span [innerHTML]=\"radioItem?.name\"></span>\n        </label>\n      </div>\n    </div>`,\n})\nexport class RadiosComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  layoutOrientation = 'vertical';\n  radiosList: any[] = [];\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    if (this.layoutNode.type === 'radios-inline' ||\n      this.layoutNode.type === 'radiobuttons'\n    ) {\n      this.layoutOrientation = 'horizontal';\n    }\n    this.radiosList = buildTitleMap(\n      this.options.titleMap || this.options.enumNames,\n      this.options.enum, true\n    );\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n","import { Component, Input } from '@angular/core';\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'root-widget',\n  template: `\n    <div *ngFor=\"let layoutItem of layout; let i = index\"\n      [class.form-flex-item]=\"isFlexItem\"\n      [style.align-self]=\"(layoutItem.options || {})['align-self']\"\n      [style.flex-basis]=\"getFlexAttribute(layoutItem, 'flex-basis')\"\n      [style.flex-grow]=\"getFlexAttribute(layoutItem, 'flex-grow')\"\n      [style.flex-shrink]=\"getFlexAttribute(layoutItem, 'flex-shrink')\"\n      [style.order]=\"(layoutItem.options || {}).order\">\n      <div\n        [dataIndex]=\"layoutItem?.arrayItem ? (dataIndex || []).concat(i) : (dataIndex || [])\"\n        [layoutIndex]=\"(layoutIndex || []).concat(i)\"\n        [layoutNode]=\"layoutItem\"\n        [orderable]=\"isDraggable(layoutItem)\">\n        <select-framework-widget *ngIf=\"showWidget(layoutItem)\"\n          [dataIndex]=\"layoutItem?.arrayItem ? (dataIndex || []).concat(i) : (dataIndex || [])\"\n          [layoutIndex]=\"(layoutIndex || []).concat(i)\"\n          [layoutNode]=\"layoutItem\"></select-framework-widget>\n      </div>\n    </div>`,\n  styles: [`\n    [draggable=true] {\n      transition: all 150ms cubic-bezier(.4, 0, .2, 1);\n    }\n    [draggable=true]:hover {\n      cursor: move;\n      box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);\n      position: relative; z-index: 10;\n      margin-top: -1px;\n      margin-left: -1px;\n      margin-right: 1px;\n      margin-bottom: 1px;\n    }\n    [draggable=true].drag-target-top {\n      box-shadow: 0 -2px 0 #000;\n      position: relative; z-index: 20;\n    }\n    [draggable=true].drag-target-bottom {\n      box-shadow: 0 2px 0 #000;\n      position: relative; z-index: 20;\n    }\n  `],\n})\nexport class RootComponent {\n  options: any;\n  @Input() dataIndex: number[];\n  @Input() layoutIndex: number[];\n  @Input() layout: any[];\n  @Input() isOrderable: boolean;\n  @Input() isFlexItem = false;\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  isDraggable(node: any): boolean {\n    return node.arrayItem && node.type !== '$ref' &&\n      node.arrayItemType === 'list' && this.isOrderable !== false;\n  }\n\n  // Set attributes for flexbox child\n  // (container attributes are set in section.component)\n  getFlexAttribute(node: any, attribute: string) {\n    const index = ['flex-grow', 'flex-shrink', 'flex-basis'].indexOf(attribute);\n    return ((node.options || {}).flex || '').split(/\\s+/)[index] ||\n      (node.options || {})[attribute] || ['1', '1', 'auto'][index];\n  }\n\n  showWidget(layoutNode: any): boolean {\n    return this.jsf.evaluateCondition(layoutNode, this.dataIndex);\n  }\n}\n","import { Component, Input, OnInit } from '@angular/core';\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'section-widget',\n  template: `\n    <div *ngIf=\"containerType === 'div'\"\n      [class]=\"options?.htmlClass || ''\"\n      [class.expandable]=\"options?.expandable && !expanded\"\n      [class.expanded]=\"options?.expandable && expanded\">\n      <label *ngIf=\"sectionTitle\"\n        class=\"legend\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [innerHTML]=\"sectionTitle\"\n        (click)=\"toggleExpanded()\"></label>\n      <root-widget *ngIf=\"expanded\"\n        [dataIndex]=\"dataIndex\"\n        [layout]=\"layoutNode.items\"\n        [layoutIndex]=\"layoutIndex\"\n        [isFlexItem]=\"getFlexAttribute('is-flex')\"\n        [isOrderable]=\"options?.orderable\"\n        [class.form-flex-column]=\"getFlexAttribute('flex-direction') === 'column'\"\n        [class.form-flex-row]=\"getFlexAttribute('flex-direction') === 'row'\"\n        [style.align-content]=\"getFlexAttribute('align-content')\"\n        [style.align-items]=\"getFlexAttribute('align-items')\"\n        [style.display]=\"getFlexAttribute('display')\"\n        [style.flex-direction]=\"getFlexAttribute('flex-direction')\"\n        [style.flex-wrap]=\"getFlexAttribute('flex-wrap')\"\n        [style.justify-content]=\"getFlexAttribute('justify-content')\"></root-widget>\n    </div>\n    <fieldset *ngIf=\"containerType === 'fieldset'\"\n      [class]=\"options?.htmlClass || ''\"\n      [class.expandable]=\"options?.expandable && !expanded\"\n      [class.expanded]=\"options?.expandable && expanded\"\n      [disabled]=\"options?.readonly\">\n      <legend *ngIf=\"sectionTitle\"\n        class=\"legend\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [innerHTML]=\"sectionTitle\"\n        (click)=\"toggleExpanded()\"></legend>\n      <div *ngIf=\"options?.messageLocation !== 'bottom'\">\n        <p *ngIf=\"options?.description\"\n        class=\"help-block\"\n        [class]=\"options?.labelHelpBlockClass || ''\"\n        [innerHTML]=\"options?.description\"></p>\n      </div>\n      <root-widget *ngIf=\"expanded\"\n        [dataIndex]=\"dataIndex\"\n        [layout]=\"layoutNode.items\"\n        [layoutIndex]=\"layoutIndex\"\n        [isFlexItem]=\"getFlexAttribute('is-flex')\"\n        [isOrderable]=\"options?.orderable\"\n        [class.form-flex-column]=\"getFlexAttribute('flex-direction') === 'column'\"\n        [class.form-flex-row]=\"getFlexAttribute('flex-direction') === 'row'\"\n        [style.align-content]=\"getFlexAttribute('align-content')\"\n        [style.align-items]=\"getFlexAttribute('align-items')\"\n        [style.display]=\"getFlexAttribute('display')\"\n        [style.flex-direction]=\"getFlexAttribute('flex-direction')\"\n        [style.flex-wrap]=\"getFlexAttribute('flex-wrap')\"\n        [style.justify-content]=\"getFlexAttribute('justify-content')\"></root-widget>\n      <div *ngIf=\"options?.messageLocation === 'bottom'\">\n        <p *ngIf=\"options?.description\"\n        class=\"help-block\"\n        [class]=\"options?.labelHelpBlockClass || ''\"\n        [innerHTML]=\"options?.description\"></p>\n      </div>\n    </fieldset>`,\n  styles: [`\n    .legend { font-weight: bold; }\n    .expandable > legend:before, .expandable > label:before  { content: '▶'; padding-right: .3em; }\n    .expanded > legend:before, .expanded > label:before  { content: '▼'; padding-right: .2em; }\n  `],\n})\nexport class SectionComponent implements OnInit {\n  options: any;\n  expanded = true;\n  containerType: string;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  get sectionTitle() {\n    return this.options.notitle ? null : this.jsf.setItemTitle(this);\n  }\n\n  ngOnInit() {\n    this.jsf.initializeControl(this);\n    this.options = this.layoutNode.options || {};\n    this.expanded = typeof this.options.expanded === 'boolean' ?\n      this.options.expanded : !this.options.expandable;\n    switch (this.layoutNode.type) {\n      case 'fieldset': case 'array': case 'tab': case 'advancedfieldset':\n      case 'authfieldset': case 'optionfieldset': case 'selectfieldset':\n        this.containerType = 'fieldset';\n      break;\n      default: // 'div', 'flex', 'section', 'conditional', 'actions', 'tagsinput'\n        this.containerType = 'div';\n      break;\n    }\n  }\n\n  toggleExpanded() {\n    if (this.options.expandable) { this.expanded = !this.expanded; }\n  }\n\n  // Set attributes for flexbox container\n  // (child attributes are set in root.component)\n  getFlexAttribute(attribute: string) {\n    const flexActive: boolean =\n      this.layoutNode.type === 'flex' ||\n      !!this.options.displayFlex ||\n      this.options.display === 'flex';\n    if (attribute !== 'flex' && !flexActive) { return null; }\n    switch (attribute) {\n      case 'is-flex':\n        return flexActive;\n      case 'display':\n        return flexActive ? 'flex' : 'initial';\n      case 'flex-direction': case 'flex-wrap':\n        const index = ['flex-direction', 'flex-wrap'].indexOf(attribute);\n        return (this.options['flex-flow'] || '').split(/\\s+/)[index] ||\n          this.options[attribute] || ['column', 'nowrap'][index];\n      case 'justify-content': case 'align-items': case 'align-content':\n        return this.options[attribute];\n    }\n  }\n}\n","import { AbstractControl } from '@angular/forms';\nimport { buildTitleMap, isArray } from '../shared';\nimport { Component, Input, OnInit } from '@angular/core';\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'select-widget',\n  template: `\n    <div\n      [class]=\"options?.htmlClass || ''\">\n      <label *ngIf=\"options?.title\"\n        [attr.for]=\"'control' + layoutNode?._id\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></label>\n      <select *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\">\n        <ng-template ngFor let-selectItem [ngForOf]=\"selectList\">\n          <option *ngIf=\"!isArray(selectItem?.items)\"\n            [value]=\"selectItem?.value\">\n            <span [innerHTML]=\"selectItem?.name\"></span>\n          </option>\n          <optgroup *ngIf=\"isArray(selectItem?.items)\"\n            [label]=\"selectItem?.group\">\n            <option *ngFor=\"let subItem of selectItem.items\"\n              [value]=\"subItem?.value\">\n              <span [innerHTML]=\"subItem?.name\"></span>\n            </option>\n          </optgroup>\n        </ng-template>\n      </select>\n      <select *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        (change)=\"updateValue($event)\">\n        <ng-template ngFor let-selectItem [ngForOf]=\"selectList\">\n          <option *ngIf=\"!isArray(selectItem?.items)\"\n            [selected]=\"selectItem?.value === controlValue\"\n            [value]=\"selectItem?.value\">\n            <span [innerHTML]=\"selectItem?.name\"></span>\n          </option>\n          <optgroup *ngIf=\"isArray(selectItem?.items)\"\n            [label]=\"selectItem?.group\">\n            <option *ngFor=\"let subItem of selectItem.items\"\n              [attr.selected]=\"subItem?.value === controlValue\"\n              [value]=\"subItem?.value\">\n              <span [innerHTML]=\"subItem?.name\"></span>\n            </option>\n          </optgroup>\n        </ng-template>\n      </select>\n    </div>`,\n})\nexport class SelectComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  selectList: any[] = [];\n  isArray = isArray;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.selectList = buildTitleMap(\n      this.options.titleMap || this.options.enumNames,\n      this.options.enum, !!this.options.required, !!this.options.flatList\n    );\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n","import {\n  Component, ComponentFactoryResolver, ComponentRef, Input,\n  OnChanges, OnInit, ViewChild, ViewContainerRef\n} from '@angular/core';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'select-framework-widget',\n  template: `<div #widgetContainer></div>`,\n})\nexport class SelectFrameworkComponent implements OnChanges, OnInit {\n  newComponent: ComponentRef<any> = null;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n  @ViewChild('widgetContainer', {\n      read: ViewContainerRef,\n      static: true })\n    widgetContainer: ViewContainerRef;\n\n  constructor(\n    private componentFactory: ComponentFactoryResolver,\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.updateComponent();\n  }\n\n  ngOnChanges() {\n    this.updateComponent();\n  }\n\n  updateComponent() {\n    if (this.widgetContainer && !this.newComponent && this.jsf.framework) {\n      this.newComponent = this.widgetContainer.createComponent(\n        this.componentFactory.resolveComponentFactory(this.jsf.framework)\n      );\n    }\n    if (this.newComponent) {\n      for (const input of ['layoutNode', 'layoutIndex', 'dataIndex']) {\n        this.newComponent.instance[input] = this[input];\n      }\n    }\n  }\n}\n","import {\n  Component, ComponentFactoryResolver, ComponentRef, Input,\n  OnChanges, OnInit, ViewChild, ViewContainerRef\n} from '@angular/core';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'select-widget-widget',\n  template: `<div #widgetContainer></div>`,\n})\nexport class SelectWidgetComponent implements OnChanges, OnInit {\n  newComponent: ComponentRef<any> = null;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n  @ViewChild('widgetContainer', { read: ViewContainerRef, static: true })\n    widgetContainer: ViewContainerRef;\n\n  constructor(\n    private componentFactory: ComponentFactoryResolver,\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.updateComponent();\n  }\n\n  ngOnChanges() {\n    this.updateComponent();\n  }\n\n  updateComponent() {\n    if (this.widgetContainer && !this.newComponent && (this.layoutNode || {}).widget) {\n      this.newComponent = this.widgetContainer.createComponent(\n        this.componentFactory.resolveComponentFactory(this.layoutNode.widget)\n      );\n    }\n    if (this.newComponent) {\n      for (const input of ['layoutNode', 'layoutIndex', 'dataIndex']) {\n        this.newComponent.instance[input] = this[input];\n      }\n    }\n  }\n}\n","import { AbstractControl } from '@angular/forms';\nimport { Component, Input, OnInit } from '@angular/core';\nimport { hasOwn } from '../shared/utility.functions';\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'submit-widget',\n  template: `\n    <div\n      [class]=\"options?.htmlClass || ''\">\n      <input\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [type]=\"layoutNode?.type\"\n        [value]=\"controlValue\"\n        (click)=\"updateValue($event)\">\n    </div>`,\n})\nexport class SubmitComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n    if (hasOwn(this.options, 'disabled')) {\n      this.controlDisabled = this.options.disabled;\n    } else if (this.jsf.formOptions.disableInvalidSubmit) {\n      this.controlDisabled = !this.jsf.isValid;\n      this.jsf.isValidChanges.subscribe(isValid => this.controlDisabled = !isValid);\n    }\n    if (this.controlValue === null || this.controlValue === undefined) {\n      this.controlValue = this.options.title;\n    }\n  }\n\n  updateValue(event) {\n    if (typeof this.options.onClick === 'function') {\n      this.options.onClick(event);\n    } else {\n      this.jsf.updateValue(this, event.target.value);\n    }\n  }\n}\n","import { Component, Input, OnInit } from '@angular/core';\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'tabs-widget',\n  template: `\n    <ul\n      [class]=\"options?.labelHtmlClass || ''\">\n      <li *ngFor=\"let item of layoutNode?.items; let i = index\"\n        [class]=\"(options?.itemLabelHtmlClass || '') + (selectedItem === i ?\n          (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n          (' ' + options?.style?.unselected))\"\n        role=\"presentation\"\n        data-tabs>\n        <a *ngIf=\"showAddTab || item.type !== '$ref'\"\n           [class]=\"'nav-link' + (selectedItem === i ? (' ' + options?.activeClass + ' ' + options?.style?.selected) :\n            (' ' + options?.style?.unselected))\"\n          [innerHTML]=\"setTabTitle(item, i)\"\n          (click)=\"select(i)\"></a>\n      </li>\n    </ul>\n\n    <div *ngFor=\"let layoutItem of layoutNode?.items; let i = index\"\n      [class]=\"options?.htmlClass || ''\">\n\n      <select-framework-widget *ngIf=\"selectedItem === i\"\n        [class]=\"(options?.fieldHtmlClass || '') +\n          ' ' + (options?.activeClass || '') +\n          ' ' + (options?.style?.selected || '')\"\n        [dataIndex]=\"layoutNode?.dataType === 'array' ? (dataIndex || []).concat(i) : dataIndex\"\n        [layoutIndex]=\"(layoutIndex || []).concat(i)\"\n        [layoutNode]=\"layoutItem\"></select-framework-widget>\n\n    </div>`,\n  styles: [` a { cursor: pointer; } `],\n})\nexport class TabsComponent implements OnInit {\n  options: any;\n  itemCount: number;\n  selectedItem = 0;\n  showAddTab = true;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.itemCount = this.layoutNode.items.length - 1;\n    this.updateControl();\n  }\n\n  select(index) {\n    if (this.layoutNode.items[index].type === '$ref') {\n      this.itemCount = this.layoutNode.items.length;\n      this.jsf.addItem({\n        layoutNode: this.layoutNode.items[index],\n        layoutIndex: this.layoutIndex.concat(index),\n        dataIndex: this.dataIndex.concat(index)\n      });\n      this.updateControl();\n    }\n    this.selectedItem = index;\n  }\n\n  updateControl() {\n    const lastItem = this.layoutNode.items[this.layoutNode.items.length - 1];\n    if (lastItem.type === '$ref' &&\n      this.itemCount >= (lastItem.options.maxItems || 1000)\n    ) {\n      this.showAddTab = false;\n    }\n  }\n\n  setTabTitle(item: any, index: number): string {\n    return this.jsf.setArrayItemTitle(this, item, index);\n  }\n}\n","import {\n  Component,\n  ComponentFactoryResolver,\n  ComponentRef,\n  Input,\n  OnChanges,\n  OnInit,\n  ViewChild,\n  ViewContainerRef\n  } from '@angular/core';\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'template-widget',\n  template: `<div #widgetContainer></div>`,\n})\nexport class TemplateComponent implements OnInit, OnChanges {\n  newComponent: ComponentRef<any> = null;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n  @ViewChild('widgetContainer', { read: ViewContainerRef , static: true})\n    widgetContainer: ViewContainerRef;\n\n  constructor(\n    private componentFactory: ComponentFactoryResolver,\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.updateComponent();\n  }\n\n  ngOnChanges() {\n    this.updateComponent();\n  }\n\n  updateComponent() {\n    if (this.widgetContainer && !this.newComponent && this.layoutNode.options.template) {\n      this.newComponent = this.widgetContainer.createComponent(\n        this.componentFactory.resolveComponentFactory(this.layoutNode.options.template)\n      );\n    }\n    if (this.newComponent) {\n      for (const input of ['layoutNode', 'layoutIndex', 'dataIndex']) {\n        this.newComponent.instance[input] = this[input];\n      }\n    }\n  }\n}\n","import { AbstractControl } from '@angular/forms';\nimport { Component, Input, OnInit } from '@angular/core';\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'textarea-widget',\n  template: `\n    <div\n      [class]=\"options?.htmlClass || ''\">\n      <label *ngIf=\"options?.title\"\n        [attr.for]=\"'control' + layoutNode?._id\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></label>\n      <textarea *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"></textarea>\n      <textarea *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [value]=\"controlValue\"\n        (input)=\"updateValue($event)\">{{controlValue}}</textarea>\n    </div>`,\n})\nexport class TextareaComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n","import { AddReferenceComponent } from './add-reference.component';\nimport { ButtonComponent } from './button.component';\nimport { CheckboxComponent } from './checkbox.component';\nimport { CheckboxesComponent } from './checkboxes.component';\nimport { FileComponent } from './file.component';\nimport { hasOwn } from '../shared/utility.functions';\nimport { Injectable } from '@angular/core';\nimport { InputComponent } from './input.component';\nimport { MessageComponent } from './message.component';\nimport { NoneComponent } from './none.component';\nimport { NumberComponent } from './number.component';\nimport { OneOfComponent } from './one-of.component';\nimport { RadiosComponent } from './radios.component';\nimport { RootComponent } from './root.component';\nimport { SectionComponent } from './section.component';\nimport { SelectComponent } from './select.component';\nimport { SelectFrameworkComponent } from './select-framework.component';\nimport { SelectWidgetComponent } from './select-widget.component';\nimport { SubmitComponent } from './submit.component';\nimport { TabsComponent } from './tabs.component';\nimport { TemplateComponent } from './template.component';\nimport { TextareaComponent } from './textarea.component';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class WidgetLibraryService {\n\n  defaultWidget = 'text';\n  widgetLibrary: any = {\n\n  // Angular JSON Schema Form administrative widgets\n    'none': NoneComponent, // Placeholder, for development - displays nothing\n    'root': RootComponent, // Form root, renders a complete layout\n    'select-framework': SelectFrameworkComponent, // Applies the selected framework to a specified widget\n    'select-widget': SelectWidgetComponent, // Displays a specified widget\n    '$ref': AddReferenceComponent, // Button to add a new array item or $ref element\n\n  // Free-form text HTML 'input' form control widgets <input type=\"...\">\n    'email': 'text',\n    'integer': 'number', // Note: 'integer' is not a recognized HTML input type\n    'number': NumberComponent,\n    'password': 'text',\n    'search': 'text',\n    'tel': 'text',\n    'text': InputComponent,\n    'url': 'text',\n\n  // Controlled text HTML 'input' form control widgets <input type=\"...\">\n    'color': 'text',\n    'date': 'text',\n    'datetime': 'text',\n    'datetime-local': 'text',\n    'month': 'text',\n    'range': 'number',\n    'time': 'text',\n    'week': 'text',\n\n  // Non-text HTML 'input' form control widgets <input type=\"...\">\n    // 'button': <input type=\"button\"> not used, use <button> instead\n    'checkbox': CheckboxComponent, // TODO: Set ternary = true for 3-state ??\n    'file': FileComponent, // TODO: Finish 'file' widget\n    'hidden': 'text',\n    'image': 'text', // TODO: Figure out how to handle these\n    'radio': 'radios',\n    'reset': 'submit', // TODO: Figure out how to handle these\n    'submit': SubmitComponent,\n\n  // Other (non-'input') HTML form control widgets\n    'button': ButtonComponent,\n    'select': SelectComponent,\n    // 'option': automatically generated by select widgets\n    // 'optgroup': automatically generated by select widgets\n    'textarea': TextareaComponent,\n\n  // HTML form control widget sets\n    'checkboxes': CheckboxesComponent, // Grouped list of checkboxes\n    'checkboxes-inline': 'checkboxes', // Checkboxes in one line\n    'checkboxbuttons': 'checkboxes', // Checkboxes as html buttons\n    'radios': RadiosComponent, // Grouped list of radio buttons\n    'radios-inline': 'radios', // Radio controls in one line\n    'radiobuttons': 'radios', // Radio controls as html buttons\n\n  // HTML Layout widgets\n    // 'label': automatically added to data widgets\n    // 'legend': automatically added to fieldsets\n    'section': SectionComponent, // Just a div <div>\n    'div': 'section', // Still just a div <div>\n    'fieldset': 'section', // A fieldset, with an optional legend <fieldset>\n    'flex': 'section', // A flexbox container <div style=\"display: flex\">\n\n  // Non-HTML layout widgets\n    'one-of': OneOfComponent, // A select box that changes another input\n                              // TODO: Finish 'one-of' widget\n    'array': 'section', // A list you can add, remove and reorder <fieldset>\n    'tabarray': 'tabs', // A tabbed version of array\n    'tab': 'section', // A tab group, similar to a fieldset or section <fieldset>\n    'tabs': TabsComponent, // A tabbed set of panels with different controls\n    'message': MessageComponent, // Insert arbitrary html\n    'help': 'message', // Insert arbitrary html\n    'msg': 'message', // Insert arbitrary html\n    'html': 'message', // Insert arbitrary html\n    'template': TemplateComponent, // Insert a custom Angular component\n\n  // Widgets included for compatibility with JSON Form API\n    'advancedfieldset': 'section', // Adds 'Advanced settings' title <fieldset>\n    'authfieldset': 'section', // Adds 'Authentication settings' title <fieldset>\n    'optionfieldset': 'one-of', // Option control, displays selected sub-item <fieldset>\n    'selectfieldset': 'one-of', // Select control, displays selected sub-item <fieldset>\n    'conditional': 'section', // Identical to 'section' (depeciated) <div>\n    'actions': 'section', // Horizontal button list, can only submit, uses buttons as items <div>\n    'tagsinput': 'section', // For entering short text tags <div>\n    // See: http://ulion.github.io/jsonform/playground/?example=fields-checkboxbuttons\n\n  // Widgets included for compatibility with React JSON Schema Form API\n    'updown': 'number',\n    'date-time': 'datetime-local',\n    'alt-datetime': 'datetime-local',\n    'alt-date': 'date',\n\n  // Widgets included for compatibility with Angular Schema Form API\n    'wizard': 'section', // TODO: Sequential panels with \"Next\" and \"Previous\" buttons\n\n  // Widgets included for compatibility with other libraries\n    'textline': 'text',\n\n  // Recommended 3rd-party add-on widgets (TODO: create wrappers for these...)\n    // 'ng2-select': Select control replacement - http://valor-software.com/ng2-select/\n    // 'flatpickr': Flatpickr date picker - https://github.com/chmln/flatpickr\n    // 'pikaday': Pikaday date picker - https://github.com/dbushell/Pikaday\n    // 'spectrum': Spectrum color picker - http://bgrins.github.io/spectrum\n    // 'bootstrap-slider': Bootstrap Slider range control - https://github.com/seiyria/bootstrap-slider\n    // 'ace': ACE code editor - https://ace.c9.io\n    // 'ckeditor': CKEditor HTML / rich text editor - http://ckeditor.com\n    // 'tinymce': TinyMCE HTML / rich text editor - https://www.tinymce.com\n    // 'imageselect': Bootstrap drop-down image selector - http://silviomoreto.github.io/bootstrap-select\n    // 'wysihtml5': HTML editor - http://jhollingworth.github.io/bootstrap-wysihtml5\n    // 'quill': Quill HTML / rich text editor (?) - https://quilljs.com\n  };\n  registeredWidgets: any = { };\n  frameworkWidgets: any = { };\n  activeWidgets: any = { };\n\n  constructor() {\n    this.setActiveWidgets();\n  }\n\n  setActiveWidgets(): boolean {\n    this.activeWidgets = Object.assign(\n      { }, this.widgetLibrary, this.frameworkWidgets, this.registeredWidgets\n    );\n    for (const widgetName of Object.keys(this.activeWidgets)) {\n      let widget: any = this.activeWidgets[widgetName];\n      // Resolve aliases\n      if (typeof widget === 'string') {\n        const usedAliases: string[] = [];\n        while (typeof widget === 'string' && !usedAliases.includes(widget)) {\n          usedAliases.push(widget);\n          widget = this.activeWidgets[widget];\n        }\n        if (typeof widget !== 'string') {\n          this.activeWidgets[widgetName] = widget;\n        }\n      }\n    }\n    return true;\n  }\n\n  setDefaultWidget(type: string): boolean {\n    if (!this.hasWidget(type)) { return false; }\n    this.defaultWidget = type;\n    return true;\n  }\n\n  hasWidget(type: string, widgetSet = 'activeWidgets'): boolean {\n    if (!type || typeof type !== 'string') { return false; }\n    return hasOwn(this[widgetSet], type);\n  }\n\n  hasDefaultWidget(type: string): boolean {\n    return this.hasWidget(type, 'widgetLibrary');\n  }\n\n  registerWidget(type: string, widget: any): boolean {\n    if (!type || !widget || typeof type !== 'string') { return false; }\n    this.registeredWidgets[type] = widget;\n    return this.setActiveWidgets();\n  }\n\n  unRegisterWidget(type: string): boolean {\n    if (!hasOwn(this.registeredWidgets, type)) { return false; }\n    delete this.registeredWidgets[type];\n    return this.setActiveWidgets();\n  }\n\n  unRegisterAllWidgets(unRegisterFrameworkWidgets = true): boolean {\n    this.registeredWidgets = { };\n    if (unRegisterFrameworkWidgets) { this.frameworkWidgets = { }; }\n    return this.setActiveWidgets();\n  }\n\n  registerFrameworkWidgets(widgets: any): boolean {\n    if (widgets === null || typeof widgets !== 'object') { widgets = { }; }\n    this.frameworkWidgets = widgets;\n    return this.setActiveWidgets();\n  }\n\n  unRegisterFrameworkWidgets(): boolean {\n    if (Object.keys(this.frameworkWidgets).length) {\n      this.frameworkWidgets = { };\n      return this.setActiveWidgets();\n    }\n    return false;\n  }\n\n  getWidget(type?: string, widgetSet = 'activeWidgets'): any {\n    if (this.hasWidget(type, widgetSet)) {\n      return this[widgetSet][type];\n    } else if (this.hasWidget(this.defaultWidget, widgetSet)) {\n      return this[widgetSet][this.defaultWidget];\n    } else {\n      return null;\n    }\n  }\n\n  getAllWidgets(): any {\n    return {\n      widgetLibrary: this.widgetLibrary,\n      registeredWidgets: this.registeredWidgets,\n      frameworkWidgets: this.frameworkWidgets,\n      activeWidgets: this.activeWidgets,\n    };\n  }\n}\n","import { Framework } from './framework';\nimport { hasOwn } from '../shared/utility.functions';\nimport { Inject, Injectable } from '@angular/core';\nimport { WidgetLibraryService } from '../widget-library/widget-library.service';\n\n// Possible future frameworks:\n// - Foundation 6:\n//   http://justindavis.co/2017/06/15/using-foundation-6-in-angular-4/\n//   https://github.com/zurb/foundation-sites\n// - Semantic UI:\n//   https://github.com/edcarroll/ng2-semantic-ui\n//   https://github.com/vladotesanovic/ngSemantic\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class FrameworkLibraryService {\n  activeFramework: Framework = null;\n  stylesheets: (HTMLStyleElement|HTMLLinkElement)[];\n  scripts: HTMLScriptElement[];\n  loadExternalAssets = false;\n  defaultFramework: string;\n  frameworkLibrary: { [name: string]: Framework } = {};\n\n  constructor(\n    @Inject(Framework) private frameworks: any[],\n    @Inject(WidgetLibraryService) private widgetLibrary: WidgetLibraryService\n  ) {\n    this.frameworks.forEach(framework =>\n      this.frameworkLibrary[framework.name] = framework\n    );\n    this.defaultFramework = this.frameworks[0].name;\n    this.setFramework(this.defaultFramework);\n  }\n\n  public setLoadExternalAssets(loadExternalAssets = true): void {\n    this.loadExternalAssets = !!loadExternalAssets;\n  }\n\n  public setFramework(\n    framework: string|Framework = this.defaultFramework,\n    loadExternalAssets = this.loadExternalAssets\n  ): boolean {\n    this.activeFramework =\n      typeof framework === 'string' && this.hasFramework(framework) ?\n        this.frameworkLibrary[framework] :\n      typeof framework === 'object' && hasOwn(framework, 'framework') ?\n        framework :\n        this.frameworkLibrary[this.defaultFramework];\n    return this.registerFrameworkWidgets(this.activeFramework);\n  }\n\n  registerFrameworkWidgets(framework: Framework): boolean {\n    return hasOwn(framework, 'widgets') ?\n      this.widgetLibrary.registerFrameworkWidgets(framework.widgets) :\n      this.widgetLibrary.unRegisterFrameworkWidgets();\n  }\n\n  public hasFramework(type: string): boolean {\n    return hasOwn(this.frameworkLibrary, type);\n  }\n\n  public getFramework(): any {\n    if (!this.activeFramework) { this.setFramework('default', true); }\n    return this.activeFramework.framework;\n  }\n\n  public getFrameworkWidgets(): any {\n    return this.activeFramework.widgets || {};\n  }\n\n  public getFrameworkStylesheets(load: boolean = this.loadExternalAssets): string[] {\n    return (load && this.activeFramework.stylesheets) || [];\n  }\n\n  public getFrameworkScripts(load: boolean = this.loadExternalAssets): string[] {\n    return (load && this.activeFramework.scripts) || [];\n  }\n}\n","import cloneDeep from 'lodash/cloneDeep';\nimport isEqual from 'lodash/isEqual';\n\nimport {\n  ChangeDetectionStrategy,\n  ChangeDetectorRef,\n  Component,\n  EventEmitter,\n  Input,\n  OnChanges,\n  OnInit,\n  Output,\n  SimpleChanges,\n} from '@angular/core';\nimport { ControlValueAccessor } from '@angular/forms';\nimport { convertSchemaToDraft6 } from './shared/convert-schema-to-draft6.function';\nimport { forEach, hasOwn } from './shared/utility.functions';\nimport { FrameworkLibraryService } from './framework-library/framework-library.service';\nimport {\n  hasValue,\n  inArray,\n  isArray,\n  isEmpty,\n  isObject\n} from './shared/validator.functions';\nimport { JsonPointer } from './shared/jsonpointer.functions';\nimport { JsonSchemaFormService } from './json-schema-form.service';\nimport { resolveSchemaReferences } from './shared/json-schema.functions';\nimport { WidgetLibraryService } from './widget-library/widget-library.service';\n\n\n/**\n * @module 'JsonSchemaFormComponent' - Angular JSON Schema Form\n *\n * Root module of the Angular JSON Schema Form client-side library,\n * an Angular library which generates an HTML form from a JSON schema\n * structured data model and/or a JSON Schema Form layout description.\n *\n * This library also validates input data by the user, using both validators on\n * individual controls to provide real-time feedback while the user is filling\n * out the form, and then validating the entire input against the schema when\n * the form is submitted to make sure the returned JSON data object is valid.\n *\n * This library is similar to, and mostly API compatible with:\n *\n * - JSON Schema Form's Angular Schema Form library for AngularJs\n *   http://schemaform.io\n *   http://schemaform.io/examples/bootstrap-example.html (examples)\n *\n * - Mozilla's react-jsonschema-form library for React\n *   https://github.com/mozilla-services/react-jsonschema-form\n *   https://mozilla-services.github.io/react-jsonschema-form (examples)\n *\n * - Joshfire's JSON Form library for jQuery\n *   https://github.com/joshfire/jsonform\n *   http://ulion.github.io/jsonform/playground (examples)\n *\n * This library depends on:\n *  - Angular (obviously)                  https://angular.io\n *  - lodash, JavaScript utility library   https://github.com/lodash/lodash\n *  - ajv, Another JSON Schema validator   https://github.com/epoberezkin/ajv\n *\n * In addition, the Example Playground also depends on:\n *  - brace, Browserified Ace editor       http://thlorenz.github.io/brace\n */\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'json-schema-form',\n  templateUrl: './json-schema-form.component.html',\n  changeDetection: ChangeDetectionStrategy.OnPush\n})\nexport class JsonSchemaFormComponent implements ControlValueAccessor, OnChanges, OnInit {\n  debugOutput: any; // Debug information, if requested\n  formValueSubscription: any = null;\n  formInitialized = false;\n  objectWrap = false; // Is non-object input schema wrapped in an object?\n\n  formValuesInput: string; // Name of the input providing the form data\n  previousInputs: { // Previous input values, to detect which input triggers onChanges\n    schema: any, layout: any[], data: any, options: any, framework: any | string,\n    widgets: any, form: any, model: any, JSONSchema: any, UISchema: any,\n    formData: any, loadExternalAssets: boolean, debug: boolean,\n  } = {\n      schema: null, layout: null, data: null, options: null, framework: null,\n      widgets: null, form: null, model: null, JSONSchema: null, UISchema: null,\n      formData: null, loadExternalAssets: null, debug: null,\n    };\n\n  // Recommended inputs\n  @Input() schema: any; // The JSON Schema\n  @Input() layout: any[]; // The form layout\n  @Input() data: any; // The form data\n  @Input() options: any; // The global form options\n  @Input() framework: any | string; // The framework to load\n  @Input() widgets: any; // Any custom widgets to load\n\n  // Alternate combined single input\n  @Input() form: any; // For testing, and JSON Schema Form API compatibility\n\n  // Angular Schema Form API compatibility input\n  @Input() model: any; // Alternate input for form data\n\n  // React JSON Schema Form API compatibility inputs\n  @Input() JSONSchema: any; // Alternate input for JSON Schema\n  @Input() UISchema: any; // UI schema - alternate form layout format\n  @Input() formData: any; // Alternate input for form data\n\n  @Input() ngModel: any; // Alternate input for Angular forms\n\n  @Input() language: string; // Language\n\n  // Development inputs, for testing and debugging\n  @Input() loadExternalAssets: boolean; // Load external framework assets?\n  @Input() debug: boolean; // Show debug information?\n\n  @Input()\n  get value(): any {\n    return this.objectWrap ? this.jsf.data['1'] : this.jsf.data;\n  }\n  set value(value: any) {\n    this.setFormValues(value, false);\n  }\n\n  // Outputs\n  @Output() onChanges = new EventEmitter<any>(); // Live unvalidated internal form data\n  @Output() onSubmit = new EventEmitter<any>(); // Complete validated form data\n  @Output() isValid = new EventEmitter<boolean>(); // Is current data valid?\n  @Output() validationErrors = new EventEmitter<any>(); // Validation errors (if any)\n  @Output() formSchema = new EventEmitter<any>(); // Final schema used to create form\n  @Output() formLayout = new EventEmitter<any>(); // Final layout used to create form\n\n  // Outputs for possible 2-way data binding\n  // Only the one input providing the initial form data will be bound.\n  // If there is no inital data, input '{}' to activate 2-way data binding.\n  // There is no 2-way binding if inital data is combined inside the 'form' input.\n  @Output() dataChange = new EventEmitter<any>();\n  @Output() modelChange = new EventEmitter<any>();\n  @Output() formDataChange = new EventEmitter<any>();\n  @Output() ngModelChange = new EventEmitter<any>();\n\n  onChange: Function;\n  onTouched: Function;\n\n  constructor(\n    private changeDetector: ChangeDetectorRef,\n    private frameworkLibrary: FrameworkLibraryService,\n    private widgetLibrary: WidgetLibraryService,\n    public jsf: JsonSchemaFormService,\n  ) { }\n\n  private resetScriptsAndStyleSheets() {\n    document.querySelectorAll('.ajsf').forEach(element => element.remove());\n  }\n  private loadScripts() {\n    const scripts = this.frameworkLibrary.getFrameworkScripts();\n    scripts.map(script => {\n      const scriptTag: HTMLScriptElement = document.createElement('script');\n      scriptTag.src = script;\n      scriptTag.type = 'text/javascript';\n      scriptTag.async = true;\n      scriptTag.setAttribute('class', 'ajsf');\n      document.getElementsByTagName('head')[0].appendChild(scriptTag);\n    });\n  }\n  private loadStyleSheets() {\n    const stylesheets = this.frameworkLibrary.getFrameworkStylesheets();\n    stylesheets.map(stylesheet => {\n      const linkTag: HTMLLinkElement = document.createElement('link');\n      linkTag.rel = 'stylesheet';\n      linkTag.href = stylesheet;\n      linkTag.setAttribute('class', 'ajsf');\n      document.getElementsByTagName('head')[0].appendChild(linkTag);\n    });\n  }\n  private loadAssets() {\n    this.resetScriptsAndStyleSheets();\n    this.loadScripts();\n    this.loadStyleSheets();\n  }\n  ngOnInit() {\n    this.updateForm();\n    this.loadAssets();\n  }\n\n  ngOnChanges(changes: SimpleChanges) {\n    this.updateForm();\n    // Check if there's changes in Framework then load assets if that's the\n    if (changes.framework) {\n      if (!changes.framework.isFirstChange() &&\n        (changes.framework.previousValue !== changes.framework.currentValue)) {\n        this.loadAssets();\n      }\n    }\n  }\n\n  writeValue(value: any) {\n    this.setFormValues(value, false);\n    if (!this.formValuesInput) { this.formValuesInput = 'ngModel'; }\n  }\n\n  registerOnChange(fn: Function) {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: Function) {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean) {\n    if (this.jsf.formOptions.formDisabled !== !!isDisabled) {\n      this.jsf.formOptions.formDisabled = !!isDisabled;\n      this.initializeForm();\n    }\n  }\n\n  updateForm() {\n    if (!this.formInitialized || !this.formValuesInput ||\n      (this.language && this.language !== this.jsf.language)\n    ) {\n      this.initializeForm();\n    } else {\n      if (this.language && this.language !== this.jsf.language) {\n        this.jsf.setLanguage(this.language);\n      }\n\n      // Get names of changed inputs\n      let changedInput = Object.keys(this.previousInputs)\n        .filter(input => this.previousInputs[input] !== this[input]);\n      let resetFirst = true;\n      if (changedInput.length === 1 && changedInput[0] === 'form' &&\n        this.formValuesInput.startsWith('form.')\n      ) {\n        // If only 'form' input changed, get names of changed keys\n        changedInput = Object.keys(this.previousInputs.form || {})\n          .filter(key => !isEqual(this.previousInputs.form[key], this.form[key]))\n          .map(key => `form.${key}`);\n        resetFirst = false;\n      }\n\n      // If only input values have changed, update the form values\n      if (changedInput.length === 1 && changedInput[0] === this.formValuesInput) {\n        if (this.formValuesInput.indexOf('.') === -1) {\n          this.setFormValues(this[this.formValuesInput], resetFirst);\n        } else {\n          const [input, key] = this.formValuesInput.split('.');\n          this.setFormValues(this[input][key], resetFirst);\n        }\n\n        // If anything else has changed, re-render the entire form\n      } else if (changedInput.length) {\n        this.initializeForm();\n        if (this.onChange) { this.onChange(this.jsf.formValues); }\n        if (this.onTouched) { this.onTouched(this.jsf.formValues); }\n      }\n\n      // Update previous inputs\n      Object.keys(this.previousInputs)\n        .filter(input => this.previousInputs[input] !== this[input])\n        .forEach(input => this.previousInputs[input] = this[input]);\n    }\n  }\n\n  setFormValues(formValues: any, resetFirst = true) {\n    if (formValues) {\n      const newFormValues = this.objectWrap ? formValues['1'] : formValues;\n      if (!this.jsf.formGroup) {\n        this.jsf.formValues = formValues;\n        this.activateForm();\n      } else if (resetFirst) {\n        this.jsf.formGroup.reset();\n      }\n      if (this.jsf.formGroup) {\n        this.jsf.formGroup.patchValue(newFormValues);\n      }\n      if (this.onChange) { this.onChange(newFormValues); }\n      if (this.onTouched) { this.onTouched(newFormValues); }\n    } else {\n      this.jsf.formGroup.reset();\n    }\n  }\n\n  submitForm() {\n    const validData = this.jsf.validData;\n    this.onSubmit.emit(this.objectWrap ? validData['1'] : validData);\n  }\n\n  /**\n   * 'initializeForm' function\n   *\n   * - Update 'schema', 'layout', and 'formValues', from inputs.\n   *\n   * - Create 'schemaRefLibrary' and 'schemaRecursiveRefMap'\n   *   to resolve schema $ref links, including recursive $ref links.\n   *\n   * - Create 'dataRecursiveRefMap' to resolve recursive links in data\n   *   and corectly set output formats for recursively nested values.\n   *\n   * - Create 'layoutRefLibrary' and 'templateRefLibrary' to store\n   *   new layout nodes and formGroup elements to use when dynamically\n   *   adding form components to arrays and recursive $ref points.\n   *\n   * - Create 'dataMap' to map the data to the schema and template.\n   *\n   * - Create the master 'formGroupTemplate' then from it 'formGroup'\n   *   the Angular formGroup used to control the reactive form.\n   */\n  initializeForm() {\n    if (\n      this.schema || this.layout || this.data || this.form || this.model ||\n      this.JSONSchema || this.UISchema || this.formData || this.ngModel ||\n      this.jsf.data\n    ) {\n\n      this.jsf.resetAllValues();  // Reset all form values to defaults\n      this.initializeOptions();   // Update options\n      this.initializeSchema();    // Update schema, schemaRefLibrary,\n      // schemaRecursiveRefMap, & dataRecursiveRefMap\n      this.initializeLayout();    // Update layout, layoutRefLibrary,\n      this.initializeData();      // Update formValues\n      this.activateForm();        // Update dataMap, templateRefLibrary,\n      // formGroupTemplate, formGroup\n\n      // Uncomment individual lines to output debugging information to console:\n      // (These always work.)\n      // console.log('loading form...');\n      // console.log('schema', this.jsf.schema);\n      // console.log('layout', this.jsf.layout);\n      // console.log('options', this.options);\n      // console.log('formValues', this.jsf.formValues);\n      // console.log('formGroupTemplate', this.jsf.formGroupTemplate);\n      // console.log('formGroup', this.jsf.formGroup);\n      // console.log('formGroup.value', this.jsf.formGroup.value);\n      // console.log('schemaRefLibrary', this.jsf.schemaRefLibrary);\n      // console.log('layoutRefLibrary', this.jsf.layoutRefLibrary);\n      // console.log('templateRefLibrary', this.jsf.templateRefLibrary);\n      // console.log('dataMap', this.jsf.dataMap);\n      // console.log('arrayMap', this.jsf.arrayMap);\n      // console.log('schemaRecursiveRefMap', this.jsf.schemaRecursiveRefMap);\n      // console.log('dataRecursiveRefMap', this.jsf.dataRecursiveRefMap);\n\n      // Uncomment individual lines to output debugging information to browser:\n      // (These only work if the 'debug' option has also been set to 'true'.)\n      if (this.debug || this.jsf.formOptions.debug) {\n        const vars: any[] = [];\n        // vars.push(this.jsf.schema);\n        // vars.push(this.jsf.layout);\n        // vars.push(this.options);\n        // vars.push(this.jsf.formValues);\n        // vars.push(this.jsf.formGroup.value);\n        // vars.push(this.jsf.formGroupTemplate);\n        // vars.push(this.jsf.formGroup);\n        // vars.push(this.jsf.schemaRefLibrary);\n        // vars.push(this.jsf.layoutRefLibrary);\n        // vars.push(this.jsf.templateRefLibrary);\n        // vars.push(this.jsf.dataMap);\n        // vars.push(this.jsf.arrayMap);\n        // vars.push(this.jsf.schemaRecursiveRefMap);\n        // vars.push(this.jsf.dataRecursiveRefMap);\n        this.debugOutput = vars.map(v => JSON.stringify(v, null, 2)).join('\\n');\n      }\n      this.formInitialized = true;\n    }\n  }\n\n  /**\n   * 'initializeOptions' function\n   *\n   * Initialize 'options' (global form options) and set framework\n   * Combine available inputs:\n   * 1. options - recommended\n   * 2. form.options - Single input style\n   */\n  private initializeOptions() {\n    if (this.language && this.language !== this.jsf.language) {\n      this.jsf.setLanguage(this.language);\n    }\n    this.jsf.setOptions({ debug: !!this.debug });\n    let loadExternalAssets: boolean = this.loadExternalAssets || false;\n    let framework: any = this.framework || 'default';\n    if (isObject(this.options)) {\n      this.jsf.setOptions(this.options);\n      loadExternalAssets = this.options.loadExternalAssets || loadExternalAssets;\n      framework = this.options.framework || framework;\n    }\n    if (isObject(this.form) && isObject(this.form.options)) {\n      this.jsf.setOptions(this.form.options);\n      loadExternalAssets = this.form.options.loadExternalAssets || loadExternalAssets;\n      framework = this.form.options.framework || framework;\n    }\n    if (isObject(this.widgets)) {\n      this.jsf.setOptions({ widgets: this.widgets });\n    }\n    this.frameworkLibrary.setLoadExternalAssets(loadExternalAssets);\n    this.frameworkLibrary.setFramework(framework);\n    this.jsf.framework = this.frameworkLibrary.getFramework();\n    if (isObject(this.jsf.formOptions.widgets)) {\n      for (const widget of Object.keys(this.jsf.formOptions.widgets)) {\n        this.widgetLibrary.registerWidget(widget, this.jsf.formOptions.widgets[widget]);\n      }\n    }\n    if (isObject(this.form) && isObject(this.form.tpldata)) {\n      this.jsf.setTpldata(this.form.tpldata);\n    }\n  }\n\n  /**\n   * 'initializeSchema' function\n   *\n   * Initialize 'schema'\n   * Use first available input:\n   * 1. schema - recommended / Angular Schema Form style\n   * 2. form.schema - Single input / JSON Form style\n   * 3. JSONSchema - React JSON Schema Form style\n   * 4. form.JSONSchema - For testing single input React JSON Schema Forms\n   * 5. form - For testing single schema-only inputs\n   *\n   * ... if no schema input found, the 'activateForm' function, below,\n   *     will make two additional attempts to build a schema\n   * 6. If layout input - build schema from layout\n   * 7. If data input - build schema from data\n   */\n  private initializeSchema() {\n\n    // TODO: update to allow non-object schemas\n\n    if (isObject(this.schema)) {\n      this.jsf.AngularSchemaFormCompatibility = true;\n      this.jsf.schema = cloneDeep(this.schema);\n    } else if (hasOwn(this.form, 'schema') && isObject(this.form.schema)) {\n      this.jsf.schema = cloneDeep(this.form.schema);\n    } else if (isObject(this.JSONSchema)) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      this.jsf.schema = cloneDeep(this.JSONSchema);\n    } else if (hasOwn(this.form, 'JSONSchema') && isObject(this.form.JSONSchema)) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      this.jsf.schema = cloneDeep(this.form.JSONSchema);\n    } else if (hasOwn(this.form, 'properties') && isObject(this.form.properties)) {\n      this.jsf.schema = cloneDeep(this.form);\n    } else if (isObject(this.form)) {\n      // TODO: Handle other types of form input\n    }\n\n    if (!isEmpty(this.jsf.schema)) {\n\n      // If other types also allowed, render schema as an object\n      if (inArray('object', this.jsf.schema.type)) {\n        this.jsf.schema.type = 'object';\n      }\n\n      // Wrap non-object schemas in object.\n      if (hasOwn(this.jsf.schema, 'type') && this.jsf.schema.type !== 'object') {\n        this.jsf.schema = {\n          'type': 'object',\n          'properties': { 1: this.jsf.schema }\n        };\n        this.objectWrap = true;\n      } else if (!hasOwn(this.jsf.schema, 'type')) {\n\n        // Add type = 'object' if missing\n        if (isObject(this.jsf.schema.properties) ||\n          isObject(this.jsf.schema.patternProperties) ||\n          isObject(this.jsf.schema.additionalProperties)\n        ) {\n          this.jsf.schema.type = 'object';\n\n          // Fix JSON schema shorthand (JSON Form style)\n        } else {\n          this.jsf.JsonFormCompatibility = true;\n          this.jsf.schema = {\n            'type': 'object',\n            'properties': this.jsf.schema\n          };\n        }\n      }\n\n      // If needed, update JSON Schema to draft 6 format, including\n      // draft 3 (JSON Form style) and draft 4 (Angular Schema Form style)\n      this.jsf.schema = convertSchemaToDraft6(this.jsf.schema);\n\n      // Initialize ajv and compile schema\n      this.jsf.compileAjvSchema();\n\n      // Create schemaRefLibrary, schemaRecursiveRefMap, dataRecursiveRefMap, & arrayMap\n      this.jsf.schema = resolveSchemaReferences(\n        this.jsf.schema, this.jsf.schemaRefLibrary, this.jsf.schemaRecursiveRefMap,\n        this.jsf.dataRecursiveRefMap, this.jsf.arrayMap\n      );\n      if (hasOwn(this.jsf.schemaRefLibrary, '')) {\n        this.jsf.hasRootReference = true;\n      }\n\n      // TODO: (?) Resolve external $ref links\n      // // Create schemaRefLibrary & schemaRecursiveRefMap\n      // this.parser.bundle(this.schema)\n      //   .then(schema => this.schema = resolveSchemaReferences(\n      //     schema, this.jsf.schemaRefLibrary,\n      //     this.jsf.schemaRecursiveRefMap, this.jsf.dataRecursiveRefMap\n      //   ));\n    }\n  }\n\n  /**\n   * 'initializeData' function\n   *\n   * Initialize 'formValues'\n   * defulat or previously submitted values used to populate form\n   * Use first available input:\n   * 1. data - recommended\n   * 2. model - Angular Schema Form style\n   * 3. form.value - JSON Form style\n   * 4. form.data - Single input style\n   * 5. formData - React JSON Schema Form style\n   * 6. form.formData - For easier testing of React JSON Schema Forms\n   * 7. (none) no data - initialize data from schema and layout defaults only\n   */\n  private initializeData() {\n    if (hasValue(this.data)) {\n      this.jsf.formValues = cloneDeep(this.data);\n      this.formValuesInput = 'data';\n    } else if (hasValue(this.model)) {\n      this.jsf.AngularSchemaFormCompatibility = true;\n      this.jsf.formValues = cloneDeep(this.model);\n      this.formValuesInput = 'model';\n    } else if (hasValue(this.ngModel)) {\n      this.jsf.AngularSchemaFormCompatibility = true;\n      this.jsf.formValues = cloneDeep(this.ngModel);\n      this.formValuesInput = 'ngModel';\n    } else if (isObject(this.form) && hasValue(this.form.value)) {\n      this.jsf.JsonFormCompatibility = true;\n      this.jsf.formValues = cloneDeep(this.form.value);\n      this.formValuesInput = 'form.value';\n    } else if (isObject(this.form) && hasValue(this.form.data)) {\n      this.jsf.formValues = cloneDeep(this.form.data);\n      this.formValuesInput = 'form.data';\n    } else if (hasValue(this.formData)) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      this.formValuesInput = 'formData';\n    } else if (hasOwn(this.form, 'formData') && hasValue(this.form.formData)) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      this.jsf.formValues = cloneDeep(this.form.formData);\n      this.formValuesInput = 'form.formData';\n    } else {\n      this.formValuesInput = null;\n    }\n  }\n\n  /**\n   * 'initializeLayout' function\n   *\n   * Initialize 'layout'\n   * Use first available array input:\n   * 1. layout - recommended\n   * 2. form - Angular Schema Form style\n   * 3. form.form - JSON Form style\n   * 4. form.layout - Single input style\n   * 5. (none) no layout - set default layout instead\n   *    (full layout will be built later from the schema)\n   *\n   * Also, if alternate layout formats are available,\n   * import from 'UISchema' or 'customFormItems'\n   * used for React JSON Schema Form and JSON Form API compatibility\n   * Use first available input:\n   * 1. UISchema - React JSON Schema Form style\n   * 2. form.UISchema - For testing single input React JSON Schema Forms\n   * 2. form.customFormItems - JSON Form style\n   * 3. (none) no input - don't import\n   */\n  private initializeLayout() {\n\n    // Rename JSON Form-style 'options' lists to\n    // Angular Schema Form-style 'titleMap' lists.\n    const fixJsonFormOptions = (layout: any): any => {\n      if (isObject(layout) || isArray(layout)) {\n        forEach(layout, (value, key) => {\n          if (hasOwn(value, 'options') && isObject(value.options)) {\n            value.titleMap = value.options;\n            delete value.options;\n          }\n        }, 'top-down');\n      }\n      return layout;\n    };\n\n    // Check for layout inputs and, if found, initialize form layout\n    if (isArray(this.layout)) {\n      this.jsf.layout = cloneDeep(this.layout);\n    } else if (isArray(this.form)) {\n      this.jsf.AngularSchemaFormCompatibility = true;\n      this.jsf.layout = cloneDeep(this.form);\n    } else if (this.form && isArray(this.form.form)) {\n      this.jsf.JsonFormCompatibility = true;\n      this.jsf.layout = fixJsonFormOptions(cloneDeep(this.form.form));\n    } else if (this.form && isArray(this.form.layout)) {\n      this.jsf.layout = cloneDeep(this.form.layout);\n    } else {\n      this.jsf.layout = ['*'];\n    }\n\n    // Check for alternate layout inputs\n    let alternateLayout: any = null;\n    if (isObject(this.UISchema)) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      alternateLayout = cloneDeep(this.UISchema);\n    } else if (hasOwn(this.form, 'UISchema')) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      alternateLayout = cloneDeep(this.form.UISchema);\n    } else if (hasOwn(this.form, 'uiSchema')) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      alternateLayout = cloneDeep(this.form.uiSchema);\n    } else if (hasOwn(this.form, 'customFormItems')) {\n      this.jsf.JsonFormCompatibility = true;\n      alternateLayout = fixJsonFormOptions(cloneDeep(this.form.customFormItems));\n    }\n\n    // if alternate layout found, copy alternate layout options into schema\n    if (alternateLayout) {\n      JsonPointer.forEachDeep(alternateLayout, (value, pointer) => {\n        const schemaPointer = pointer\n          .replace(/\\//g, '/properties/')\n          .replace(/\\/properties\\/items\\/properties\\//g, '/items/properties/')\n          .replace(/\\/properties\\/titleMap\\/properties\\//g, '/titleMap/properties/');\n        if (hasValue(value) && hasValue(pointer)) {\n          let key = JsonPointer.toKey(pointer);\n          const groupPointer = (JsonPointer.parse(schemaPointer) || []).slice(0, -2);\n          let itemPointer: string | string[];\n\n          // If 'ui:order' object found, copy into object schema root\n          if (key.toLowerCase() === 'ui:order') {\n            itemPointer = [...groupPointer, 'ui:order'];\n\n            // Copy other alternate layout options to schema 'x-schema-form',\n            // (like Angular Schema Form options) and remove any 'ui:' prefixes\n          } else {\n            if (key.slice(0, 3).toLowerCase() === 'ui:') { key = key.slice(3); }\n            itemPointer = [...groupPointer, 'x-schema-form', key];\n          }\n          if (JsonPointer.has(this.jsf.schema, groupPointer) &&\n            !JsonPointer.has(this.jsf.schema, itemPointer)\n          ) {\n            JsonPointer.set(this.jsf.schema, itemPointer, value);\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * 'activateForm' function\n   *\n   * ...continued from 'initializeSchema' function, above\n   * If 'schema' has not been initialized (i.e. no schema input found)\n   * 6. If layout input - build schema from layout input\n   * 7. If data input - build schema from data input\n   *\n   * Create final layout,\n   * build the FormGroup template and the Angular FormGroup,\n   * subscribe to changes,\n   * and activate the form.\n   */\n  private activateForm() {\n\n    // If 'schema' not initialized\n    if (isEmpty(this.jsf.schema)) {\n\n      // TODO: If full layout input (with no '*'), build schema from layout\n      // if (!this.jsf.layout.includes('*')) {\n      //   this.jsf.buildSchemaFromLayout();\n      // } else\n\n      // If data input, build schema from data\n      if (!isEmpty(this.jsf.formValues)) {\n        this.jsf.buildSchemaFromData();\n      }\n    }\n\n    if (!isEmpty(this.jsf.schema)) {\n\n      // If not already initialized, initialize ajv and compile schema\n      this.jsf.compileAjvSchema();\n\n      // Update all layout elements, add values, widgets, and validators,\n      // replace any '*' with a layout built from all schema elements,\n      // and update the FormGroup template with any new validators\n      this.jsf.buildLayout(this.widgetLibrary);\n\n      // Build the Angular FormGroup template from the schema\n      this.jsf.buildFormGroupTemplate(this.jsf.formValues);\n\n      // Build the real Angular FormGroup from the FormGroup template\n      this.jsf.buildFormGroup();\n    }\n\n    if (this.jsf.formGroup) {\n\n      // Reset initial form values\n      if (!isEmpty(this.jsf.formValues) &&\n        this.jsf.formOptions.setSchemaDefaults !== true &&\n        this.jsf.formOptions.setLayoutDefaults !== true\n      ) {\n        this.setFormValues(this.jsf.formValues);\n      }\n\n      // TODO: Figure out how to display calculated values without changing object data\n      // See http://ulion.github.io/jsonform/playground/?example=templating-values\n      // Calculate references to other fields\n      // if (!isEmpty(this.jsf.formGroup.value)) {\n      //   forEach(this.jsf.formGroup.value, (value, key, object, rootObject) => {\n      //     if (typeof value === 'string') {\n      //       object[key] = this.jsf.parseText(value, value, rootObject, key);\n      //     }\n      //   }, 'top-down');\n      // }\n\n      // Subscribe to form changes to output live data, validation, and errors\n      this.jsf.dataChanges.subscribe(data => {\n        this.onChanges.emit(this.objectWrap ? data['1'] : data);\n        if (this.formValuesInput && this.formValuesInput.indexOf('.') === -1) {\n          this[`${this.formValuesInput}Change`].emit(this.objectWrap ? data['1'] : data);\n        }\n      });\n\n      // Trigger change detection on statusChanges to show updated errors\n      this.jsf.formGroup.statusChanges.subscribe(() => this.changeDetector.markForCheck());\n      this.jsf.isValidChanges.subscribe(isValid => this.isValid.emit(isValid));\n      this.jsf.validationErrorChanges.subscribe(err => this.validationErrors.emit(err));\n\n      // Output final schema, final layout, and initial data\n      this.formSchema.emit(this.jsf.schema);\n      this.formLayout.emit(this.jsf.layout);\n      this.onChanges.emit(this.objectWrap ? this.jsf.data['1'] : this.jsf.data);\n\n      // If validateOnRender, output initial validation and any errors\n      const validateOnRender =\n        JsonPointer.get(this.jsf, '/formOptions/validateOnRender');\n      if (validateOnRender) { // validateOnRender === 'auto' || true\n        const touchAll = (control) => {\n          if (validateOnRender === true || hasValue(control.value)) {\n            control.markAsTouched();\n          }\n          Object.keys(control.controls || {})\n            .forEach(key => touchAll(control.controls[key]));\n        };\n        touchAll(this.jsf.formGroup);\n        this.isValid.emit(this.jsf.isValid);\n        this.validationErrors.emit(this.jsf.ajvErrors);\n      }\n    }\n  }\n}\n","import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'no-framework',\n  templateUrl: './no-framework.component.html',\n})\nexport class NoFrameworkComponent {\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n}\n","import { Injectable } from '@angular/core';\nimport { Framework } from './framework';\nimport { NoFrameworkComponent } from './no-framework.component';\n// No framework - plain HTML controls (styles from form layout only)\n\n@Injectable()\nexport class NoFramework extends Framework {\n  name = 'no-framework';\n\n  framework = NoFrameworkComponent;\n}\n","import { AbstractControl } from '@angular/forms';\nimport { Component, Input, OnInit } from '@angular/core';\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'hidden-widget',\n  template: `\n    <input *ngIf=\"boundControl\"\n      [formControl]=\"formControl\"\n      [id]=\"'control' + layoutNode?._id\"\n      [name]=\"controlName\"\n      type=\"hidden\">\n    <input *ngIf=\"!boundControl\"\n      [disabled]=\"controlDisabled\"\n      [name]=\"controlName\"\n      [id]=\"'control' + layoutNode?._id\"\n      type=\"hidden\"\n      [value]=\"controlValue\">`,\n})\nexport class HiddenComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.jsf.initializeControl(this);\n  }\n}\n","import { Component, Input, OnInit } from '@angular/core';\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'tab-widget',\n  template: `\n    <div [class]=\"options?.htmlClass || ''\">\n      <root-widget\n        [dataIndex]=\"dataIndex\"\n        [layoutIndex]=\"layoutIndex\"\n        [layout]=\"layoutNode.items\"></root-widget>\n    </div>`,\n})\nexport class TabComponent implements OnInit {\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n  }\n}\n","import {\n  Directive,\n  ElementRef,\n  Input,\n  NgZone,\n  OnInit\n  } from '@angular/core';\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n\n/**\n * OrderableDirective\n *\n * Enables array elements to be reordered by dragging and dropping.\n *\n * Only works for arrays that have at least two elements.\n *\n * Also detects arrays-within-arrays, and correctly moves either\n * the child array element or the parent array element,\n * depending on the drop targert.\n *\n * Listeners for movable element being dragged:\n * - dragstart: add 'dragging' class to element, set effectAllowed = 'move'\n * - dragover: set dropEffect = 'move'\n * - dragend: remove 'dragging' class from element\n *\n * Listeners for stationary items being dragged over:\n * - dragenter: add 'drag-target-...' classes to element\n * - dragleave: remove 'drag-target-...' classes from element\n * - drop: remove 'drag-target-...' classes from element, move dropped array item\n */\n@Directive({\n  // tslint:disable-next-line:directive-selector\n  selector: '[orderable]',\n})\nexport class OrderableDirective implements OnInit {\n  arrayLayoutIndex: string;\n  element: any;\n  overParentElement = false;\n  overChildElement = false;\n  @Input() orderable: boolean;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private elementRef: ElementRef,\n    private jsf: JsonSchemaFormService,\n    private ngZone: NgZone\n  ) { }\n\n  ngOnInit() {\n    if (this.orderable && this.layoutNode && this.layoutIndex && this.dataIndex) {\n      this.element = this.elementRef.nativeElement;\n      this.element.draggable = true;\n      this.arrayLayoutIndex = 'move:' + this.layoutIndex.slice(0, -1).toString();\n\n      this.ngZone.runOutsideAngular(() => {\n\n        // Listeners for movable element being dragged:\n\n        this.element.addEventListener('dragstart', (event) => {\n          event.dataTransfer.effectAllowed = 'move';\n          event.dataTransfer.setData('text', '');\n          // Hack to bypass stupid HTML drag-and-drop dataTransfer protection\n          // so drag source info will be available on dragenter\n          const sourceArrayIndex = this.dataIndex[this.dataIndex.length - 1];\n          sessionStorage.setItem(this.arrayLayoutIndex, sourceArrayIndex + '');\n        });\n\n        this.element.addEventListener('dragover', (event) => {\n          if (event.preventDefault) { event.preventDefault(); }\n          event.dataTransfer.dropEffect = 'move';\n          return false;\n        });\n\n        // Listeners for stationary items being dragged over:\n\n        this.element.addEventListener('dragenter', (event) => {\n          // Part 1 of a hack, inspired by Dragster, to simulate mouseover and mouseout\n          // behavior while dragging items - http://bensmithett.github.io/dragster/\n          if (this.overParentElement) {\n            return this.overChildElement = true;\n          } else {\n            this.overParentElement = true;\n          }\n\n          const sourceArrayIndex = sessionStorage.getItem(this.arrayLayoutIndex);\n          if (sourceArrayIndex !== null) {\n            if (this.dataIndex[this.dataIndex.length - 1] < +sourceArrayIndex) {\n              this.element.classList.add('drag-target-top');\n            } else if (this.dataIndex[this.dataIndex.length - 1] > +sourceArrayIndex) {\n              this.element.classList.add('drag-target-bottom');\n            }\n          }\n        });\n\n        this.element.addEventListener('dragleave', (event) => {\n          // Part 2 of the Dragster hack\n          if (this.overChildElement) {\n            this.overChildElement = false;\n          } else if (this.overParentElement) {\n            this.overParentElement = false;\n          }\n\n          const sourceArrayIndex = sessionStorage.getItem(this.arrayLayoutIndex);\n          if (!this.overParentElement && !this.overChildElement && sourceArrayIndex !== null) {\n            this.element.classList.remove('drag-target-top');\n            this.element.classList.remove('drag-target-bottom');\n          }\n        });\n\n        this.element.addEventListener('drop', (event) => {\n          this.element.classList.remove('drag-target-top');\n          this.element.classList.remove('drag-target-bottom');\n          // Confirm that drop target is another item in the same array as source item\n          const sourceArrayIndex = sessionStorage.getItem(this.arrayLayoutIndex);\n          const destArrayIndex = this.dataIndex[this.dataIndex.length - 1];\n          if (sourceArrayIndex !== null && +sourceArrayIndex !== destArrayIndex) {\n            // Move array item\n            this.jsf.moveArrayItem(this, +sourceArrayIndex, destArrayIndex);\n          }\n          sessionStorage.removeItem(this.arrayLayoutIndex);\n          return false;\n        });\n\n      });\n    }\n  }\n}\n","import { AddReferenceComponent } from './add-reference.component';\nimport { ButtonComponent } from './button.component';\nimport { CheckboxComponent } from './checkbox.component';\nimport { CheckboxesComponent } from './checkboxes.component';\nimport { FileComponent } from './file.component';\nimport { HiddenComponent } from './hidden.component';\nimport { InputComponent } from './input.component';\nimport { MessageComponent } from './message.component';\nimport { NoneComponent } from './none.component';\nimport { NumberComponent } from './number.component';\nimport { OneOfComponent } from './one-of.component';\nimport { RadiosComponent } from './radios.component';\nimport { RootComponent } from './root.component';\nimport { SectionComponent } from './section.component';\nimport { SelectComponent } from './select.component';\nimport { SelectFrameworkComponent } from './select-framework.component';\nimport { SelectWidgetComponent } from './select-widget.component';\nimport { SubmitComponent } from './submit.component';\nimport { TabComponent } from './tab.component';\nimport { TabsComponent } from './tabs.component';\nimport { TemplateComponent } from './template.component';\nimport { TextareaComponent } from './textarea.component';\n\nexport const BASIC_WIDGETS = [\n  AddReferenceComponent, OneOfComponent, ButtonComponent, CheckboxComponent,\n  CheckboxesComponent, FileComponent, HiddenComponent, InputComponent,\n  MessageComponent, NoneComponent, NumberComponent, RadiosComponent,\n  RootComponent, SectionComponent, SelectComponent, SelectFrameworkComponent,\n  SelectWidgetComponent, SubmitComponent, TabComponent, TabsComponent,\n  TemplateComponent, TextareaComponent\n];\n\nexport { AddReferenceComponent } from './add-reference.component';\nexport { OneOfComponent } from './one-of.component';\nexport { ButtonComponent } from './button.component';\nexport { CheckboxComponent } from './checkbox.component';\nexport { CheckboxesComponent } from './checkboxes.component';\nexport { FileComponent } from './file.component';\nexport { HiddenComponent } from './hidden.component';\nexport { InputComponent } from './input.component';\nexport { MessageComponent } from './message.component';\nexport { NoneComponent } from './none.component';\nexport { NumberComponent } from './number.component';\nexport { OrderableDirective } from './orderable.directive';\nexport { RadiosComponent } from './radios.component';\nexport { RootComponent } from './root.component';\nexport { SectionComponent } from './section.component';\nexport { SelectComponent } from './select.component';\nexport { SelectFrameworkComponent } from './select-framework.component';\nexport { SelectWidgetComponent } from './select-widget.component';\nexport { SubmitComponent } from './submit.component';\nexport { TabComponent } from './tab.component';\nexport { TabsComponent } from './tabs.component';\nexport { TemplateComponent } from './template.component';\nexport { TextareaComponent } from './textarea.component';\nexport { WidgetLibraryService } from './widget-library.service';\n","import { BASIC_WIDGETS } from './index';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { NgModule } from '@angular/core';\nimport { OrderableDirective } from './orderable.directive';\n\n@NgModule({\n  imports: [CommonModule, FormsModule, ReactiveFormsModule],\n  declarations: [...BASIC_WIDGETS, OrderableDirective],\n  exports: [...BASIC_WIDGETS, OrderableDirective],\n  entryComponents: [...BASIC_WIDGETS]\n})\nexport class WidgetLibraryModule {\n}\n","import { CommonModule } from '@angular/common';\nimport { Framework } from './framework';\nimport { NgModule } from '@angular/core';\nimport { NoFramework } from './no.framework';\nimport { NoFrameworkComponent } from './no-framework.component';\nimport { WidgetLibraryModule } from '../widget-library/widget-library.module';\n\n// No framework - plain HTML controls (styles from form layout only)\n\n@NgModule({\n  imports: [CommonModule, WidgetLibraryModule],\n  declarations: [NoFrameworkComponent],\n  exports: [NoFrameworkComponent],\n  providers: [\n    { provide: Framework, useClass: NoFramework, multi: true }\n  ],\n  entryComponents: [NoFrameworkComponent]\n})\nexport class NoFrameworkModule { }\n","import { CommonModule } from '@angular/common';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { NgModule } from '@angular/core';\nimport { JsonSchemaFormComponent } from './json-schema-form.component';\nimport { NoFrameworkModule } from './framework-library/no-framework.module';\nimport { WidgetLibraryModule } from './widget-library/widget-library.module';\n\n@NgModule({\n  imports: [\n    CommonModule, FormsModule, ReactiveFormsModule,\n    WidgetLibraryModule, NoFrameworkModule\n  ],\n  declarations: [JsonSchemaFormComponent],\n  exports: [JsonSchemaFormComponent, WidgetLibraryModule]\n})\nexport class JsonSchemaFormModule {\n}\n","import { longDays, longMonths, shortDays, shortMonths } from '../locale-dates/en-US';\n\n/**\n *\n * @param date\n * @param options\n * return a date string which follows the JSON schema standard\n */\nexport function dateToString(date: string | Date, options: any = {}): string {\n  const dateFormat = options.dateFormat || 'YYYY-MM-DD';\n  // TODO: Use options.locale to change default format and names\n  // const locale = options.locale || 'en-US';\n  date = new Date(date || undefined);\n  if (!date.getDate()) { return null; }\n  const year = date.getFullYear().toString();\n  const month = date.getMonth();\n  const day = date.getDate();\n  const dayOfWeek = date.getDay();\n  return dateFormat\n    .replace(/S/g, getOrdinal(day))\n    .replace(/YYYY/g, year)\n    .replace(/YY/g, year.slice(-2))\n    .replace(/MMMM/g, longMonths[month])\n    .replace(/MMM/g, shortMonths[month])\n    .replace(/MM/g, ('0' + (month + 1)).slice(-2))\n    .replace(/M/g, month + 1)\n    .replace(/DDDD/g, longDays[dayOfWeek])\n    .replace(/DDD/g, shortDays[dayOfWeek])\n    .replace(/DD/g, ('0' + day).slice(-2))\n    .replace(/D/g, day);\n}\n\nexport function getOrdinal(day: number): string {\n  if (day > 3 && day < 21) { return 'th'; }\n  switch (day % 10) {\n    case 1: return 'st';\n    case 2: return 'nd';\n    case 3: return 'rd';\n    default: return 'th';\n  }\n}\n"]}